----------------------------------------------------------------------------------------------------
[ 네트웍 드라이브 ]

    (x) > subst E:     \\10.150.252.70\201506_스템구축

    net use \\IP\IPC$ 패스워드 /USER:아이디
    (o) > net use \\10.150.252.70\201506_시스템구축 file123 /USER:file

        192.168.253.13, ID가 Admin, 패스워드가 1234 일 때 다음과 같습니다.
        -> net use \\192.168.253.13\IPC$ 1234 /USER:Admin

----------------------------------------------------------------------------------------------------
[ 레지스트 변경 ]

    > cmd /c reg add HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\system /v LocalAccountTokenFilterPolicy /t REG_DWORD /d 1 /f
        HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\system\ 에서 오른쪽 클릭 > 새로 만들기 > DWORD(32bit) 클릭하여 값을 만든 후,
        이름을 LocalAccountTokenFilterPolicy 로 정하고 값을 1로 세팅합니다.


----------------------------------------------------------------------------------------------------
[ 원격 서버 종료 ]

    > shutdown -s -t 시간초 -m \\IP

    IP가 192.168.253.13, 시간초를 30000 이라고 할 때 다음과 같습니다.
    > shutdown -s -t 30000 -m \\192.168.253.13




----------------------------------------------------------------------------------------------------
[ 이클립스 환경 ]

    개발 : eclipse luna 32bit jdk 1.7.0_45 32bit

    D:\PROJ\PROG\eclipse_mars\eclipse.exe -vm "D:\PROJ\PROG\jdk1.8.0_60\bin\javaw.exe" -data "D:\PROJ\WORK\workspace_mars"

    N:\tools\eclipse\eclipse.exe -vm N:\tools\jdk\jdk1.7.0_45\bin\javaw.exe -data N:\workspace

    Project 선택 > Properties > Project Facets > Java Version 확인

    subst N: .

    set KANG_DRIVE=K:    -> %KANG_DRIVE%

    K:\PROG\eclipse\eclipse_mars\eclipse.exe -vm "K:\PROG\jdk\jdk1.8.0_60\bin\javaw.exe" -data "K:\WORK\workspace_mars" -showlocation "제목표시줄(타이틀바)"
        -Xverify:none -XX+UseParallelGC -XXPermSize=20M -XXMaxNewSize=32M -XXNewSize=32M -vmargs -Xms512m -Xmx1024m


----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------

01,03,05,07,09,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51,53,55,57,59 * * * * sshpass -p saspw94\!\@ scp -r sas@app02:/sas/sasv94/config/Lev1/Web/WebAppServer/SASServer_/sas_webapps/sas.war/mfile /sas/sasv94/config/Lev1/Web/WebAppServer/SASServer_/sas_webapps/sas.war/ > /dev/null
01,03,05,07,09,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51,53,55,57,59 * * * * sshpass -p saspw94\!\@ scp -r sas@app02:/sas/sasv94/config/Lev1/Web/WebAppServer/SASServer_/sas_webapps/sas.war/bfile /sas/sasv94/config/Lev1/Web/WebAppServer/SASServer_/sas_webapps/sas.war/ > /dev/null

----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
[ SVN 위치 ]

    Server

        svn://mine01/repo-tasks

    Server 종료 / 실행

        $ ps -ef | grep svnserv
        $ svnserve -d -r /sas/svn


    Client

        SVN : Subclipse 1.10.10    other : Subversion - SVN Team Provider 3.0.0


    /sas/svn/repo-tasks

    /sas/svn/repo-tasks/conf/passwd

        ### This file is an example password file for svnserve.
        ### Its format is similar to that of svnserve.conf. As shown in the
        ### example below it contains one section labelled [users].
        ### The name and password for each user follow, one account per line.

        [users]
        # harry = harryssecret
        # sally = sallyssecret
        jenkins = Jen4$$$123
        fic01524=Kang123!


    확인1 : http://pyrasis.com/book/WindowsProjectEssentialUtility/Chapter01
    확인2 : http://pyrasis.com/book/WindowsProjectEssentialUtility/Chapter02#section-1

    ----------------------------------------------------------------------

    참조 사이트

        http://pyrasis.com/private/2014/07/19/open-windows-project-essential-utility-book
            https://github.com/pyrasis/windowsprojectbook
        http://revf.tistory.com/145
        http://www.talkdev.net/jenkins-%EC%84%A4%EC%A0%95%EC%97%90-%EB%8C%80%ED%95%9C-%EC%A0%95%EB%A6%AC/


        위 설명을 참조로 Subversion을 설치한다.

        repository를 생성한다.

            > svnadmin create .\repo-test

        repo-test 폴더가 생기고 아래와 같은 sub 항목이 생긴다.

            conf/
            db/
            hooks/
            locks/
            format
            README.text

        위는 저장소(repository)를 생성한 것이고 이제 서버를 띄워야 한다.

            > svnserve -d -r .\repo-test

        확인한다.

            > svn list svn://localhost:3690/repo-test

        기타 명령

            > svn import antsample file:///blog2book/test/antsample -m "initial import"

            > svn checkout svn://localhost:3690/antsample

            > svn commit build.xml -m "change build files"

        conf 폴더의 svnserve.conf, passwd 파일을 수정하여 svn을 재기동한다.

            > svn commit build.xml -m "change build files" --username kang --password seok






----------------------------------------------------------------------------------------------------
[ CI 위치 ]

    Server 종료 / 실행

        $ cd /sas/jenkins/apache-tomcat-7.0.63/bin

        $ ./catalina.sh stop

        $ ./catalina.sh start

    /sas/jenkins/apache-tomcat-7.0.63

    http://matcmsmine01:8080/jenkins/    :   sas/saspw94!@

----------------------------------------------------------------------------------------------------
[ 쓸모없는 메일 삭제 ]

    cat /dev/null > /var/spool/mail/[계정]


----------------------------------------------------------------------------------------------------
[ Jenkins ]

        /sas/sasuser/sas/.jenkins/jobs/EmartCMSDevDeploy/workspace/SASEMARTCMS

    설치
        $ sudo wget -O /etc/yum.repos.d/jenkins.repo http://pkg.jenkins-ci.org/redhat/jenkins.repo

        .....

        $ sudo rpm --import http://pkg.jenkins-ci.org/redhat/jenkins-ci.org.key
        $ sudo yum install jenkins

        .....

        $ sudo service jenkins start              <- Jenkins를 구동한다.

        /etc/sysconfig/jenkins 파일의 JENKINS_PORT = "8080" 부분을 수정한다.

        $ sudo chkconfig jenkins on                <- Jenkins가 자동으로 시작하도록 서비스 등록


    제공하는 기능

        - 미려한 웹 인터페이스를 통한 간편한 설정
        - 강력하고 편리한 레포팅 기능
        - 지속적인 자동화 빌드
        - 지속적인 자동화 테스트
        - 커버리지 감시
        - 코드 품질 감시
        - 다양한 인증기반과 결합한 인증 및 권한관리 기능
        - Groovy script를 이용한 고수준의 잡 스케줄링 기능
        - 커맨드라인 인터페이스 제공
        - 자동화된 배포 관리
        - 분산빌드 기능
        - 윈도우 커맨드 스케줄링 실행기능

        이 외에도 수많은 플러그인을 통해 간단히 기능을 추가/확장 할 수 있다.

    설치파일 다운로드

        http://jenkins-ci.org/ 사이트에서 jenkins.war 파일을 다운로드 한다.

        > java -jar jenkins.war

        > sc delete jenkins

    Jenkins 설치 및 구동하기

        # Debian/Ubuntu 환경에서 설치

        # jenkins 접속 키 추가
        wget -q -O - http://pkg.jenkins-ci.org/debian/jenkins-ci.org.key | sudo apt-key add -

        # jenkins 저장소 위치 추가
        sudo sh -c 'echo deb http://pkg.jenkins-ci.org/debian binary/ > /etc/apt/sources.list.d/jenkins.list'

        # apt-get 갱신
        sudo apt-get update

        # jenkins 설치
        sudo apt-get install jenkins

        # jenkins.war 위치 파악
        dpkg -L jenkins

        # 수동으로 jenkins 구동
        java -jar /usr/share/jenkins/jenkins.war

        # 8080 포트를 이미 다른 프로세스가 사용하고 있다면 다음과 같은 에러 발생
        Caused by: java.io.IOException: Failed to listen on port 8080

        # 다른 포트를 사용하여 구동
        java -jar /usr/share/jenkins/jenkins.war --httpPort=8888

        # 리눅스 서비스로 등록하여 구동
        sudo service jenkins start

        # 또는 기본 포트 변경하고 구동
        sudo vi /etc/default/jenkins
        HTTP_PORT=8080

        # 접속해 보기
        http://127.0.0.1:8080





        set JAVA_HOME=D:\Java\jdk1.6

        cd "D:\Java\Tomcat 6"
        cmd /c bin\shutdown.bat
        timeout 5
        cmd /c bin\startup.bat


        $ java -jar jenkins.war --httpPort=8888



----------------------------------------------------------------------------------------------------

1. Eclipse > SASEMARTCMS(우클릭) > Team > Synchronize with Repository
2. SVN > Update
3. Pom.xml(우클릭) > Run As > Maven Clean
4. 상단메뉴 > Project > Clean > Clean All Project > OK
5. Pom.xml(우클릭) > Run As > Maven Install
6. SASEMARTCMS > target > EmartCampaign-1.0.0 을 확인한다.

----------------------------------------------------------------------------------------------------

1 도스 명령어
    1.1 APPEND
    1.2 ASSIGN
    1.3 ATTRIB
    1.4 BACKUP, RESTORE
    1.5 BASIC, BASICA
    1.6 CALL
    1.7 CD, CHDIR
    1.8 CHCP
    1.9 CHKDSK
    1.10 CHOICE
    1.11 CLS
    1.12 COPY
    1.13 CTTY
    1.14 DATE
    1.15 DEFRAG
    1.16 DEL, ERASE
    1.17 DELTREE
    1.18 DIR
    1.19 ECHO
    1.20 EDIT
    1.21 EDLIN
    1.22 EXE2BIN
    1.23 EXIT
    1.24 FASTOPEN
    1.25 FC, COMP
    1.26 FDISK
    1.27 FIND
    1.28 FOR
    1.29 FORMAT
    1.30 HELP
    1.31 INTERSVR, INTERLINK
    1.32 JOIN
    1.33 LABEL
    1.34 LOADFIX
    1.35 LOADHIGH, LH
    1.36 MD, MKDIR
    1.37 MEM
    1.38 MEMMAKER
    1.39 MODE
    1.40 MORE
    1.41 MOVE
    1.42 MSD
    1.43 PATH
    1.44 PAUSE
    1.45 PRINT
    1.46 RD, RMDIR
    1.47 RECOVER
    1.48 REM
    1.49 REN
    1.50 SCANDISK
    1.51 SET
    1.52 SETVER
    1.53 SHARE
    1.54 SMARTDRIVE
    1.55 SORT
    1.56 SUBST
    1.57 SYS
    1.58 TIME
    1.59 TREE
    1.60 TRUENAME
    1.61 TYPE
    1.62 UNDELTEE
    1.63 VER
    1.64 VERIFY
    1.65 XCOPY

----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------

[ PC 세팅 ]

    1. 환경변수 세팅 : 컴퓨터 > 속성

        시스템 변수

            WORK_DRIVE=K:
            JAVA_HOME=       <- 변경가능

        사용자 변수

            PATH=%PATH%;%JAVA_HOME%\bin

    2. jenkins 설치

        jenkins-1.631.zip 파일을 압축풀어서 setup.exe 파일을 실행한다.

    3. SVN (Subversion) 설치

        Setup-Subversion-1.6.6.msi 파일을 실행한다.

        SVN Manager Tool  : SVNManager-1.1.2-Setup.msi             <- 별로
        Eclipse Plugin    : Eclipse Subversion site-1.10.10.zip
        Subversion Client : TortoiseSVN-1.9.2.26806-x64-svn-1.9.2.msi
        Subversion SRC    : subversion_src-1.9.2.zip

    4. Maven을 설치한다.

        apache-maven-3.3.3-bin.zip 파일을 특정위치에 압축을 풀어서 사용한다.

    5. 설치 프로그램 확인-1 : 폴더확인

        C:\Program Files (x86)\jenkins
        C:\Program Files (x86)\Subversion

    6. 설치 프로그램 확인-2 : 제어판 > 프로그램

        Jenkins 1.631
        Subversion

    7. 설치 프로그램 확인-3 : 서비스 확인 : 컴퓨터 > 관리 > 서비스

        > sc qc     jenkins
        > sc query  jenkins
        > sc start  jenkins
        > sc stop   jenkins
        > sc delete jenkins

        서비스에는 driver/service 두 종류가 있다.

        > sc query               | more
        > sc query type= driver  | more
        > sc query type= service | more
        > sc query type= all     | more

    8. SVN Repository 생성

        8.1. 사용자 변수의 PATH 항목에 추가한다.

            PATH=%PATH%;%ProgramFiles(x86)%\Subversion\bin;

        8.2. Repository root 폴더로 이동한다. 그리고 프로젝트를 위한 TEST_PRJ 저장소(repository)를 생성한다.
            그리고 생성된 폴더를 확인한다. 인증을 위한 계정을 만든다.

            예) K:\PROG\_Repo_

            > svnadmin create TEST_PRJ
            > tree

                SSD250DATA 볼륨에 대한 폴더 경로의 목록입니다.
                볼륨 일련 번호는 8EB4-DD7F입니다.
                K:.
                └─TEST_PRJ
                    ├─conf
                    ├─db
                    │  ├─revprops
                    │  │  └─0
                    │  ├─revs
                    │  │  └─0
                    │  ├─transactions
                    │  └─txn-protorevs
                    ├─hooks
                    └─locks

            > type TEST_PRJ\conf\svnserve.conf

                ### This file controls the configuration of the svnserve daemon, if you
                ### use it to allow access to this repository.  (If you only allow
                ### access through http: and/or file: URLs, then this file is
                ### irrelevant.)

                ### Visit http://subversion.tigris.org/ for more information.

                [general]
                ### These options control access to the repository for unauthenticated
                ### and authenticated users.  Valid values are "write", "read",
                ### and "none".  The sample settings below are the defaults.
                # anon-access = read
                # auth-access = write
                ### The password-db option controls the location of the password
                ### database file.  Unless you specify a path starting with a /,
                ### the file's location is relative to the directory containing
                ### this configuration file.
                ### If SASL is enabled (see below), this file will NOT be used.
                ### Uncomment the line below to use the default password file.
                password-db = passwd                                                         <- 인증관련 확인
                ### The authz-db option controls the location of the authorization
                ### rules for path-based access control.  Unless you specify a path
                ### starting with a /, the file's location is relative to the the
                ### directory containing this file.  If you don't specify an
                ### authz-db, no path-based access control is done.
                ### Uncomment the line below to use the default authorization file.
                # authz-db = authz
                ### This option specifies the authentication realm of the repository.
                ### If two repositories have the same authentication realm, they should
                ### have the same password database, and vice versa.  The default realm
                ### is repository's uuid.
                # realm = My First Repository

                [sasl]
                ### This option specifies whether you want to use the Cyrus SASL
                ### library for authentication. Default is false.
                ### This section will be ignored if svnserve is not built with Cyrus
                ### SASL support; to check, run 'svnserve --version' and look for a line
                ### reading 'Cyrus SASL authentication is available.'
                # use-sasl = true
                ### These options specify the desired strength of the security layer
                ### that you want SASL to provide. 0 means no encryption, 1 means
                ### integrity-checking only, values larger than 1 are correlated
                ### to the effective key length for encryption (e.g. 128 means 128-bit
                ### encryption). The values below are the defaults.
                # min-encryption = 0
                # max-encryption = 256

            > type TEST_PRJ\conf\passwd

                ### This file is an example password file for svnserve.
                ### Its format is similar to that of svnserve.conf. As shown in the
                ### example below it contains one section labelled [users].
                ### The name and password for each user follow, one account per line.

                [users]
                # harry = harryssecret
                # sally = sallyssecret
                admin = admin123                                                               <- 계정관련 확인


        8.3. SVN 서버를 실행한다. 그리고 확인한다.

            > start svnserve -d -r .          <- 서버가 실행 하는 DOS 창이 새로 생긴다.

            > netstat -nab | more
                .....
                 TCP    0.0.0.0:3690           0.0.0.0:0              LISTENING     <- 사용포트 3690  프로그램 svnserve.exe
                [svnserve.exe]
                .....

        8.4. 기존 프로젝트를 PC로 checkout 한다.  -> 확인용

            > svn checkout svn://matcmsmine01/repo-tasks/SASEMARTCMS
            .....

        8.5. 기존 프로젝트를 PC로 export 한다.

            > svn export svn://matcmsmine01/repo-tasks/SASEMARTCMS        <- Local PC에 SASEMARTCMS 폴더가 생긴다.
            .....

        8.5. PC로 export 한 소스를 다른 SVN 저장소(repository)로 import 한다.

            > svn import SASEMARTCMS svn://localhost/TEST_PRJ -m "svn 임포트 로그" --username admin --password admin123
            .....


    9. Jenkins








----------------------------------------------------------------------------------------------------
[ Subversion 명령어 ]

    $ mkdir /home/svn
    $ cd /home/svn
    $ svnadmin create --fs-type bdb  TEST          <- SVN PROJ 생성
    $ svnadmin create --fs-type fsfs TEST
    $ svnserve -d -r /home/svn      <- SVN 서버 실행

    svn checkout(co) : svn 서버에서 소스 내려받기

        > svn checkout svn://xxx.xxx/Test     <- 모두
        > svn checkout -r 100  svn://xxx.xxx/Test test.jsp   <- revision 100번 test.jsp 소스 받기
        > svn checkout -r HEAD svn://xxx.xxx/Test test.jsp   <- 마지막 revision 받기

    svn commit(ci) : svn 서버에 소스 집어 넣기

        > svn commit ./test.jsp

    svn update : 업데이트 commit 하기전에 소스의 충돌을 막기 위해 update를 실행한다.

        A : 추가됨
        C : 충돌됨
        D : 삭제됨
        M : 수정됨
        G : 병합된

        > svn update ./test.jsp

    svn delete (del, remove, rm) : 파일 및 폴더를 삭제한다.

        > svn delete ./test.jsp

    ---------------------------------------------------------------------

    $ svn status //항상 확인할 것. 로컬 작업본의 변경 상태를 보여준다.
    ?      WEB-INF/classes
    M      index.jsp
    M      index.html

    $ svn status - u //서버 저장소의 변경 상태를 보여준다.

    $ svn status board

    $ svn co http://SVN_SERVER:8080/svn/repos/trunk/SSO
    A    SSO/prod
    A    SSO/prod/verify.sso

    $ svn update

    $ svn update board/
    U    board/view.jsp
    업데이트 된 리비전 81.

    $ svn update main/notice.jsp //특정 파일만 업데이트하기

    $ svn commit -m "" test/welcome.html //=-=> 문법 맞나?

    $ svn update
    무시함 '.' //권한이 없는 사용자인 경우였음. root 로 하면 된다.

    $ svn log number.txt

    $ svn diff number.txt //작업본(working copy)의 변경 내용을 볼 때

    $ svn diff -r HEAD number.txt //저장소와 작업본을 비교

    ---------------------------------------------------------------------

    SVN(Subversion)은 형상관리를 위한 도구이다. 다시 말하면 소프트웨어 개발의 버전 관리 시스템이다.

    SVN에서 많이 사용되는 명령어는 다음과 같다.

    checkout 또는 co - 저장소(repository)에서 로컬 작업공간으로 소스를 받아오는 것.
    $ svn checkout 저장소URL [PATH...]
    : 지정된 로컬경로에 저장소의 소스가 복사된다. 경로가 지정안되면 저장소URL의 맨마지막 디렉토리명이 저장될 디렉토리로 사용되어진다. -r 옵션으로 리비전을 지정한 경우엔 해당 리비전의 소스를 가져온다.
    예제) svn checkout -r 99 http://repository/src src
    설명) 저장소에서 리비전 번호 99의 src경로내의 소스를 가져온다.

    update 또는 up - 저장소(repository)의 최신 내용으로 로컬 소스를 갱신 한다.
    $ svn update [PATH...]
    : 기본적으로 최신 리비전을 반영한다. 그러나 -r 옵션으로 리비전을 지정한 경우엔 그 리비전으로 맞춘다.

    commit 또는 ci - 로컬에서 수정된 내용을 저장소에 적용시킨다.
    $ svn commit [PATH...]
    : 기본적으로 이 명령을 내리면 수정 사항을 코멘트할 수 있게 로그 편집기가 실행된다. lock된 파일이나 디렉토리는 commit성공후 자동적으로 unlock된다.

    lock - 저장소의 파일이나 디렉토리를 잠근다.
    $ svn lock TARGET
    : lock이 걸린 파일이나 디렉토리는 다른 사용자가 변경하여 commit할 수 없다. 해당 경로의 작업이 너무 방대하여 그 동안 다른 사용자가 수정하지 못하도록 할때 유용.

    unlock - 저장소의 잠근 파일이나 디렉토리를 풀어준다.
    $ svn unlock TARGET
    : lock의 반대. 기본적으로 lock을 건 사용자가 풀어줘야 한다.

    add - 새 파일이나 디렉토리를 추가한다.
    $ svn add PATH...
    : add 명령은 지정된 PATH의 새로운 파일이나 디렉토리를 버전관리 대상에 등록할 뿐이므로, add후 commit 명령을 수행해야만 실제로 저장소에 해당 파일이 추가된다.

    delete 또는 del, remove, rm - 파일이나 디렉토리를 제거한다.
    $ svn delete PATH...(URL)
    : delete 명령은 add와 반대로 해당 PATH의 파일이나 디렉토리을 버전관리 대상에서 삭제한다. 역시 commit 명령을 수행해야만 실제로 저장소에서 해당 목록이 제거된다. URL로 지정했을 경우 해당 목록은 즉시 저장소에서 제거된다.


    copy 또는 cp - 로컬 사본이나 저장소 내용을 복사한다. 브랜치(branch)를 만들기 위해 사용.
    $ svn copy SRC  DST
    : SRC가 로컬경로이고 DST도 로컬경로일 경우, 로컬복사되고 commit시 저장소에 복사 목록이 추가 저장된다. SRC가 로컬경로이고 DST가 저장소URL일 경우, URL에 복사되고 즉시 commit됨. SRC가 저장소URL이고 DST가 로컬경로일 경우, 로컬로 checkout하고 commit시 저장소에 해당 사본이 추가.
    SRC가 저장소URL이고 DST도 저장소URL일 경우, 저장소 내에 브랜치(branch)를 만듬.

    move 또는 mv, rename, ren - 파일이나 디렉토리의 이름을 바꾸거나 이동시킨다. 이 명령은 copy후 delete와 같다.
    $ svn move SRC  DST
    : SRC가 로컬경로이고 DST도 로컬경로일 경우, 로컬로 rename 또는 move되고 commit시 저장소에 반영된다. SRC가 저장소URL이고 DST도 저장소URL일 경우, 저장소에서 rename,move가 바로 commit됨.

    info - 해당 파일에 대한 정보를 출력한다.
    $ svn info TARGET
    : TARGET의 저장소 URL경로나 마지막 수정 일자등에 대한 정보를 보여준다.

    log - 해당 경로나 파일의 로그( 리비전에 따라 변경된 내역)를 볼수 있다.
    $ svn log [PATH]
    : 지정된 로컬 PATH에 대한 로그를 출력한다. -r 옵션을 지정하면 출력할 리비젼 범위등을 정할 수 있다.
    예제) svn log -r 30:100 test.c
    설명) 리비전 번호 30~100 내에서 test.c에 대한 로그를 출력한다.

    status 또는 stat, st - 로컬 경로의 파일이나 디렉토리의 상태를 보여준다.
    $ svn status [PATH]
    : 해당 파일이 수정, 추가되었는지 등의 정보를 보여준다. -u 옵션을 주면 저장소의 최신 리비젼이 얼마인지 알려준다.

    diff 또는 di - 서로 다른 리비젼 간에 차이점을 출력해준다.
    $ svn diff [-r N:M] TARGET
    : 지정된 파일이나 경로에 대해 이전 리비젼하고 차이점을 보여준다. -r 을 지정하면 리비젼 N과 M사이의 차이점을 출력해준다.
    예제) svn -r 30:45 test
    설명) test 경로내에서 리비젼 번호 30과 45의 차이점을 출력해준다.

    merge - 두 source 사이에 변경 내용을 작업 경로에 적용해준다.
    1. $ svn merge URL1[@N] URL2[@M] [PATH]
    2. $ svn merge [-r N:M] SOURCE [PATH]
    : 1. URL1[리비젼 N]과 URL2[리비젼 M]을 비교하여, 변경 내용을 작업경로에 적용한다.
      2. SOURCE의 리비젼 N과 M을 비교하여, 해당 작업경로에 적용한다.
    merge는 branch로 분리된 source에 대해 각각의 변경 내용을 현재의 작업에 병합하고자 할때 유용하다.

    blame 또는 praise, annotate, ann - 지정한 파일이나 URL의 내용 수정내역을 각 라인별로 보여준다.
    $ svn blame TARGET
    : 해당 파일의 각 라인에 대해 리비젼과 작성자를 나타내 준다. 누가 언제 어떤행을 수정했는지 알수 있음.

    import - 파일과 디렉토리를 저장소에 추가한다.
    $ svn import [PATH] URL

    : URL에 지정된 PATH의 하위 디렉토리는 재귀적으로 추가되며, 필요시 상위 디렉토리가 자동으로 생성된다.

    export - 저장소에서 순수하게 프로그램 소스만 가져온다.
    $ svn export URL [PATH]
    : export는 버전관리를 위한 부속 파일들은 제외하고 순수한 소스만 받아오기 때문에, 주로 source release 용도로 사용되게된다. -r 옵션을 지정해서 해당 리비젼의 소스를 받아올 수 있다.

    [출처] SVN(Subversion) 명령어 사용 방법|작성자 재후니


    ---------------------------------------------------------------------






----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------

[ 한글변환 ]

    1. Eclipse > Window > Preference > General > Workspace > Text file encoding > Other : UTF-8

    2. xml 파일 utf-8    <?xml version="1.0" encoding="utf-8"?>

    3. .bash_profile     export LANG=ko_KR.UTF-8    <->    export LANG=ko_KR.EUC-KR

    4. Xshell 등록정보에서 터미널 > 출력변환 > 인코딩 : 유니코드(UTF-8)







----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------

1. 삭제

    $CATALINA_BASE/bin/catalina.sh 을 편집한다.

        org.apache.catalina.startup.Bootstrap "%@" start >> "$CATALINA_BASE"/logs/catalina.out 2>&1 &

    위와 같이 "$CATALINA_BASE"/logs/catalina.out 으로 로그를 보내는 것을 아래와 같이 변경하여 보내지 않도록 한다.

        org.apache.catalina.startup.Bootstrap "%@" start >> /dev/null 2>&1 &

    if else 로 구성되어서 아마 2군데를 편집해야 할 것이다.

        touch "$CATALINA_BASE"/logs/catalina.out

    쓸데없기 때문에 주석(#) 처리하거나 삭제한다.

2. rotatecatalinalog.sh을 생성하여 cron에 등록한다.

        $ vi rotatecatalinalog.sh

        #!/bin/sh
        LOG_DIR=/util/esb/tomcat6/logs
        DATE=`/bin/date +%Y-%m-%d`
        /bin/nice /bin/cp $LOG_DIR/catalina.out $LOG_DIR/$DATE.catalina.out
        /bin/nice /bin/cat /dev/null > $LOG_DIR/catalina.out

    위와 같이 해당 날짜로 복사하고 원판 catalina.out은 비워주는 sh을 만들어서 crontab에 등록한다.

        $ chmod 755 rotatecatalinalog.sh

        $ crontab -e

            59 23 * * * /util/esb/tomcat6/bin/rotatecatalinalog.sh

3. cronolog사용

    http://cronolog.org

        $ cd /home/esb

        $ wget http://cronolog.org/download/cronolog-1.6.2.tar.gz

        # tar xzvf cronolog-1.6.2.tar.gz

        # cd cronolog-1.6.2

        # ./configure --prefix=/home/esb/cronolog

        # make && make install

        # ls -al /home/esb/cronolog/sbin

    $CATALINA_BASE/bin/catalina.sh을 편집한다.

        org.apache.catalina.startup.Bootstrap "$@" start >> "$CATALINA_BASE"/logs/catalina.out 2>&1 &

    ->  org.apache.catalina.startup.Bootstrap "$@" start | /home/esb/cronolog/sbin/cronolog "$CATALINA_BASE"/logs/%Y-%m-%d.catalina.out >> /dev/null 2>&1 &




----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------

/*
 *  [ JAVA SSL PKIX path building failed 오류시 ]
 *
 *
 *  JSSE(Java Secure Socket Extension, J2SE 1.4 이후 버전에는 JSSE가 포함되어 있다.)를 이용하여
 *  SSL 연결을 시도할 때 아래와 같은 exception이 발생할 수 있다. 공인 인증기관에서 받은 인증서가
 *  아닌 개인 인증서를 사용하는 경우 많이 발생할 수 있다.
 *
 *  javax.net.ssl.SSLHandshakeException: sun.security.validator.ValidatorException: PKIX path
 *  building failed: sun.security.provider.certpath.SunCertPathBuilderException: unable to find
 *  valid certification path to requested target
 *
 *  그렇다면 어떻게 해야 하느냐?? 여러 가지 방법이 있지만, 간단한 방법은 서버의 인증서를 신뢰할
 *  수 있는 인증서 목록(KeyStore)에 추가하면 된다. 인증서를 추가하려면 우선 인증서를 받아야겠다.
 *  인증서는 첨부된 파일(installcert.java)을 받아서 컴파일하고 실행하면 된다. 실행시키면 아래와
 *  같은 화면이 나타날 것이다. "ecc.fedora.redhat.com" 부분에 인증서를 원하는 서버의 ip와 port를
 *  써주면 된다.
 *
 *          관련 소스 : installcert.java
 *
 *      % java InstallCert ecc.fedora.redhat.com
 *      Loading KeyStore C:\Program Files\Java\jre1.5.0_08\lib\security\cacerts...
 *      Opening connection to ecc.fedora.redhat.com:443...
 *      Starting SSL handshake...
 *
 *      javax.net.ssl.SSLHandshakeException: sun.security.validator.ValidatorException: PKIX
 *          path building failed: sun.security.provider.certpath.SunCertPathBuilderException: unable
 *          to find valid certification path to requested target
 *      at com.sun.net.ssl.internal.ssl.Alerts.getSSLException(Alerts.java:150)
 *      at com.sun.net.ssl.internal.ssl.SSLSocketImpl.fatal(SSLSocketImpl.java:1476)
 *      at com.sun.net.ssl.internal.ssl.Handshaker.fatalSE(Handshaker.java:174)
 *      at com.sun.net.ssl.internal.ssl.Handshaker.fatalSE(Handshaker.java:168)
 *      at com.sun.net.ssl.internal.ssl.ClientHandshaker.serverCertificate(ClientHandshaker.java:846)
 *      at com.sun.net.ssl.internal.ssl.ClientHandshaker.processMessage(ClientHandshaker.java:106)
 *      at com.sun.net.ssl.internal.ssl.Handshaker.processLoop(Handshaker.java:495)
 *      at com.sun.net.ssl.internal.ssl.Handshaker.process_record(Handshaker.java:433)
 *      at com.sun.net.ssl.internal.ssl.SSLSocketImpl.readRecord(SSLSocketImpl.java:815)
 *      at com.sun.net.ssl.internal.ssl.SSLSocketImpl.performInitialHandshake(SSLSocketImpl.java:1025)
 *      at com.sun.net.ssl.internal.ssl.SSLSocketImpl.startHandshake(SSLSocketImpl.java:1038)
 *      at InstallCert.main(InstallCert.java:63)
 *      Caused by: sun.security.validator.ValidatorException: PKIX path building failed: sun.security.
 *          provider.certpath.SunCertPathBuilderException: unable to find valid certification path to requested target
 *      at sun.security.validator.PKIXValidator.doBuild(PKIXValidator.java:221)
 *      at sun.security.validator.PKIXValidator.engineValidate(PKIXValidator.java:145)
 *      at sun.security.validator.Validator.validate(Validator.java:203)
 *      at com.sun.net.ssl.internal.ssl.X509TrustManagerImpl.checkServerTrusted(X509TrustManagerImpl.java:172)
 *      at InstallCert$SavingTrustManager.checkServerTrusted(InstallCert.java:158)
 *      at com.sun.net.ssl.internal.ssl.JsseX509TrustManager.checkServerTrusted(SSLContextImpl.java:320)
 *      at com.sun.net.ssl.internal.ssl.ClientHandshaker.serverCertificate(ClientHandshaker.java:839)
 *      ... 7 more
 *      Caused by: sun.security.provider.certpath.SunCertPathBuilderException: unable to find valid certification path to requested target
 *      at sun.security.provider.certpath.SunCertPathBuilder.engineBuild(SunCertPathBuilder.java:236)
 *      at java.security.cert.CertPathBuilder.build(CertPathBuilder.java:194)
 *      at sun.security.validator.PKIXValidator.doBuild(PKIXValidator.java:216)
 *      ... 13 more
 *
 *      Server sent 2 certificate(s):
 *
 *      1 Subject CN=ecc.fedora.redhat.com, O=example.com, C=US
 *      Issuer CN=Certificate Shack, O=example.com, C=US
 *      sha1 2e 7f 76 9b 52 91 09 2e 5d 8f 6b 61 39 2d 5e 06 e4 d8 e9 c7
 *      md5 dd d1 a8 03 d7 6c 4b 11 a7 3d 74 28 89 d0 67 54
 *
 *      2 Subject CN=Certificate Shack, O=example.com, C=US
 *      Issuer CN=Certificate Shack, O=example.com, C=US
 *      sha1 fb 58 a7 03 c4 4e 3b 0e e3 2c 40 2f 87 64 13 4d df e1 a1 a6
 *      md5 72 a0 95 43 7e 41 88 18 ae 2f 6d 98 01 2c 89 68
 *
 *      Enter certificate to add to trusted keystore or 'q' to quit: [1]
 *
 *  실행시키면 SSL handshake가 일어난다. 화면에는 exception 부분도 출력된다. exception이 출력되는
 *  이유는 서버에서 사용하는 인증서가 없기 때문에 SSL 연결을 성공할 수 없기 때문이다. 자, 인증서를
 *  받자. 그리고 화면에는 trusted KeyStore에 인증서를 추가할 것인지 묻고 있다. sha1과 md5를 확인해서
 *  올바른 인증서인지 확인한 다음, 올바른 인증서인 경우 "1"을 입력해서 인증서를 받으면 되고,
 *  받고 싶지 않은 경우는 "q"를 입력해서 프로그램을 종료시키면 된다. 인증서를 받게 되면 아래와
 *  같은 화면이 출력되고, "jssecacerts" 파일로 인증서가 저장된다.
 *
 *      [
 *      [
 *      Version: V3
 *      Subject: CN=ecc.fedora.redhat.com, O=example.com, C=US
 *      Signature Algorithm: MD5withRSA, OID = 1.2.840.113549.1.1.4
 *
 *      Key: SunPKCS11-Solaris RSA public key, 1024 bits (id 5158256, session object)
 *      modulus: 1402933022884660852748661816869706021655226675890
 *      635441166580364941191074987345500771612454338502131694873337
 *      233737712894815966313948609351561047977102880577818156814678
 *      041303637255354084762814638611185951230474669455913908815827
 *      173696651397340074281578017567044868711049821409365743953199
 *      69584127568303024757
 *      public exponent: 65537
 *      Validity: [From: Wed Jan 18 13:16:12 PST 2006,
 *      To: Wed Apr 18 14:16:12 PDT 2007]
 *      Issuer: CN=Certificate Shack, O=example.com, C=US
 *      SerialNumber: [ 0f]
 *
 *      Certificate Extensions: 2
 *      [1]: ObjectId: 2.16.840.1.113730.1.1 Criticality=false
 *      NetscapeCertType [
 *      SSL server
 *      ]
 *
 *      [2]: ObjectId: 2.5.29.15 Criticality=false
 *      KeyUsage [
 *      Key_Encipherment
 *      ]
 *
 *      ]
 *      Algorithm: [MD5withRSA]
 *      Signature:
 *      0000: 6D F4 2A 63 76 2A 05 70 A2 21 0E 1E 4A 31 BE 6B m.*cv*.p.!..J1.k
 *      0010: 15 64 D8 BB 35 36 82 B0 0D 2A 96 FA 7A 9F A1 59 .d..56...*..z..Y
 *      0020: CA 90 C3 28 C5 A6 9B 59 05 3B EB B2 8D C9 5E 38 ...(...Y.;....^8
 *      0030: 62 ED 1A D7 93 DF 2A A5 D6 54 94 23 15 A2 0C E5 b.....*..T.#....
 *      0040: 13 40 2C 3E 59 E4 2A EB 51 AC 9E 28 44 23 87 B1 .@,>Y.*.Q..(D#..
 *      0050: 34 0B AC F3 E0 39 CA B8 35 B4 78 07 BF 28 4C C4 4....9..5.x..(L.
 *      0060: 9A 2B A3 E9 04 26 78 19 F0 62 EA 0A B5 BB DC 0B .+...&x..b......
 *      0070: 90 59 E7 77 90 F8 BC 8A 1B 74 4B 4D C1 F8 3B 6C .Y.w.....tKM..;l
 *
 *      ]
 *
 *      Added certificate to keystore 'jssecacerts' using alias 'ecc.fedora.redhat.com-1'
 *
 *  이제 이 인증서를 어떻게 사용할까?? 여기에도 몇 가지 방법이 있다. 가장 간단한 방법은
 *  "$JAVA_HOME/jre/lib/security" 폴더에 받은 인증서 파일을 복사하는 방법이다. (이 경우는
 *  파일명을 변경하면 인증서를 찾지 못 한다. 원인은 아직까지는 잘 모르겠다. 본인은
 *  이 방법 대신 다음 방법을 사용한다.)
 *  그리고 다른 방법은 인증서를 원하는 위치로 옮기고 (이 경우는 파일명을 변경해도 상관 없다.)
 *  SSL 연결이 필요한 java 명령을 실행할 때, VM 옵션으로 "-Djavax.net.ssl.trustStore=인증서의
 *  경로(인증서 파일명 포함)"를 추가해주면 된다. 다시 첨부 파일을 실행시켰을 때, 아까와는
 *  다른 아래와 같은 화면이 출력되면 성공이다.
 *
 *      % java InstallCert ecc.fedora.redhat.com
 *      Loading KeyStore jssecacerts...
 *      Opening connection to ecc.fedora.redhat.com:443...
 *      Starting SSL handshake...
 *
 *      No errors, certificate is already trusted
 *
 *      Server sent 2 certificate(s):
 *
 *      1 Subject CN=ecc.fedora.redhat.com, O=example.com, C=US
 *      Issuer CN=Certificate Shack, O=example.com, C=US
 *      sha1 2e 7f 76 9b 52 91 09 2e 5d 8f 6b 61 39 2d 5e 06 e4 d8 e9 c7
 *      md5 dd d1 a8 03 d7 6c 4b 11 a7 3d 74 28 89 d0 67 54
 *
 *      2 Subject CN=Certificate Shack, O=example.com, C=US
 *      Issuer CN=Certificate Shack, O=example.com, C=US
 *      sha1 fb 58 a7 03 c4 4e 3b 0e e3 2c 40 2f 87 64 13 4d df e1 a1 a6
 *      md5 72 a0 95 43 7e 41 88 18 ae 2f 6d 98 01 2c 89 68
 *
 *      Enter certificate to add to trusted keystore or 'q' to quit: [1]
 *      q
 *      KeyStore not changed
 *
 *  위 프로그램 실행으로 생성된 jssecacerts 파일을 %JAVA_HOME%/jre/lib/security 로 복사한다.
 *  그리고 HttpsURLConnection을 실행하면 에러가 생성되지 않는다.
 *
 *      javax.net.ssl.SSLHandshakeException: sun.security.validator.ValidatorException: PKIX
 *          path building failed: sun.security.provider.certpath.SunCertPathBuilderException: unable
 *          to find valid certification path to requested target
 *
 *  위 에러가 해결된다.
 *
 */

import java.io.BufferedReader;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.OutputStream;
import java.security.KeyStore;
import java.security.MessageDigest;
import java.security.cert.CertificateException;
import java.security.cert.X509Certificate;

import javax.net.ssl.SSLContext;
import javax.net.ssl.SSLException;
import javax.net.ssl.SSLSocket;
import javax.net.ssl.SSLSocketFactory;
import javax.net.ssl.TrustManager;
import javax.net.ssl.TrustManagerFactory;
import javax.net.ssl.X509TrustManager;


public class InstallCert {

    public static void main(String[] args) throws Exception {
        String host;
        int port;
        char[] passphrase;
        if ((args.length == 1) || (args.length == 2)) {
            String[] c = args[0].split(":");
            host = c[0];
            port = (c.length == 1) ? 443 : Integer.parseInt(c[1]);
            String p = (args.length == 1) ? "changeit" : args[1];
            passphrase = p.toCharArray();
        } else {
            System.out.println("Usage: java InstallCert <host>[:port] [passphrase]");
            return;
        }

        File file = new File("jssecacerts");
        if (file.isFile() == false) {
            char SEP = File.separatorChar;
            File dir = new File(System.getProperty("java.home") + SEP + "lib" + SEP + "security");
            file = new File(dir, "jssecacerts");
            if (file.isFile() == false) {
                file = new File(dir, "cacerts");
            }
        }
        System.out.println("Loading KeyStore " + file + "...");
        InputStream in = new FileInputStream(file);
        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());
        ks.load(in, passphrase);
        in.close();

        SSLContext context = SSLContext.getInstance("TLS");
        TrustManagerFactory tmf = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());
        tmf.init(ks);
        X509TrustManager defaultTrustManager = (X509TrustManager)tmf.getTrustManagers()[0];
        SavingTrustManager tm = new SavingTrustManager(defaultTrustManager);
        context.init(null, new TrustManager[] {tm}, null);
        SSLSocketFactory factory = context.getSocketFactory();

        System.out.println("Opening connection to " + host + ":" + port + "...");
        SSLSocket socket = (SSLSocket)factory.createSocket(host, port);
        socket.setSoTimeout(10000);
        try {
            System.out.println("Starting SSL handshake...");
            socket.startHandshake();
            socket.close();
            System.out.println();
            System.out.println("No errors, certificate is already trusted");
        } catch (SSLException e) {
            System.out.println();
            e.printStackTrace(System.out);
        }

        X509Certificate[] chain = tm.chain;
        if (chain == null) {
            System.out.println("Could not obtain server certificate chain");
            return;
        }

        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));

        System.out.println();
        System.out.println("Server sent " + chain.length + " certificate(s):");
        System.out.println();
        MessageDigest sha1 = MessageDigest.getInstance("SHA1");
        MessageDigest md5 = MessageDigest.getInstance("MD5");
        for (int i = 0; i < chain.length; i++) {
            X509Certificate cert = chain[i];
            System.out.println(" " + (i + 1) + " Subject " + cert.getSubjectDN());
            System.out.println("   Issuer  " + cert.getIssuerDN());
            sha1.update(cert.getEncoded());
            System.out.println("   sha1    " + toHexString(sha1.digest()));
            md5.update(cert.getEncoded());
            System.out.println("   md5     " + toHexString(md5.digest()));
            System.out.println();
        }

        System.out.println("Enter certificate to add to trusted keystore or 'q' to quit: [1]");
        String line = reader.readLine().trim();
        int k;
        try {
            k = (line.length() == 0) ? 0 : Integer.parseInt(line) - 1;
        } catch (NumberFormatException e) {
            System.out.println("KeyStore not changed");
            return;
        }

        X509Certificate cert = chain[k];
        String alias = host + "-" + (k + 1);
        ks.setCertificateEntry(alias, cert);

        OutputStream out = new FileOutputStream("jssecacerts");
        ks.store(out, passphrase);
        out.close();

        System.out.println();
        System.out.println(cert);
        System.out.println();
        System.out.println("Added certificate to keystore 'jssecacerts' using alias '" + alias + "'");
    }

    private static final char[] HEXDIGITS = "0123456789abcdef".toCharArray();

    private static String toHexString(byte[] bytes) {
        StringBuilder sb = new StringBuilder(bytes.length * 3);
        for (int b : bytes) {
            b &= 0xff;
            sb.append(HEXDIGITS[b >> 4]);
            sb.append(HEXDIGITS[b & 15]);
            sb.append(' ');
        }
        return sb.toString();
    }

    private static class SavingTrustManager implements X509TrustManager {

        private final X509TrustManager tm;
        private X509Certificate[] chain;

        SavingTrustManager(X509TrustManager tm) {
            this.tm = tm;
        }

        public X509Certificate[] getAcceptedIssuers() {
            throw new UnsupportedOperationException();
        }

        public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {
            throw new UnsupportedOperationException();
        }

        public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {
            this.chain = chain;
            tm.checkServerTrusted(chain, authType);
        }
    }
}


----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------

package tain.kr.test.url.v01;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.OutputStream;
import java.security.KeyStore;
import java.security.MessageDigest;
import java.security.cert.CertificateException;
import java.security.cert.X509Certificate;

import javax.net.ssl.SSLContext;
import javax.net.ssl.SSLException;
import javax.net.ssl.SSLSocket;
import javax.net.ssl.SSLSocketFactory;
import javax.net.ssl.TrustManager;
import javax.net.ssl.TrustManagerFactory;
import javax.net.ssl.X509TrustManager;

public class InstallCert2 {

    public static void main(String[] args) throws Exception {
        checkCert();
    }

    public static void checkCert() throws Exception {
        String host = "www.itis.or.kr";
        int port = 443;
        char[] passphrase = "changeit".toCharArray();

        File file = new File("jssecacerts");
        System.out.println(System.getProperty("java.home"));

        if (file.isFile() == false) {
            char SEP = File.separatorChar;
            File dir = new File(System.getProperty("java.home") + SEP + "lib" + SEP + "security");
            file = new File(dir, "jssecacerts");
            if (file.isFile() == false) {
                file = new File(dir, "cacerts");
            }
        }
        System.out.println("Loading KeyStore " + file + "...");
        InputStream in = new FileInputStream(file);
        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());
        ks.load(in, passphrase);
        in.close();

        SSLContext context = SSLContext.getInstance("TLS");
        TrustManagerFactory tmf = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());
        tmf.init(ks);
        X509TrustManager defaultTrustManager = (X509TrustManager)tmf.getTrustManagers()[0];
        SavingTrustManager tm = new SavingTrustManager(defaultTrustManager);
        context.init(null, new TrustManager[] {tm}, null);
        SSLSocketFactory factory = context.getSocketFactory();

        System.out.println("Opening connection to " + host + ":" + port + "...");
        SSLSocket socket = (SSLSocket)factory.createSocket(host, port);
        socket.setSoTimeout(10000);
        try {
            System.out.println("Starting SSL handshake...");
            socket.startHandshake();
            socket.close();
            System.out.println();
            System.out.println("No errors, certificate is already trusted");
            return;
        } catch (SSLException e) {
            System.out.println(e.getMessage());
            //e.printStackTrace(System.out);
        }

        X509Certificate[] chain = tm.chain;
        if (chain == null) {
            System.out.println("Could not obtain server certificate chain");
            return;
        }

        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));

        //System.out.println();
        //System.out.println("Server sent " + chain.length + " certificate(s):");
        //System.out.println();
        MessageDigest sha1 = MessageDigest.getInstance("SHA1");
        MessageDigest md5 = MessageDigest.getInstance("MD5");
        for (int i = 0; i < chain.length; i++) {
            X509Certificate cert = chain[i];
            //System.out.println
            //  (" " + (i + 1) + " Subject " + cert.getSubjectDN());
            //System.out.println("   Issuer  " + cert.getIssuerDN());
            sha1.update(cert.getEncoded());
            //System.out.println("   sha1    " + toHexString(sha1.digest()));
            md5.update(cert.getEncoded());
            //System.out.println("   md5     " + toHexString(md5.digest()));
            //System.out.println();
        }

        //System.out.println("Enter certificate to add to trusted keystore or 'q' to quit: [1]");
        //String line = reader.readLine().trim();
        //int k;
        //try {
        //    k = (line.length() == 0) ? 0 : Integer.parseInt(line) - 1;
        //} catch (NumberFormatException e) {
        //    System.out.println("KeyStore not changed");
        //    return;
        //}

        int k=0;
        X509Certificate cert = chain[k];
        String alias = host + "-" + (k + 1);
        ks.setCertificateEntry(alias, cert);

        OutputStream out = new FileOutputStream("jssecacerts");
        ks.store(out, passphrase);
        out.close();

        //System.out.println();
        //System.out.println(cert);
        //System.out.println();
        System.out.println("Added certificate to keystore 'jssecacerts' using alias '" + alias + "'");
    }

    private static final char[] HEXDIGITS = "0123456789abcdef".toCharArray();

    private static String toHexString(byte[] bytes) {
        StringBuilder sb = new StringBuilder(bytes.length * 3);
        for (int b : bytes) {
            b &= 0xff;
            sb.append(HEXDIGITS[b >> 4]);
            sb.append(HEXDIGITS[b & 15]);
            sb.append(' ');
        }
        return sb.toString();
    }

    private static class SavingTrustManager implements X509TrustManager {

        private final X509TrustManager tm;
        private X509Certificate[] chain;

        SavingTrustManager(X509TrustManager tm) {
            this.tm = tm;
        }

        public X509Certificate[] getAcceptedIssuers() {
            throw new UnsupportedOperationException();
        }

        public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {
            throw new UnsupportedOperationException();
        }

        public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {
            this.chain = chain;
            tm.checkServerTrusted(chain, authType);
        }
    }
}


----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------

웹서버에서 종종 중요한 정보교환을 위해 SSL을 사용하곤 한다.
이번의 경우는 HttpsURLConnection을 통해 SSL연결을 하는데 있어 문제되었던 사항이다.

<환경>
- Tomcat 5.5
- Apache 2.0 OpenSSL 포함 버전
- J2EE 5.X

<문제>
SSL연결시 아래와 같은 Exception이 발생했다.

javax.net.ssl.SSLHandshakeException: sun.security.validator.ValidatorException: PKIX
path building failed: sun.security.provider.certpath.SunCertPathBuilderException: unable
to find valid certification path to requested target

javax.net.ssl.SSLHandshakeException 은 접속하려는 SSL서버에 유효한 인증서가 없는 경우를 의미한다.
이러한 인증서의 위치는 %JRE_HOME%\lib\security 에 cacerts 파일로 존재한다.
즉, 이파일에 현재 접속하려는 SSL서버의 인증서가 존재하지 않는것이다.

<해결>
첨부된 InstallCert.java을 열면 소스 상단부분에
/************** 소스 24째줄 ***************/
String host = "127.0.0.1"; //SSL서버의 도메인이나 IP
 int port = 443;

위와같이 host를 설정하는 부분이 있다. host에는 접속하려는 SSL서버의 IP나 도메인을 설정한다.
이소스는 java.net.ssl.SSLHandshakeException이 발생하면 해당 서버에서 인증서를 받아 파일로
저장해주는 역할을 한다.

컴파일하고 클래스를 실행하면 전과같이 java.net.ssl.SSLHandshakeException이 발생하고 class와
동일한 위치에 jssecacerts라는 인증서 파일이 생성된다. 이 파일을 J2EE 5 설치시 생성해던
%JRE_HOME%\lib\security 에 넣어주면 완료된다.
기존의 cacerts파일에 인증서가 존재하지 않으면 jssecacerts에서 찾는다고 한다.
[출처] HttpsURLConnection 을 사용한 SSL서버 접속|작성자 소요


----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------

사이트 : http://pyrasis.com/book/WindowsProjectEssentialUtility/Chapter01

간단히

    $ svn --help

    $ svn list svn://localhost/repo-tasks --username #### --password #####


[ 버전관리 시스템 용어 ]

    - Repository : 저장소라고 하며 모든 프로젝트의 프로그램 소스들은 이 저장소 안에 저장됩니다.
        그리고 소스뿐만 아니라 소스의 변경 사항도 모두 저장됩니다. 네트워크를 통해서 여러 사람이
        접근할 수 있습니다. 버전관리 시스템마다 고유의 저장소 포맷이 있습니다.

    - Check Out : 저장소에서 소스를 받아오는 것입니다. 체크아웃한 소스를 보면 프로그램 소스가 아닌 다른
        디렉토리와 파일들이 섞여 있는 것을 볼 수 있습니다. 이 디렉토리와 파일들은 버전 관리를 위한 파일들입니다.
        임의로 지우거나 변경하면 저장소와 연결이 되지 않습니다. 이 체크아웃에는 권한을 줄 수 있습니다.
        오픈 소스 프로젝트에서는 대부분 익명 체크아웃을 허용하고 있습니다.

    - Commit : 체크아웃 한 소스를 수정, 파일 추가, 삭제한 뒤 저장소에 저장하고 갱신하는 것입니다. 커밋을
        하면 CVS에서는 수정한 파일의 리비전이 증가하고 Subversion에서는 전체 리비전이 1증가하게 됩니다.
        버전관리 시스템에 따라서는 리비전이 해쉬값인 경우도 있습니다.

    - Update : 체크아웃을 해서 소스를 가져 왔더라도 다른 사람이 커밋을 하였다면 소스가 달라졌을 것입니다.
        이럴 때는 업데이트해서 저장소에 있는 최신 버전의 소스를 가져옵니다. 물론 바뀐부분만 가져옵니다.

    - Revision : 소스 파일 들을 수정하여 커밋하게 되면 일정한 규칙에 따라 숫자가 증가합니다. 버전관리 시스템에
        따라 해쉬값을 사용하는 경우도 있습니다. 저장소에 저장된 각각의 파일 버전이라 할 수 있습니다.
        Subversion은 파일 별로 리비전을 매기지 않고 한번 커밋 한 것으로 전체 리비젼을 매깁니다.
        따라서 리비전을 보고 프로젝트 진행 상황을 알수 있습니다.

    - Import : 아무것도 들어 있지 않은 저장소에 맨 처음 소스를 넣는 작업입니다.

    - Export : 체크아웃과는 달리 버전 관리 파일들을 뺀 순수한 소스파일을 받아올 수 있습니다.
        오픈 소스 프로젝트에서는 소스를 압축해서 릴리즈 할 때 사용합니다.

----------------------------------------------------------------------------------------------------
[ 저장소 접근 방법 ]

    - file://
        로컬파일시스템 접근

    - svn://
        svnserve.exe 프로그램 실행과 서버/클라이언트 접근

    - http://   https://
        아파치 웹서버와 연동하여 접근

    - svn+ssh://
        ssh를 통하여 저장소에 접근



    - trunk : 나무의 몸통을 뜻하는데 프로젝트의 원본이 관리되는 곳입니다.

    - branches : 몸통에서 뻗어나온 나뭇가지를 뜻하는데 개발을 하다 보면 고객시연용 개발발 등과 같이
        원본과는 다른 목적으로 프로젝트가 분기되는 경우가 있습니다. 이런 경우, 프로젝트의 원본을 분기시킨
        버전을 branchs에 만들어 관리하게 됩니다.

    - tags : 꼬리표를 뜻하며, 정기적으로 1.0, 2.0 버전과 같은 식으로 특정 시점의 릴리스를 관리하게 됩니다.


    http://svn.samplerepository.org/svn/sample

        trunk
            src
            doc
            Makefile

        branches
            dev-mirror
                src
                doc
                Makefile
            svn-push
            svnserve-thread-pools

        tags
            0.10
                0.10.1
                    src
                    doc
                    Makefile
            0.20
            0.30
            0.50
            1.01



----------------------------------------------------------------------------------------------------
[ 관련 폴더 ]

    $ mkdir Repos
    $ cd Repos
    $ svnadmin create sample
    $ svnadmin create kang

        C:.
        ├─kang
        │  ├─conf
        │  ├─db
        │  │  ├─revprops
        │  │  │  └─0
        │  │  ├─revs
        │  │  │  └─0
        │  │  ├─transactions
        │  │  └─txn-protorevs
        │  ├─hooks
        │  └─locks
        └─sample
            ├─conf
            ├─db
            │  ├─revprops
            │  │  └─0
            │  ├─revs
            │  │  └─0
            │  ├─transactions
            │  └─txn-protorevs
            ├─hooks
            └─locks

    - conf

        svnserve.conf : svnserve를사용하여 저장소 서버를 구성할 때 사용합니다. 이 파일을 설정해 주지 않으면
            svnserve를 통하여 저장소에 접근 할 수 없습니다.

            [general]
            anon-access = read    # anonymous access로 로그인 여부에 관계없이 접근방식을 설정하는 부분입니다.
                                  # write(쓰기 허용) read(읽기 허용) none(읽기/쓰기 모두 금지)
            auth-access = write   # 로그인 한 사용자에게 한해 접근방식을 설정하는 부분

            password-db = passwd

            authz-db = authz

        passwd : svnserve에서 사용하는 사용자ID와 암호 설정 파일입니다. 암호는 암호화되지 않은 텍스트로 바로 저장됩니다.
            이 파일은 저장소 컴퓨터에 접근 할 수 있는 사람만 볼 수 있기 때문에 암호화 되지 않더라도 큰 문제는
            없습니다. 이미 암호 설정 파일을 볼 정도로 서버에 접근했다 하는 것은 저장소를 모두 가져갈 수 있는 위치에 와
            있다는 것입니다. 암호를 암호화 되지 않은 텍스트로 자장하고 싶지 않은 경우에는 Apache와 연동해야 합니다.

            [users]
            sampleuser = abc123!@

        authz : svnserve와 Apache에서 사용하는 파일, 디렉토리별 접근 권한 설정 파일입니다. 특정 파일, 디렉터리에
            대해 각 사용자에게 읽기, 쓰기 권한을 지정할 수 있습니다. 사용자를 그룹화 하여 지정할 수도 있습니다.

            [groups]

            [/foo/bar]               foo아래 bar 디렉터리에 대한 경로 설정
            [/trunk:/readme.txt]     trunk 디렉터리 아래에 readme.txt 파일에 대한 경로 설정
            [kang:/trunk]            kang 저장소의 trunk 디렉터리에 대한 경로 설정
            [kang:/branches/hello.c] kang 저장소의 trunk 디렉터리 아래에 hello.c 파일에 대한 경로 설정

            사용자       : sampleuser harry
            모든 사용자  : *
            그룹         : @harry_and_sally

            아래는 모든경로에 대해 sampleuser는 읽기, 쓰기를 가능하도록 설정

                [/]
                sampleuser = rw




----------------------------------------------------------------------------------------------------
[ Subversion 서버 사용하기 ]

    서버로 실행하는 방법에는 일반모드와 서비스 모드 두가지가 있습니다. svn://프로토콜 서버인 svnserve를
    사용하는 방법을 설명하도록 하겠습니다. svnserve는 명령행 도구입니다. 윈도우 프롬프트에서 svnserve -help를
    입력하면 옵션들의 도움말을 볼 수 있습니다.

        -d : [daemon] 데몬 모드입니다. svnserve는 일반 모드와 서비스 모드로 실행할 수 있는데 -d는
            일반 모드로 실행하는 옵션입니다.

        --listen-port : 기본 포트 3690 이외의 포트를 사용하고자 할 때 설정합니다.

            -listen-port 12345

        --listen-host : 컴퓨터의 IP가 여러개 일 때 하나의 IP를 지정하여 사용하고자 할 때 설정합니다.

            -listen-host 123.123.123.123

        -r [-root] : 저장소들이 모여 있는 부모 디렉토리나 개별 저장소의 경로를 지정합니다.

            -r C:\Repos

        -service : 서비스 모드로 실행할 때 사용합니다. 이 옵션은 서비스를 따로 등록해주어야 사용할 수 있습니다.
            서비스 모드는 일반 모드와 달리 윈도우 서비스로 등록해서 Subversion 서버를 실행하는 방법입니다.
            서비스 등록을 통해 Subversion 서버의 자동시작 여부를 지정하고 실행할 수 있습니다.
            서비스 모드 등록은 윈도우 관리 명령인 sc명령을 이용합니다.


[ 일반 모드로 사용하기 ]

    svnserve.exe -d -r C:\Repos

    svnserve.exe -d -r C:\Repos --listen-port 7777

[ 서비스 모드로 사용하기 ]

    아래의 \\experience는 'echo %COMPUTERNAME%' 을 해서 나온 값에 \\을 붙인 것이다.

        sc \\experience create svnserve binpath= "C:\Program Files\Subversion\bin\svnserve.exe --service -r C:\Repos" DisplayName= "Subversion svnserve"

        sc create svnserve binpath= "C:\Program Files\Subversion\bin\svnserve.exe --service -r C:\Repos" DisplayName= "Subversion svnserve"

        sc \\experience create svnserve binpath= "C:\Program Files\Subversion\bin\svnserve.exe --service -r C:\Repos --listen-port 7777" DisplayName= "Subversion svnserve"

    서비스 등록을 확인한다. 그리고 명령창에서 net start svnserve, net stop svnserve로 시작/종료할 수 있다.

        sc \\experience delete svnserve

    위와 같이 하면 서비스가 제거된다.


[ 기본 에디터 지정하기 ]

    먼저 Subversion의 svn.exe를 사용하기 위해서는 기본 에디터를 지정해주어야 합니다. 기본 에디터는
    환경변수에 SVN_EDITOR를 만들고 에디터의 실행파일 경로를 설정해 줍니다.
    기본 에디터를 지정하지 않고 사용하려면 svn.exe 명령을 내릴 때 마다 -m "로그 메시지"의 형태로
    로그 메시지를 지정해주면 됩니다.

        svn ci -m "main 함수 수정"

    환경변수 SVN_EDITOR=C:\Windows\notepad.exe

    svnserve.exe를 실행합니다.

        svnserve.exe -d -r C:\Repos

[ 기본 디렉토리 생성 ]

    프로젝트를 시작하기 전 기본 디렉토리인 trunk, branches, tags를 만들어 주어야 합니다.

        svn mkdir svn://127.0.0.1/sample/trunk
        svn mkdir svn://127.0.0.1/sample/branches
        svn mkdir svn://127.0.0.1/sample/tags

        svn mkdir svn://127.0.0.1/sample/trunk     --username kang --password seok123
        svn mkdir svn://127.0.0.1/sample/branches  --username kang --password seok123
        svn mkdir svn://127.0.0.1/sample/tags      --username kang --password seok123



    위와 같이 svn 명령을 실행하면 SVN_EDITOR에 설정한 에디터가 실행되며, 에디터에 적절한 로그 메시지를 입력
    하고 저장한 뒤 종료합니다.
    svn 명령을 처음 실행했다면 그림과 같이 사용자명과 암호를 입력하라고 합니다. 기본적으로 현재 컴퓨터의 계정이
    표시되고 암호를 입력하라고 하는데, 다시 한번 엔터를 치면 사용자면을 입력할 수 있습니다. 암호까지 정확
    하게 입력하면 커밋이 됩니다. 이후 사용자면과 암호는 저장되기 때문에 다시 입력할 필요가 없습니다.
    암호가 저장되지 않게 하려면 -no-auth-cache 옵션을 사용하면 됩니다.

        > svn mkdir svn://127.0.0.1/sample/trunk
        인증 영역(realm): <svn://127.0.0.1:3690> 1860###########################
        'xp'의 암호:
        인증 영역(realm): <svn://127.0.0.1:3690> 1860###########################
        사용자명:sampleuser
        'sampleuser'의 암호:**********

        커밋된 리비전 1.
        >


    * svn:호스트 '127.0.0.1'에 접속할 수 없습니다. : 대상 컴퓨터에서 연결을 거부했으므로 연결하지 못했습니다. 라는 오류 메시지가 나올 때

        1. svnserve.exe 가 정상적으로 실행되고 있는가? (일반모드) 아니라면 새로운 명령프트를 열고
            svnserve.exe -d -r C:\Repos를 실행한다.

        2. 서비스 모드일 경우 서비스를 시작했는가? 아니라면 명령 프롬프트에서 'net start svnserve'를
            실행하거나 관리도구의 서비스에서 Subversion svnserve서비스를 시작합니다.

    * svn:인증 실패 라는 오류 메시지가 나올 때

        1. C:\Repos\sample\conf 디렉토리에 svnserve.conf 파일을 열고 아래와 같이 anon-access, auth-access,
            password-db 가 정상적으로 설정되어 있는지 확인합니다.

                anon-access = none
                auth-access = write
                password-db = passwd

        2. C:\Repos\sample\conf 디렉토리에 svnserve.conf 파일에서 아래와 같이 authz-db=authz로 설정했다면
            C:\Repos\sample\conf 디렉터리 아래에 authz 파일을 다음과 같이 설정되어 있는지 확인

                [/]
                sampleuser = rw

        3. C:\Repos\sample\conf 디렉토리에 passwd 파일을 열고 아래와 같이 사용자 설정이 정상적으로 되어
            있는지 확인합니다.

                [users]
                sampleuser = abc123

        4. C:\Repos\sample\conf 디렉토리의 authz 파일에서 쓰기 권한을 막아놓지는 않았는지 확인합니다.




----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------

		1Chapter. Subversion 레퍼런스

		Table of Contents
		1.1.
		1.1. Subversion 커멘드 라인 클라이언트: svn
		1.1.1. svn 의 스윗치
		1.1.2. svn 서브 커멘드
			svn add -- 파일이나 디렉토리를 추가합니다.
			svn cat -- 지정한 파일 또는 URL의 내용을 표시합니다.
			svn checkout -- 저장소(repository)로부터 작업 카피를 체크아웃 합니다.
			svn cleanup -- 작업 카피를 재귀적으로 정상화한다.
			svn commit -- 작업 카피의 변경점을 저장소(repository)에 보냅니다.
			svn copy -- 작업 카피나 저장소(repository)중의, 파일이나 디렉토리를 카피.
			svn delete -- 작업 카피나 저장소(repository)로부터 파일 또는 디렉토리를 삭제합니다.
			svn diff -- 두 개의 패스동안의 차이점을 표시합니다.
			svn export -- 디렉토리 트리의 export
			svn help -- 헬프
			svn import -- PATH를 URL에 대해서 재귀적으로 커밋합니다.
			svn info -- PATH에 대한 정보를 표시합니다.
			svn list -- 저장소(repository)중의 디렉토리 엔트리를 일람표 가리킵니다.
			svn log -- 커밋 로그 메세지의 표시.
			svn merge -- 두 소스의 차이를 작업 카피 패스에 반영합니다.
			svn mkdir -- 버전 관리하에 있는 새로운 디렉토리를 만듭니다.
			svn move -- 파일이나 디렉토리를 이동한다.
			svn propdel -- 아이템으로부터 속성을 삭제합니다.
			svn propedit -- 버전 관리되고 있는 하나 이상의 아이템의 속성을 편집한다.
			svn propget -- 속성의 값을 표시합니다.
			svn proplist -- 모든 속성을 일람표 가리킵니다.
			svn propset -- 파일, 디렉토리, 리비전의 PROPNAME 의 값 (을)를 PROPVAL로 설정한다.
			svn resolved -- 작업 카피의 파일 또는 디렉토리의 "충돌" 상태를 잡기 들여다 봅니다.
			svn revert -- 로컬 파일에의 모든 편집을 취소합니다.
			svn status -- 작업 카피에 있는 파일이나 디렉토리 상태를 표시.
			svn switch -- 작업 카피를 다른 URL에 갱신합니다.
			svn update -- 작업 카피의 갱신.
		1.2. svnadmin
		1.2.1. svnadmin스윗치
		1.2.2. svnadmin 서브 커멘드
			svnadmin list-unused-dblogs -- 어느 로그 파일이 안전하게 삭제 가능한가를 Berkeley DB 에 문의 .
			svnadmin create -- REPOS_PATH에 신규의 빈 저장소(repository)를 만듭니다.
			svnadmin dump -- 파일 시스템의 내용을 표준 출력에 덤프 합니다.
			svnadmin help --
			svnadmin load -- 표준 입력으로부터"덤프 형식" 의 데이터를 읽어들입니다.
			svnadmin lstxns -- 커밋되어 있지 않은 모든 트랜잭션(transaction)의 이름의 표시.
			svnadmin recover -- 저장소(repository)중이 없어진 상황의 복원.
			svnadmin rmtxns -- 저장소(repository)로부터 트랜잭션(transaction)를 삭제합니다.
			svnadmin setlog -- 리비전에 로그 메세지를 설정합니다.
		1.3. svnlook
		1.3.1. svnlook스윗치
		1.3.2. svnlook 서브 커멘드
			svnlook author -- 처리한 사람의 표시.
			svnlook cat -- 파일의 내용을 표시합니다
			svnlook changed -- 변경된 패스를 표시합니다.
			svnlook date -- 일자를 표시합니다.
			svnlook diff -- 변경된 파일, 디렉토리의 차분을 표시합니다.
			svnlook dirs-changed -- 변경이 있던 디렉토리를 표시합니다.
			svnlook help --
			svnlook history -- 저장소(repository)중의 패스의 히스토리에 관한 정보를 표시합니다 (혹은 패스가 지정되지 않았던 경우에는 루트 디렉토리가 됩니다).
			svnlook info -- 작업자, 일자, 로그 메세지의 크기, 로그 메세지를 표시합니다.
			svnlook log -- 로그 메세지를 표시합니다.
			svnlook proplist -- 버전화 된 파일과 디렉토리의 속성의 이름과 값을 표시합니다.
			svnlook tree -- 트리를 표시합니다.
			svnlook youngest -- 제일 최근의 리비전 번호를 표시합니다.


		1.1.

		이 장은 Subversion의 완전한 레퍼런스입니다. 커멘드 라인 클라이언트 (svn)(와)과 그 모든 서브 커멘드, 한층 더 저장소(repository) 관리 프로그램 (svnadmin와svnlook)(와)과 그 모든 서브 커멘드입니다.

		1.1. Subversion 커멘드 라인 클라이언트: svn

		커멘드 라인 클라이언트를 사용하려면 svn (이)라고 입력하고 나서, 사용하고 싶은 서브 커멘드를 입력해 주세요. [1], 어떤 스윗치나 대상이 된다 타겟으로 붙어도 그렇습니다 서브 커멘드와 스윗치의 및은 특정의 순서는 없습니다. 예를 들어 svn status: (을)를 사용하는 경우에, 이하는 모두 유효합니다:

		$ svn -v status
		$ svn status -v
		$ svn status -v myfile

		클라이언트 커멘드의 이용법에 대해서는, 좀 더 많은 예가 >에 있어, 속성의 관리에 대해서는 >에 있습니다.

		1.1.1. svn 의 스윗치

		Subversion 는 서브 커멘드 마다 다른 스윗치를 가져 있습니다만, 모두 글로벌하게 일합니다즉 각각의 스윗치는 함께 이용되는 서브 커멘드에 관계없이 같은 의미 (을)를 가집니다. 예를 들어--verbose (-v) (은)는 항상, 어느 서브 커멘드와 함께 사용해도"장황한 출력"을 의미합니다.

		--diff-cmd CMD
		파일간의 차이를 표시하기 위해서 사용하는 외부 프로그램을 지정합니다. svn diff가 기동되면(자), 디폴트에서는 unifid diff 형식 인 Subversion의 내부 diff 엔진이 이용됩니다. 외부 diff 프로그램 (을)를 이용하고 싶은 경우는,--diff-cmd를 사용해 주세요. --extensions스윗치로 diff 프로그램을 지정하는 일도로 옵니다. (자세하게는 이 장의 나중에 설명하겠습니다).

		--diff3-cmd CMD
		파일을 merge 하기 위해서 사용하는 외부 프로그램을 지정합니다.

		--dry-run
		커멘드의 실행을 그대로 더듬습니다만, 실제의 동작은 하지 않습니다 작업 카피에 대해서도, 저장소(repository)에 대한 커멘드에도 사용할 수 있습니다.

		--editor-cmd CMD
		로그 메세지나 속성치를 편집하는데 사용하는 외부 프로그램을 지정합니다.

		--encoding ENC
		Subversion 에 커밋의 메세지를 준비한 charset로 encode 하도록(듯이) 지시합니다. 디폴트는 당신의 operating system의 원래의 locale 로, 커밋 메세지개의 encode의 경우에는 그것을 지정할 필요가 있습니다.

		--extensions(-x) "ARGS"
		Subverion 가 파일간의 차이를 얻을 때에 사용하는 외부 diff 커멘드에 건네주지 않고 (이)라고는 안 되는 하나 이상의 인수를 지정합니다. 복수의 인수를 건네주고 싶다 경우는, 그것들 모든 것을 인용부호로 묶지 않으면 안됩니다. (예를 들어, svn diff --diff-cmd /usr/bin/diff -x "-b -E"). 이 스윗치는--diff-cmd스윗치도 지정했을 경우 에마셔이용할 수가 있습니다.

		--file (-F) FILENAME
		지정한 서브 커멘드에 대해, 이 스윗치의 인수로서 건네준 파일의 내용이 사용됩니다.

		--force
		특정의 커멘드 또는 조작의 실행을 강제합니다. Subversion 가 통상이라면 거부하는 것 같은 몇개의 조작이 있습니다만, 이 강제 스윗치를 사용해, Subversion 에"그것을 하면(자) 어떻게 되는 일이 있을까는 알고 있기 때문에, 어쨌든 그것을 시켜 줘"라고 전할 수가 있습니다. 이 스윗치는, 전자 공작이나 무엇인가로, 마지막에 전원을 넣는 상황에 닮습니다무엇을 하려 하고 있는지 잘 이해하고 있지 않으면 반드시 싫은 눈을 당하겠지요.

		--force-log
		--messages (-m)나 --file (-F) 옵션에 건네주는 의심스러운 인수를 올바른 것으로서 강제적으로 받아들인다 같게 지시합니다. 디폴트에서는, Subversion 는 올바른 서브 커멘드로 어느 해석하는 대신에, 그러한 인수가 실수이다고 하여 에러를 생성합니다. 예를 들어, 버전화 된 파일의 패스를--file (-F) 옵션에 건네주면(자), Subversion 는 그 패스가 조작 대상으로 해 의도되고 있었다고 생각하지 않고 , 그 인수에는 실수가 있으면(자) 간주, 로그 메세지를 위한 버전화되어 있지 않은 원파일을 준비하는 것에 실패해 버립니다. 자신의 의도를 선언해, 이런 종류의 에러 (을)를 무시하기 위해서는,--force-log옵션을 로그 메세지 (을)를 받아들이는 커멘드에 대해서 지정할 필요가 있습니다.

		--help (-h or -? )
		하나 이상의 서브 커멘드와 함께 사용해, 각각의 서브 커멘드의 편입 헬프 텍스트를 표시합니다. 이 스윗치만을 단독으로 사용하면(자), 일반적인 커멘드 클라이언트의 헬프 텍스트를 표시합니다.

		--notice-ancestry
		차분을 계산할 경우에, 히스토리에 주의합니다.

		--incremental
		(다른 출력과) 연결하는데 적합한 형식에서 출력을 표시합니다.

		--message (-m) MESSAGE
		커멘드 라인상에서 커밋 메세지를 지정합니다. 이 스윗치의 나중에, 예를 들어:

		$ svn commit -m "They don't make Sunday. "

		--new ARG
		ARG 를 새로운 타겟으로서 이용합니다.

		--no-auth-cache
		인증 정보(유저명이나 패스워드등)를 Subversion 관리 디렉토리에 캐쉬하지 않게 지시합니다.

		--no-diff-deleted
		삭제된 파일의 차분을 표시하지 않게 Subversion에 지시합니다. 디폴트에서는 파일을 삭제했을 때의svn diff의 출력은, 파일은 삭제되지 않고 제로 아르바이트로 남아 있는 것과 같은 형태가 됩니다.

		--no-ignore
		svn:ignore 속성에 성냥 했기 때문에 통상이라면 생략 되는 것 같은 파일의 스테이터스 일람을 표시합니다. > 에 한층 더 자세한 정보가 있습니다.

		--non-interactive
		인증이 실패하거나 충분한 허가가 없을 때에, 인증 요구하는 것을 억제합니다. (예를 들어, 유저명과 패스워드) 이것은, Subversion을 자동 스크립트중에서 실행하고 있는 것 같은 때로 인증 요구시키는 것보다도 단지 실패하는 편이 편리한 경우에 도움이 됩니다.

		--non-recursive (-N)
		서브 디렉토리에 대해서 서브 커멘드를 재귀적으로 실행하는 것을 억제합니다. 대부분의 서브 커멘드는 디폴트로 재귀적으로 실행 됩니다만, 몇개의 서브 커멘드보통은, 작업 카피의 변경에 대한 삭제나 취소가 일어나는 것 같은 것는 그런 것은 없습니다.

		--old ARG
		ARG 를 낡은 타겟으로서 이용합니다.

		--passwordPASS
		커멘드 라인상에서 인증용 패스워드를 지정합니다이것을 지정하지 않으면, 필요한 장소에서 Subversion 는 패스워드 입력을 요구해 옵니다.

		--quiet (-q)
		실행중에 중요한 정보만을 표시하도록(듯이) 지시합니다.

		--recursive (-R)
		서브 커멘드를 서브 디렉토리에 대해서 재귀적으로 실행한다 같게 합니다. 대부분의 서브 커멘드는 디폴트로 재귀적인 동작을 합니다.

		--relocate FROM TO [PATH...]
		svn switch서브 커멘드와 함께 사용하는 것으로 작업 카피 하지만 참조하고 있는 저장소(repository)의 장소를 변경합니다. 이것은, 저장소(repository)의 장소가 이동해도, 벌써 존재하고 있는 작업 카피를 계속해 이용하고 싶은 경우 에 편리합니다. 예로서svn switch를 참조해 주세요.

		--revision (-r) REV
		특정의 조작으로, 리비전(또는 리비전의 범위)을 설정합니다. 리비전은 리비전 스윗치의 인수로서 번호, 키워드, 일자(이 경우는 안외모를 사용해)의 어떤 것인가로 지정할 수가 있습니다. 리비전을 둘지정할 때에는 코론으로 단락짓습니다. 예를 들어:

		$ svn log -r 1729
		$ svn log -r 1729:HEAD
		$ svn log -r 1729:1744
		$ svn log -r {12/04/01}:{2/17/02}
		$ svn log -r 1729:{2/17/02}

		자세하게는> 을 봐 주세요.

		--revprop
		파일이나 디렉토리의 속성의 대신에, 리비전의 속성에 대해 조작하도록(듯이) 합니다. 이 스윗치를 사용하는 경우는 --revision(-r)를 사용해 리비전도 건네줄 필요가 있습니다. 버전화하지 않는 속성에 대한 자세한 것은> (을)를 봐 주세요.

		--show-updates (-u)
		작업 카피의 어느 파일이 최신일까의 정보를 표시합니다. 이것은 실제로 자신에게 작업 파일을 갱신하지 않습니다만약 svn update 를 실행했다고 하면(자), 어느 파일이 갱신되는지를 표시할 뿐입니다.

		--strict
		Subversion은 엄밀한 의미론을 사용하게 됩니다. 자세하게는 > (을)를 참조해 주세요.

		--targets FILENAME
		Subversion 에 커멘드 라인상의 모든 파일을 일람표시 하는 대신에 지정한 파일의 일람을 취득하도록 지시합니다.

		--usernameNAME
		커멘드 라인상에서의 인증에, 지정한 유저 명칭을 사용하도록(듯이) 지시합니다그렇지 않으면, 필요한 장소에서, Subversion은 그 입력을 유저에게 요구합니다.

		--verbose (-v)
		서브 커멘드 실행시에, 할 수 있는 사나워지고 많은 정보를 표시하도록(듯이) 지시합니다. Subversion 는, 추가 필드, 모든 파일의 상세 정보, 동작 내용에 대한 추가 정보등을 표시하게 됩니다.

		--version
		클라이언트 프로그램의 버전 번호를 표시합니다. 이 정보는 버전 번호외, Subversion 저장소(repository)에 클라이언트 프로그램 하지만 액세스 하기 위해서 이용할 수 있는 모듈의 일람도 표시합니다.

		--xml
		XML 포맷으로 출력합니다.

		1.1.2. svn 서브 커멘드

		Table of Contents
			svn add -- 파일이나 디렉토리를 추가합니다.
			svn cat -- 지정한 파일 또는 URL의 내용을 표시합니다.
			svn checkout -- 저장소(repository)로부터 작업 카피를 체크아웃 합니다.
			svn cleanup -- 작업 카피를 재귀적으로 정상화한다.
			svn commit -- 작업 카피의 변경점을 저장소(repository)에 보냅니다.
			svn copy -- 작업 카피나 저장소(repository)중의, 파일이나 디렉토리를 카피.
			svn delete -- 작업 카피나 저장소(repository)로부터 파일 또는 디렉토리를 삭제합니다.
			svn diff -- 두 개의 패스동안의 차이점을 표시합니다.
			svn export -- 디렉토리 트리의 export
			svn help -- 헬프
			svn import -- PATH를 URL에 대해서 재귀적으로 커밋합니다.
			svn info -- PATH에 대한 정보를 표시합니다.
			svn list -- 저장소(repository)중의 디렉토리 엔트리를 일람표 가리킵니다.
			svn log -- 커밋 로그 메세지의 표시.
			svn merge -- 두 소스의 차이를 작업 카피 패스에 반영합니다.
			svn mkdir -- 버전 관리하에 있는 새로운 디렉토리를 만듭니다.
			svn move -- 파일이나 디렉토리를 이동한다.
			svn propdel -- 아이템으로부터 속성을 삭제합니다.
			svn propedit -- 버전 관리되고 있는 하나 이상의 아이템의 속성을 편집한다.
			svn propget -- 속성의 값을 표시합니다.
			svn proplist -- 모든 속성을 일람표 가리킵니다.
			svn propset -- 파일, 디렉토리, 리비전의 PROPNAME 의 값 (을)를 PROPVAL로 설정한다.
			svn resolved -- 작업 카피의 파일 또는 디렉토리의 "충돌" 상태를 잡기 들여다 봅니다.
			svn revert -- 로컬 파일에의 모든 편집을 취소합니다.
			svn status -- 작업 카피에 있는 파일이나 디렉토리 상태를 표시.
			svn switch -- 작업 카피를 다른 URL에 갱신합니다.
			svn update -- 작업 카피의 갱신.
		svn add

		Name

		svn add  -- 파일이나 디렉토리를 추가합니다.
		용법

		svn add PATH...
		설명

		파일이나 디렉토리를 작업 카피에 추가해 저장소(repository)에 추가할 것을 예약 합니다. 실제의 추가는 커밋 명령으로 저장소(repository)에 업로드하여 이루어집니다. 커밋 전에 마음이 바뀌었을 경우엔 svn revert로 추가를 취소할 수 있습니다.

		별명

		없음

		변경 대상

		작업 카피

		스윗치

		--targets FILENAME
		--non-recursive (-N)
		--quiet (-q)

		례

		작업 카피에 파일을 추가:

		$ svn add foo.c
		A         foo.c

		디렉토리를 추가할 때 svn add 의 디폴트는 재귀적입니다:

		$ svn add testdir
		A         testdir
		A         testdir/a
		A         testdir/b
		A         testdir/c
		A         testdir/d

		내부에 있는 파일을 추가하는 것 없이 , 디렉토리만 추가한다 일이 생깁니다:

		$ svn add --non-recursive otherdir
		A         otherdir

		svn cat

		Name

		svn cat  -- 지정한 파일 또는 URL의 내용을 표시합니다.
		용법

		svn cat TARGET...
		설명

		지정한 파일 또는 URL의 내용을 표시합니다. 디렉토리의 내용의 표시에 대해서는,svn list 를 봐 주세요.

		별명

		없음

		변경 대상

		없음

		저장소(repository)에의 액세스

		발생

		스윗치

		--revision (-r) REV
		--username USER
		--password PASS

		례

		체크아웃 하는 것 없이 저장소(repository)중의 readme.txt를 표시하고 싶다 경우:

		$ svn cat http://svn.red-bean.com/repos/test/readme.txt
		This is a README file.
		You should read this.

		Tip: 작업 카피가 최신은 아니다(인가, 작업 카피에 무엇인가 수정을 더했다 경우) 상태로, 작업 카피가 있는 파일의 HEAD 리비전을 보고 싶은 경우, 패스를 지정하면svn cat 는 자동적으로 HEAD 리비전 에 액세스 합니다:

		$ cat foo.c
		This file is in my local working copy
		and has changes that I've made.

		$ svn cat foo.c
		Latest revision fresh from the repository!

		svn checkout

		Name

		svn checkout  -- 저장소(repository)로부터 작업 카피를 체크아웃 합니다.
		용법

		svn checkout URL... [PATH]
		설명

		저장소(repository)로부터 작업 카피를 체크아웃 합니다. PATH 가 생략 되면 카피처로서 URL의 베이스명이 사용됩니다. 복수의 URL가 지정되었을 경우에는, 각각이, PATH의 서브 디렉토리에 체크아웃 됩니다만 여기서의 서브 디렉토리의 이름은 URL의 베이스명이 됩니다.

		별명

		co

		변경 대상

		작업 카피가 새롭게 만들어집니다.

		저장소(repository)에의 액세스

		발생

		스윗치

		--revision (-r) REV
		--quiet (-q)
		--non-recursive (-N)
		--username USER
		--password PASS
		--no-auth-cache
		--non-interactive

		례

		'mine'로 불리는 디렉토리에 작업 카피를 체크아웃:

		$ svn checkout file:///tmp/repos/test mine
		A  mine/a
		A  mine/b
		Checked out revision 2.
		$ ls
		mine

		두 다른 디렉토리를 두 개개의 작업 카피에 체크아웃:

		$ svn checkout file:///tmp/repos/test  file:///tmp/repos/quiz
		A  test/a
		A  test/b
		Checked out revision 2.
		A  quiz/l
		A  quiz/m
		Checked out revision 2.
		$ ls
		quiz  test

		두 다른 디렉토리를 두 개개의 작업 카피에 체크아웃 하지만, 양쪽 모두 'working-copies'로 불린다 디렉토리안에 만든다:

		$ svn checkout file:///tmp/repos/test  file:///tmp/repos/quiz working-copies
		A  working-copies/test/a
		A  working-copies/test/b
		Checked out revision 2.
		A  working-copies/quiz/l
		A  working-copies/quiz/m
		Checked out revision 2.
		$ ls
		working-copies

		체크아웃을 중단한다(가마타는, 네트워크 접속의 불편 등에 의해 체크아웃이 중단될까 할) 경우, 한번 더 순수한 체크아웃을 실행해도, 불완전한 작업 카피를 갱신하는 것도 재개할 수 있습니다:

		$ svn checkout file:///tmp/repos/test test
		A  test/a
		A  test/b
		^C
		svn: The operation was interrupted
		svn: caught SIGINT

		$ svn checkout file:///tmp/repos/test test
		A  test/c
		A  test/d
		^C
		svn: The operation was interrupted
		svn: caught SIGINT

		$ cd test
		$ svn update
		A  test/e
		A  test/f
		Updated to revision 3.

		svn cleanup

		Name

		svn cleanup  -- 작업 카피를 재귀적으로 정상화한다.
		용법

		svn cleanup [PATH...]
		설명

		작업 카피를 재귀적으로 정상화하기 위해(때문에), 조작이 미완료의 락을 삭제합니다. "작업 카피 락"에러가 발생했을 때에는, 이 커멘드를 실행해, 락을 해제해, 작업 카피를 정상적으로 되돌려 주세요. >(을)를 봐 주세요.

		별명

		없음

		변경 대상

		작업 카피

		저장소(repository)에의 액세스

		발생하지 않는다

		스윗치:

		없음

		례

		svn cleanup 는 아무것도 출력하지 않기 때문에, 그다지 예는 없습니다. 만약, PATH 를 지정하지 않으면, '. '를 대신에 사용합니다.

		$ svn cleanup

		$ svn cleanup /path/to/working-copy

		svn commit

		Name

		svn commit  -- 작업 카피의 변경점을 저장소(repository)에 보냅니다.
		용법

		svn commit [PATH...]
		설명

		작업 카피의 변경점을 저장소(repository)에 보냅니다. --file인가, --message 의 옵션을 지정하지 않으면 svn 는 에디터를 기동해, 유저에게 커밋 메세지를 작성시킵니다. >에 있다 editor-cmd 의 장을 봐 주세요.

		Tip: 커밋 처리를 시작해 Subversion가 메세지 작성을 위한 에디터를 기동 한 다음에도 아직 변경을 커밋하지 않고 중단할 수가 있습니다. 커밋을 취소하고 싶다면 커밋 메세지를 보존하지 않고 단지 에디터를 종료 해 주세요. Subversion은 커밋을 중단하는지, 메세지없이 계속 하는지, 메세지를 재편집할까를 (들)물어 옵니다.

		별명

		ci

		ci (short for "check in" 의 단축형으로, "co"의 단축이 아닙니다. "co"는"checkout"의 단축형입니다. )

		변경 대상

		작업 카피, 저장소(repository)

		저장소(repository)에의 액세스

		발생

		스윗치

		--message (-m) TEXT
		--file (-F) FILE
		--quiet (-q)
		--non-recursive (-N)
		--targets FILENAME
		--force-log
		--username USER
		--password PASS
		--no-auth-cache
		--non-interactive
		--encoding ENC

		례

		커멘드 라인으로 지정한 커밋 메세지와 커런트 디렉토리 (". ")(을)를 암묵의 타겟으로서 단순한 변경을 커밋합니다:

		$ svn commit -m "added howto section. "
		Sending        a
		Transmitting file data .
		Committed revision 3.

		파일foo.c (커멘드 라인으로 명시적으로 지정)의 변경점을, 파일msg의 내용을 커밋 메세지와 해 커밋:

		$ svn commit -F msg foo.c
		Sending        foo.c
		Transmitting file data .
		Committed revision 5.

		커밋 메세지로서--file로 지정한 파일이 버전 관리하에 있는 경우, --force-log 스윗치를 사용할 필요가 있다:

		$ svn commit --file file_under_vc.txt foo.c
		svn: The log message file is under version control
		svn: Log message file is a versioned file; use `--force-log' to override.

		$ svn commit --force --file-log file_under_vc.txt foo.c
		Sending        foo.c
		Transmitting file data .
		Committed revision 6.

		삭제 예고 파일을 커밋:

		svn commit -m "removed file 'c'. "
		Deleting       c

		Committed revision 7.

		svn copy

		Name

		svn copy  -- 작업 카피나 저장소(repository)중의, 파일이나 디렉토리를 카피.
		용법

		svn copy SRC DST
		설명

		작업 카피 또는 저장소(repository)중의 파일을 카피합니다. SRC 와 DST 는, 작업 카피(WC) 상의 패스로도, URL에서도 괜찮습니다:

		WC - WC
		추가용으로 파일을 카피해, 추가 예고합니다. (with history).

		WC - URL
		WC의 카피를 직접 URL에 커밋.

		URL - WC
		URL를 WC에 체크아웃 해, 추가 예고한다.

		URL - URL
		완전한 서버상만에서의 카피. 이것은 보통 브랜치(branch)나 태그에 이용됩니다.

		Warning
		파일은 하나의 저장소(repository)의 내부에서만 카피 가능합니다. Subversion은 저장소(repository)간 카피를 서포트하고 있지 않습니다.

		별명

		cp

		변경 대상

		카피처가 URL 인 경우는 저장소(repository).

		카피처가 작업 카피의 패스인 경우는 작업 카피.

		저장소(repository)에의 액세스

		카피원 또는 카피처가 저장소(repository)인지, 소스 리비전 번호를 참조할 필요가 있는 경우에는 발생.

		스윗치

		--message (-m) TEXT
		--file (-F) FILE
		--revision (-r) REV
		--quiet (-q)
		--username USER
		--password PASS
		--no-auth-cache
		--non-interactive
		--encoding ENC

		례

		작업 카피중의 파일 또는 디렉토리를 카피( 카피 예고만다음의 커밋까지 저장소(repository)에는 아무것도 일어나지 않는다):

		$ svn copy foo.txt bar.txt
		A         bar.txt
		$ svn status
		A  +   bar.txt

		저장소(repository)중의 URL 에 작업 카피중의 파일 또는 디렉토리 (을)를 카피(동시에 커밋되므로, 커밋 메세지를 지정할 필요 있어):

		$ svn copy near.txt file:///tmp/repos/test/far-away.txt -m "Remote copy. "

		Committed revision 8.

		저장소(repository)의 파일 또는 디렉토리를 작업 카피에 카피(카피의 예고만다음의 커밋까지 저장소(repository)에는 아무것도 일어나지 않는다):

		Tip: 이것은 저장소(repository)중이 죽은 파일을 restore시키는 추천하는 방법입니다

		$ svn copy file:///tmp/repos/test/far-away near-here
		A         near-here

		그리고 마지막에 두 개의 URL의 사이에 카피하는 방법:

		$ svn copy file:///tmp/repos/test/far-away file:///tmp/repos/test/over-there -m "remote copy. "

		Committed revision 9.

		Tip: 저장소(repository)중의 리비전에 태그 짓고 하는 제일 간단한 방법 그 리비전(보통은 HEAD)을 태그 짓고 되었다 디렉토리에, 단지 svn copy 한다.

		$ svn copy file:///tmp/repos/test/trunk file:///tmp/repos/test/tags/0. 6.32-prerelease -m "tag tree"

		Committed revision 12.

		그 태그를 잊는 것을 신파일 할 필요는 없습니다 언제라도 낡은 리비전을 지정해 태그 붙이고 하는 것이 할 수 있습니다:

		$ svn copy -r 11 file:///tmp/repos/test/trunk file:///tmp/repos/test/tags/0. 6.32-prerelease -m "Forgot to tag at rev 11"

		Committed revision 13.

		svn delete

		Name

		svn delete  -- 작업 카피나 저장소(repository)로부터 파일 또는 디렉토리를 삭제합니다.
		용법

		svn delete PATH...
		svn delete URL...
		설명

		PATH로 지정된 파일 또는 디렉토리는 다음의 커밋 그리고 삭제하는 것을 예고합니다. 파일(와 아직 커밋하고 있지 않다 디렉토리)는 즉시 작업 카피로부터 삭제됩니다. 이 커멘드는 버전화되어 있지 않은가 수정되어 있지 않은 것에 대해서는 동작하지 않습니다. --force스윗치를 사용하면 이 동작을 변경할 수 있습니다.

		URL로 지정된 파일 또는 디렉토리는 직접 커밋을 발행하는 형태로 삭제됩니다. 복수의 URL 는 단일의 트랜잭션(transaction)와 해 불분할에 커밋됩니다.

		별명

		del, remove, rm

		변경 대상

		파일에 대해서 실행했을 경우는 작업 카피. URL에 대해서 실행했을 경우는 저장소(repository)

		저장소(repository)에의 액세스

		URL에 대해서 조작했을 경우만 발생

		스윗치

		--force
		--force-log
		--message (-m) TEXT
		--file (-F) FILE
		--quiet (-q)
		--targets FILENAME
		--username USER
		--password PASS
		--no-auth-cache
		--non-interactive
		--encoding ENC

		례

		svn 를 사용해 작업 카피로부터 파일을 삭제하면(자), 단지 삭제가 예고될 뿐입니다. 파일은 다음의 커밋 그리고 저장소(repository)로부터 삭제됩니다.

		$ svn delete myfile
		D         myfile

		$ svn commit -m "Deleted file 'myfile'. "
		Deleting       myfile
		Transmitting file data .
		Committed revision 14.

		URL를 삭제합니다만, 그것은 즉시 일어나므로 로그 메세지를 지정할 필요가 있습니다:

		$ svn delete -m "Deleting file 'yourfile'" file:///tmp/repos/test/yourfile

		Committed revision 15.

		이 예는 작업 카피에 수정이 있는 파일을 강제 삭제하는 방법입니다:

		$ svn delete over-there
		svn: Attempting restricted operation for modified resource
		svn: Use --force to override this restriction
		svn: 'over-there' has local modifications

		$ svn delete --force over-there
		D         over-there

		svn diff

		Name

		svn diff  -- 두 개의 패스동안의 차이점을 표시합니다.
		용법

		svn diff [-r N[:M]] [TARGET...]
		svn diff URL1[@N] URL2[@M]
		설명

		두 개의 패스동안의 차이점을 표시합니다. 각각의 TARGET 는 작업 카피 패스나 URL입니다. 만약 TARGET를 지정하지 않으면 '. '가 사용됩니다.

		TARGET 가 URL라면 리비전 N와 M는--revision를 사용해 지정됩니다.

		TARGET가 작업 카피 패스라면,--revision 스윗치의 의미는 이하와 같이 됩니다:

		--revision N:M
		서버는 TARGET@N 와 TARGET@M 를 비교합니다.

		--revision N
		클라이언트는 TARGET@N와 작업 카피를 비교합니다.

		(no --revision)
		클라이언트는 TARGET의 베이스 리비전과 작업 카피를 비교합니다.

		다른 구문을 사용하면(자) 서버는 각각 리비전 N와 M에 있는 URL1와 URL2 (을)를 비교합니다. 만약 N나 M가 생략 되면 HEAD의 값이 사용됩니다.

		별명

		di

		변경 대상

		없음

		저장소(repository)에의 액세스

		차이점을 아는데 필요한 경우는 발생합니다. 다만 작업 카피의 BASE 리비전을 취득하는 경우는 제외합니다.

		스윗치

		--revision (-r) REV
		--extensions (-x) "ARGS"
		--non-recursive (-N)
		--diff-cmd CMD
		--username USER
		--password PASS
		--no-auth-cache
		--non-interactive
		--no-diff-deleted

		례

		BASE 리비전과 작업 카피를 비교합니다. (svn diff 의 제일 자주 있는 사용법):

		$ svn diff COMMITTERS
		Index: COMMITTERS
		===================================================================
		--- COMMITTERS  (revision 4404)
		+++ COMMITTERS  (working copy)

		작업 카피의 변경을 이전의 리비전과 비교하는 방법:

		$ svn diff -r 3900 COMMITTERS
		Index: COMMITTERS
		===================================================================
		--- COMMITTERS  (revision 3900)
		+++ COMMITTERS  (working copy)

		리비전 3000으로 리비전 3500을'@'구문을 사용해 비교:

		$ svn diff http://svn.collab.net/repos/svn/trunk/COMMITTERS@3000 http://svn.collab.net/repos/svn/trunk/COMMITTERS@3500
		Index: COMMITTERS
		===================================================================
		--- COMMITTERS  (revision 3000)
		+++ COMMITTERS  (revision 3500)


		리비전 3000으로 리비전 3500을 범위 지정으로 비교( 이 경우는 하나의 URL만을 건네주면 된다):

		$ svn diff -r 3000:3500 http://svn.collab.net/repos/svn/trunk/COMMITTERS
		Index: COMMITTERS
		===================================================================
		--- COMMITTERS  (revision 3000)
		+++ COMMITTERS  (revision 3500)

		작업 카피가 있는 경우, 긴 URL 지정하는 것 없이 차이점을 취득할 수가 있습니다:

		$ svn diff -r 3000:3500 COMMITTERS
		Index: COMMITTERS
		===================================================================
		--- COMMITTERS  (revision 3000)
		+++ COMMITTERS  (revision 3500)

		--diff-cmd CMD -x 를 사용해 외부 diff 프로그램에 직접 인수를 건네줍니다

		svn diff --diff-cmd /usr/bin/diff -x "-i -b" COMMITTERS
		Index: COMMITTERS
		===================================================================
		0a1, 2
		 This is a test


		svn export

		Name

		svn export  -- 디렉토리 트리의 export
		용법

		svn export [-r REV] URL [PATH]
		svn export PATH1 PATH2
		설명

		최초의 구문에서는 지정된 URL의 저장소(repository)로부터 디렉토리 트리를 export 합니다. 이 차이, REV 가 지정되면 리비전 REV 로부터, 그렇지 않으면 HEAD의 리비전이 이용되어 결과는 PATH에 출력됩니다. PATH가 생략 되면 URL의 마지막 부분이 로컬 디렉토리 명칭으로서 이용됩니다.

		두번째의 구문에서는 PATH1로 지정된 로컬 작업 카피를 PATH2에 출력 합니다. 모든 작업 카피에의 변경은 보존됩니다만, 버전 관리하 에 없는 파일은 카피되지 않습니다.

		별명

		없음

		변경 대상

		로컬 디스크

		저장소(repository)에의 액세스

		URL로부터의 export의 경우만 발생

		스윗치

		--revision (-r) REV
		--quiet (-q)
		--username USER
		--password PASS
		--no-auth-cache
		--non-interactive

		례

		작업 카피로부터의 export( 모든 파일과 디렉토리를 하나 하나 표시하지 않는다):

		$ svn export a-wc my-export
		pantheon: /tmp

		저장소(repository)로부터 직접 export( 모든 파일과 디렉토리를 표시):

		$ svn export file:///tmp/repos my-export
		A  my-export/test
		A  my-export/quiz

		Exported revision 15.

		svn help

		Name

		svn help  -- 헬프
		용법

		svn help [SUBCOMMAND...]
		설명

		Subversion을 사용하는 경우의 최선의 가이드로, 거기에 비교하면(자) 이 책 등은 미치지 않습니다!

		별명

		?, h

		변경 대상

		없음

		저장소(repository)에의 액세스

		발생하지 않는다

		스윗치

		--version
		--quiet (-q)

		svn import

		Name

		svn import  -- PATH를 URL에 대해서 재귀적으로 커밋합니다.
		용법

		svn import [PATH] URL
		설명

		PATH의 카피를 재귀적으로URL 에 커밋합니다. PATH 가 없으면 '. '가 가정됩니다. 필요에 따라서 친디렉토리가 저장소(repository)에 만들어집니다.

		별명

		없음

		변경 대상

		저장소(repository)

		저장소(repository)에의 액세스

		발생한다

		스윗치

		--message (-m) TEXT
		--file (-F) FILE
		--quiet (-q)
		--non-recursive (-N)
		--username USER
		--password PASS
		--no-auth-cache
		--non-interactive
		--force-log
		--encoding ENC

		례

		이것은, 로컬 디렉토리'myproj'를 저장소(repository)의 근원에 임포트 합니다:

		$ svn import -m "New import" myproj http://svn.red-bean.com/repos/test
		Adding         myproj/sample.txt

		Transmitting file data .........
		Committed revision 16.

		이것은 로컬 디렉토리'myproj'를 저장소(repository)의'trunk/vendors' 에 임포트 합니다. 디렉토리'trunk/vendor'는 임포트 하기 전에 존재하고 있지 않아도 괜찮습니다 svn import (은)는 재귀적으로 디렉토리를 만듭니다:

		$ svn import -m "New import" myproj \
		    http://svn.red-bean.com/repos/test/trunk/vendors/myproj
		Adding         myproj/sample.txt

		Transmitting file data .........
		Committed revision 19.

		svn info

		Name

		svn info  -- PATH에 대한 정보를 표시합니다.
		용법

		svn info [PATH...]
		설명

		작업 카피의 패스에 대한 정보를 표시합니다. 이것에는:

		패스

		이름

		URL

		리비전

		노드의 종류

		마지막에 수정한 사람

		마지막에 수정한 리비전

		마지막에 수정한 일시

		마지막에 갱신한 텍스트

		마지막에 갱신한 속성

		체크 섬

		별명

		없음

		변경 대상

		없음

		저장소(repository)에의 액세스

		발생하지 않는다

		스윗치

		--targets FILENAME
		--recursive (-R)

		례

		svn info 는 작업 카피중의 파일 또는 디렉토리에 관한 유용한 정보를 표시합니다. 다음은 파일에 관한 정보를 표시합니다:

		$ svn info foo.c
		Path: foo.c
		Name: foo.c
		URL: http://svn.red-bean.com/repos/test/foo.c
		Revision: 4417
		Node Kind: file
		Schedule: normal
		Last Changed Author: sally
		Last Changed Rev: 20
		Last Changed Date: 2003-01-13 16:43:13 -0600 (Mon, 13 Jan 2003)
		Text Last Updated: 2003-01-16 21:18:16 -0600 (Thu, 16 Jan 2003)
		Properties Last Updated: 2003-01-13 21:50:19 -0600 (Mon, 13 Jan 2003)
		Checksum: /3L38YwzhT93BWvgpdF6Zw==

		디렉토리에 대한 정보를 표시할 수도 있습니다:

		$ svn info vendors
		Path: trunk
		URL: http://svn.red-bean.com/repos/test/vendors
		Revision: 19
		Node Kind: directory
		Schedule: normal
		Last Changed Author: harry
		Last Changed Rev: 19
		Last Changed Date: 2003-01-16 23:21:19 -0600 (Thu, 16 Jan 2003)

		svn list

		Name

		svn list  -- 저장소(repository)중의 디렉토리 엔트리를 일람표 가리킵니다.
		용법

		svn list [TARGET...]
		설명

		각각의 TARGET 파일과 TARGET 디＋쿠트리의 저장소(repository) 안의 내용을 일람표 가리킵니다. TARGET 가 작업 카피의 패스인 경우, 대응하는 저장소(repository) URL 가 이용됩니다.

		디폴트의 TARGET 치는 '. '로, 현재의 작업 카피 디렉토리 의 저장소(repository) URL를 의미합니다.

		--verbose를 사용하면(자) 이하의 필드가 아이템마다의 상태를 나타냅니다:

		마지막 커밋의 리비전 번호

		마지막 커밋을 한 사람

		데이터 사이즈 (아르바이트 단위의)

		마지막 커밋의 일시

		별명

		ls

		변경 대상

		없음

		저장소(repository)에의 액세스

		발생한다

		스윗치

		--revision (-r) REV
		--verbose (-v)
		--recursive (-R)
		--username USER
		--password PASS
		--no-auth-cache
		--non-interactive

		례

		svn list 는, 작업 카피를 다운로드하는 것 없이 어떤 파일이 저장소(repository)에 있을까를 안다 때에 도움이 됩니다:

		$ svn list http://svn.red-bean.com/repos/test/support
		README.txt
		INSTALL
		례/


		UNIX 의 ls와 같이 추가 정보를 얻기 위해서(때문에) --verbose 스윗치를 붙일 수도 있습니다:

		svn list --verbose file:///tmp/repos
		     16 sally         28361 Jan 16 23:18 README.txt
		     27 sally             0 Jan 18 15:27 INSTALL
		     24 harry               Jan 18 11:27 예/

		자세하게는>(을)를 봐 주세요.

		svn log

		Name

		svn log  -- 커밋 로그 메세지의 표시.
		용법

		svn log [PATH]
		svn log URL [PATH...]
		설명

		디폴트의 타겟은 현재의 작업 디렉토리의 패스가 됩니다. 인수를 지정하지 않으면 svn log 는 자신의 작업 카피의 현재의 작업 디렉토리 자신과 그 내부의 모든 파일과 디렉토리에 관한 로그 메세지를 표시합니다. 하나의 패스, 하나 이상의 리비전, 혹은 그러한 편성을 지정하는 것으로 결과 내용을 지정을 할 수 있습니다. 로컬 패스의 디폴트 리비전 범위는, BASE:1 입니다.

		URL만을 지정하면, 그 URL 에 포함되는 모든 로그 메세지가 표시됩니다. URL의 뒤에 패스를 붙이면 URL중의 그러한 패스에 포함된다 메세지만이 표시됩니다. URL 의 디폴트 리비전 범위는 HEAD:1 입니다.

		--verbose 를 지정하면(자)svn log (은)는 각각의 로그 메세지와 함께 관련한 모든 패스를 표시합니다. --quiet 를 지정하면(자) svn log (은)는 로그 메세지의 본체 부분을 표시하지 않게 됩니다(이것은 --verbose 스윗치와 양립합니다).

		각각의 로그 메세지는, 그 리비전에 영향이 있는 패스가 두 번 이상 요구되어도, 한 번만 표시됩니다. 디폴트에서는 Logs cross copy history; --strict 로 이 동작을 무효로 할 수 있습니다.

		별명

		없음

		변경 대상

		없음

		저장소(repository)에의 액세스

		발생한다

		스윗치

		--revision (-r) REV
		--quiet (-q)
		--verbose (-v)
		--targets FILENAME
		--username USER
		--password PASS
		--no-auth-cache
		--non-interactive
		--strict
		--incremental
		--xml

		례

		최상정도로 svn log 를 실행하는 것에 의해 작업 카피중의 변경된 모든 패스의 로그 메세지를 볼 수가 있습니다:

		$ svn log
		------------------------------------------------------------------------
		r20 | harry | 2003-01-17 22:56:19 -0600 (Fri, 17 Jan 2003) | 1 line

		Tweak.
		------------------------------------------------------------------------
		r17 | sally | 2003-01-16 23:21:19 -0600 (Thu, 16 Jan 2003) | 2 lines


		작업 카피중의 특정의 파일에 관한 모든 로그 메세지를 조사합니다:

		$ svn log foo.c
		------------------------------------------------------------------------
		r32 | sally | 2003-01-13 16:43:13 -0600 (Mon, 13 Jan 2003) | 1 line

		Added defines.
		------------------------------------------------------------------------
		r28 | sally | 2003-01-07 21:48:33 -0600 (Tue, 07 Jan 2003) | 3 lines


		작업 카피가 수중에 없는 경우, URL를 log 할 수가 있습니다:

		$ svn log http://svn.red-bean.com/repos/test/foo.c
		------------------------------------------------------------------------
		r32 | sally | 2003-01-13 16:43:13 -0600 (Mon, 13 Jan 2003) | 1 line

		Added defines.
		------------------------------------------------------------------------
		r28 | sally | 2003-01-07 21:48:33 -0600 (Tue, 07 Jan 2003) | 3 lines


		같은 URL아래의 몇개의 다른 패스를 갖고 싶은 경우URL [PATH...] 구문을 사용할 수가 있습니다.

		$ svn log http://svn.red-bean.com/repos/test/ foo.c bar.c
		------------------------------------------------------------------------
		r32 | sally | 2003-01-13 16:43:13 -0600 (Mon, 13 Jan 2003) | 1 line

		Added defines.
		------------------------------------------------------------------------
		r31 | harry | 2003-01-10 12:25:08 -0600 (Fri, 10 Jan 2003) | 1 line

		Added new file bar.c
		------------------------------------------------------------------------
		r28 | sally | 2003-01-07 21:48:33 -0600 (Tue, 07 Jan 2003) | 3 lines


		그것은 커멘드 라인상에서 양쪽 모두의 URL를 명시적으로 두는 것과 같은 것이 됩니다:

		$ svn log http://svn.red-bean.com/repos/test/foo.c \
		          http://svn.red-bean.com/repos/test/bar.c


		복수의 log 커멘드의 결과를 연결하고 싶은 경우,--incremental 스윗치를 사용할 수가 있습니다. svn log는 보통 메세지의 최초로 데쉬의 행을 표시 해, 각각의 계속하는 로그 메세지를 표시해, 마지막 로그 메세지가 거기에 계속됩니다. 만약 svn log 를 두 개의 리비전 범위에서 실행했을 경우, 다음과 같은 출력 (이)가 됩니다:

		$ svn log -r 14:15
		------------------------------------------------------------------------
		r14 | ...

		------------------------------------------------------------------------
		r15 | ...

		------------------------------------------------------------------------

		그러나, 두 차례로 되지 않은 로그 메세지를 파일에 출력하고 싶은 경우, 무엇인가 다음과 같은 기분이 들겠지요:

		$ svn log -r 14 > mylog
		$ svn log -r 19 >> mylog
		$ svn log -r 27 >> mylog
		$ cat mylog
		------------------------------------------------------------------------
		r14 | ...

		------------------------------------------------------------------------
		------------------------------------------------------------------------
		r19 | ...

		------------------------------------------------------------------------
		------------------------------------------------------------------------
		r27 | ...

		------------------------------------------------------------------------

		incremental 스윗치를 사용하면, 출력중의 중복 한 데쉬행 의 표시를 피할 수가 있습니다:

		$ svn log --incremental -r 14 > mylog
		$ svn log --incremental -r 19 >> mylog
		$ svn log --incremental -r 27 >> mylog
		$ cat mylog
		------------------------------------------------------------------------
		r14 | ...

		------------------------------------------------------------------------
		r19 | ...

		------------------------------------------------------------------------
		r27 | ...

		--incremental 스윗치는, --xml 스윗치를 사용했을 때 것과 같은 출력 제어를 합니다.

		Tip: 만약 svn log 를 특정의 패스상의 특정의 리비전 지정으로 실행하면(자) 아무것도 출력되지 않을 것입니다

		$ svn log -r 20 http://svn.red-bean.com/untouched.txt
		------------------------------------------------------------------------

		그것은 패스는 리비전에 따라서는 수정되지 않았던 것을 의미 하고 있습니다. 저장소(repository)의 최상정도로 log 하는지, 그 리비전으로 수정한 파일을 알고 있다면, 명시적으로 그것을 지정하는 것이 할 수 있습니다:

		$ svn log -r 20 touched.txt
		------------------------------------------------------------------------
		r20 | sally | 2003-01-17 22:56:19 -0600 (Fri, 17 Jan 2003) | 1 line

		Made a change.
		------------------------------------------------------------------------

		svn merge

		Name

		svn merge  -- 두 소스의 차이를 작업 카피 패스에 반영합니다.
		용법

		svn merge sourceURL1[@N] sourceURL2[@M] [WCPATH]
		svn merge -r N:M SOURCE [PATH]
		설명

		최초의 형식에서는 소스가 되는 URL는 리비전 N 와 M 로 지정되어 그 둘이 비교됩니다. 리비전이 생략 되면 HEAD 를 지정된 것과 간주합니다.

		두번째의 형식에서는 SOURCE 는 URL 인가, 작업 카피 아이템이며, 그 경우, 대응한 URL가 이용됩니다. 이, 리비전 N 와 M 의 URL가, 비교 대상과 됩니다.

		WCPATH 가 변경을 받아들이는 작업 카피 패스입니다. 만약 WCPATH가 생략 되면(자), 디폴트로서'. '가 이용됩니다. 다만, 양쪽 모두의 소스의 베이스명이 같아, 게다가 그 이름의 파일이'. '에 있는 경우는 별개로, 이 경우는, 차분은 그 파일에 적용됩니다.

		별명

		없음

		변경 대상

		작업 카피

		저장소(repository)에의 액세스

		URL에 대해서 동작할 때 마셔 발생한다

		스윗치

		--revision (-r) REV
		--non-recursive (-N)
		--quiet (-q)
		--force
		--dry-run
		--username USER
		--password PASS
		--no-auth-cache
		--non-interactive

		례

		브랜치(branch)를 주계에 merge 합니다 (주계의 작업 카피가 있는 것이 전제가 됩니다):

		$ svn merge http://svn.red-bean.com/repos/trunk/vendors \
		            http://svn.red-bean.com/repos/branches/vendors-with-fix
		U  myproj/tiny.txt
		U  myproj/thhgttg.txt
		U  myproj/win.txt
		U  myproj/flo.txt

		리비전 23으로 분기(브랜치(branch)화) 해, 그 브랜치(branch)안의 주계로 변경을 merge 하고 싶다고 합니다. 이것에는 브랜치(branch)의 작업 카피 중(안)에서 이하와 같은 조작을 합니다:

		$ svn merge -r 23:30 file:///tmp/repos/trunk/vendors
		U  myproj/thhgttg.txt


		변경을 하나의 파일에 merge 하려면:

		$ cd myproj
		$ svn merge -r 30:31 thhgttg.txt
		U  thhgttg.txt

		svn mkdir

		Name

		svn mkdir  -- 버전 관리하에 있는 새로운 디렉토리를 만듭니다.
		용법

		svn mkdir PATH...
		svn mkdir URL...
		설명

		PATH 또는 URL를 마지막 부분으로 할 것 같은 디렉토리를 만듭니다. 작업 카피 PATH 로 지정된 디렉토리는 작업 카피에의 추가로서 예고됩니다. URL 에 의해 지정된 디렉토리는 작성과 동시에 커밋됩니다. 복수의 디렉토리 URL 는 불분할에 커밋됩니다. 어느 쪽의 경우에서도 도중의 디렉토리는 모두 존재하고 있지 않으면 안됩니다.

		별명

		없음

		변경 대상

		작업 카피. URL를 지정했을 경우는 저장소(repository)

		저장소(repository)에의 액세스

		URL를 지정했을 경우는 발생한다

		스윗치

		--message (-m) TEXT
		--file (-F) FILE
		--quiet (-q)
		--username USER
		--password PASS
		--no-auth-cache
		--non-interactive
		--encoding ENC
		--force-log

		례

		작업 카피중에 디렉토리를 만든다:

		$ svn mkdir newdir
		A         newdir

		저장소(repository)에 만든다(커밋이 발생하므로 로그 메세지를 지정할 필요가 있다) :

		$ svn mkdir -m "Making a new dir. " http://svn.red-bean.com/repos/newdir

		Committed revision 26.

		svn move

		Name

		svn move  -- 파일이나 디렉토리를 이동한다.
		용법

		svn move SRC DST
		설명

		이 커멘드는 작업 카피 또는 저장소(repository)에 있다 파일이나 디렉토리를 이동합니다.

		Tip: 이 커멘드는,svn copy 의 뒤에 svn delete를 실행하는 것과 같은 것입니다.

		Warning
		Subversion에서는 작업 카피와 URL의 사이의 이동은 서포트하고 있지 않습니다. 게다가 파일의 이동은 하나의 저장소(repository)의 내부에서만 가능합니다 Subversion은 저장소(repository)간의 이동을 서포트하고 있지 않습니다.

		WC - WC
		이동하고 나서, 파일이나 디렉토리를 추가 예고합니다.

		URL - URL
		서버상에서의 명칭 변경

		별명

		mv, rename, ren

		변경 대상

		작업 카피. URL를 지정했을 경우는 저장소(repository)

		저장소(repository)에의 액세스

		URL를 지정했을 경우는 발생한다

		스윗치

		--message (-m) TEXT
		--file (-F) FILE
		--revision (-r) REV
		--quiet (-q)
		--force
		--username USER
		--password PASS
		--no-auth-cache
		--non-interactive
		--encoding ENC
		--force-log

		례

		작업 카피의 파일을 이동:

		$ svn move foo.c bar.c
		A         bar.c
		D         foo.c

		저장소(repository)의 파일을 이동(커밋이 발생하므로 커밋 메세지를 지정할 필요가 있다):

		$ svn move -m "Move a file" http://svn.red-bean.com/repos/foo.c \
		                            http://svn.red-bean.com/repos/bar.c

		Committed revision 27.

		svn propdel

		Name

		svn propdel  -- 아이템으로부터 속성을 삭제합니다.
		용법

		svn propdel PROPNAME [PATH...]
		svn propdel PROPNAME --revprop -r REV [URL]
		설명

		이것은 파일, 디렉토리, 리비전으로부터 속성을 삭제합니다. 최초의 형식은 작업 카피의 버전 관리된 속성을 삭제해, 두번째의 형식에서는 저장소(repository) 리비전상의 버전 관리되어 있지 않은 속성을 삭제합니다.

		별명

		pdel, pd

		변경 대상

		작업 카피. URL를 지정했을 경우는 저장소(repository)

		저장소(repository)에의 액세스

		URL를 지정했을 경우만 발생한다

		스윗치

		--quiet (-q)
		--recursive (-R)
		--revision (-r) REV
		--revprop

		례

		작업 카피의 파일로부터 속성을 삭제한다

		$ svn propdel svn:mime-type  some-script
		property `svn:mime-type' deleted from 'some-script'.

		리비전 속성을 삭제한다:

		$ svn propdel --revprop -r 26 release-date
		property `release-date' deleted from repository revision '26'

		svn propedit

		Name

		svn propedit  -- 버전 관리되고 있는 하나 이상의 아이템의 속성을 편집한다.
		용법

		svn propedit PROPNAME PATH...
		svn propedit PROPNAME --revprop -r REV [URL]
		설명

		하나 이상의 속성을 좋아하는 에디터로 수정합니다. 최초의 형식은 작업 카피중의 버전 관리된 속성을 편집합니다. 두번째의 형식에서는 저장소(repository) 리비전상의 버전 관리되어 있지 않다 속성을 편집합니다.

		별명

		pedit, pe

		변경 대상

		작업 카피. URL를 지정했을 경우는 저장소(repository)

		저장소(repository)에의 액세스

		URL를 지정했을 경우만 발생한다

		스윗치

		--revision (-r) REV
		--revprop
		--encoding ENC

		례

		svn propedit 는, 복수의 값을 가진다 속성을 간단하게 변경할 수가 있습니다:

		$ svn propedit svn:keywords  foo.c
		    svn will launch your favorite editor here, with a buffer open
		    containing the current contents of the svn:keywords property.   You
		    can add multiple values to a property easily here by entering one
		    value per line.
		Set new value for property `svn:keywords' on `foo.c'

		svn propget

		Name

		svn propget  -- 속성의 값을 표시합니다.
		용법

		svn propget PROPNAME [PATH...]
		svn propget PROPNAME --revprop -r REV [URL]
		설명

		파일, 디렉토리, 리비전의 속성치를 표시합니다. 최초의 형식은 작업 카피에 있는 하나 이상의 아이템의 버전 관리된 속성을 표시합니다. 두번째의 형식인 저장소(repository) 리비전의 버전 관리하고 있지 않는 속성을 표시합니다. 속성에 대한 자세한 것은 > (을)를 봐 주세요.

		별명

		pget, pg

		변경 대상

		작업 카피. URL를 지정했을 경우는 저장소(repository)

		저장소(repository)에의 액세스

		URL를 지정했을 때 마셔 발생한다

		스윗치

		--recursive (-R)
		--revision (-r) REV
		--revprop

		례

		작업 카피중의 아이템의 속성을 조사한다:

		$ svn propget svn:keywords foo.c
		Author
		Date
		Rev

		리비전 속성에 대해서도 같이:

		$ svn propget svn:log --revprop -r 20
		Began journal.

		svn proplist

		Name

		svn proplist  -- 모든 속성을 일람표 가리킵니다.
		용법

		svn proplist [PATH...]
		svn proplist --revprop -r REV [URL]
		설명

		파일, 디렉토리, 리비전의 모든 속성을 일람표 가리킵니다. 최초의 형식에서는 작업 카피중의 버전 관리된 속성을 표시합니다만, 두번째의 형식인 저장소(repository) 리비전의 속성을 표시합니다.

		별명

		plist, pl

		변경 대상

		작업 카피. URL가 지정되어 있는 경우는 저장소(repository)

		저장소(repository)에의 액세스

		URL를 지정했을 경우만 발생한다

		스윗치

		--verbose (-v)
		--recursive (-R)
		--revision (-r) REV
		--revprop

		례

		작업 카피의 아이템의 속성의 일람을 보고 싶은 경우는 proplist 커멘드를 사용할 수가 있습니다:

		$ svn proplist foo.c
		Properties on 'foo.c':
		  svn:mime-type
		  svn:keywords
		  owner

		그러나--verbose 플래그를 붙이면(자), 각각의 속성의 값도 함께 표시할 수가 있으므로 매우 편리합니다:

		$ svn proplist --verbose foo.c
		Properties on 'foo.c':
		  svn:mime-type : text/plain
		  svn:keywords : Author Date Rev
		  owner : sally

		svn propset

		Name

		svn propset  -- 파일, 디렉토리, 리비전의 PROPNAME 의 값 (을)를 PROPVAL로 설정한다.
		용법

		svn propset PROPNAME [PROPVAL | -F VALFILE] PATH [PATH [PATH ... ]]
		svn propset PROPNAME --revprop -r REV [PROPVAL | -F VALFILE] [URL]
		설명

		파일, 디렉토리, 리비전의 PROPNAME의 값을 PROPVAL로 설정합니다. 최초의 예는 버전 관리된 작업 카피중의 속성치의 변경으로, 두번째는 버전 관리되어 있지 않은 저장소(repository)상의 리비전 속성치의 작성입니다.

		Tip: Subversion은, 동작에 영향을 주는 많은"특별한"속성 (을)를 갖고 있습니다. 자세하게는 >(을)를 봐 주세요.

		별명

		pset, ps

		변경 대상

		작업 카피. URL를 지정했을 경우만 저장소(repository)

		저장소(repository)에의 액세스

		URL를 지정했을 경우만 발생한다

		스윗치

		--file (-F) FILE
		--quiet (-q)
		--revision (-r) REV
		--targets FILENAME
		--recursive (-R)
		--revprop
		--encoding ENC

		례

		파일의 MIME 타입을 설정한다:

		$ svn propset svn:mime-type image/jpeg foo.jpg
		property `svn:mime-type' set on 'foo.jpg'

		UNIX 상에서, 어느 파일에 실행 속성을 붙이고 싶을 때에는:

		$ svn propset svn:executable ON somescript
		property `svn:executable' set on 'somescript'

		아마, 공동 작업자의 편의를 생각하면(자), 어느 속성을 설정 하려면 내부적인 폴리시가 없으면 안됩니다:

		$ svn propset owner sally foo.c
		property `owner' set on 'foo.c'

		특정의 리비전의 로그 메세지를 틀려 버려, 그것을 변경하고 싶을 때, --revprop 를 사용해, svn:log 에 새로운 메세지를 설정합니다:

		$ svn propset --revprop -r 25 svn:log "Journaled about trip to New York. "
		property `svn:log' set on repository revision '25'

		혹은, 작업 카피를 가지고 있지 않은 경우에서도, URL를 설정하는 것이 할 수 있습니다.

		$ svn propset --revprop -r 26 svn:log "Document nap. " http://svn.red-bean.com/repos
		property `svn:log' set on repository revision '25'

		마지막으로, 속성치를 파일을 입력으로서 설정할 수도 있습니다. 이 방법으로, 속성치에 바이너리치를 설정하는 것 조차 할 수 있습니다:

		$ svn propset owner-pic -F sally.jpg moo.c
		property `owner-pic' set on 'moo.c'

		Warning
		디폴트에서는 Subversion 저장소(repository)중의 리비전 속성은 변경 할 수 없습니다. 저장소(repository) 관리자는'pre-revprop-change'라고 한다 이름의 훅을 만드는 것으로 명시적으로 리비전 프롭퍼티의 수정을 유효하게 하지 않으면 안됩니다. 푹스 클립트에 대해 자세하게는 > (을)를 봐 주세요.

		svn resolved

		Name

		svn resolved  -- 작업 카피의 파일 또는 디렉토리의 "충돌" 상태를 잡기 들여다 봅니다.
		용법

		svn resolved PATH...
		설명

		작업 카피의 파일 또는 디렉토리의 "충돌" 상태를 잡기 들여다 봅니다. 이 커멘드는 충돌 마커를 의미적으로 해소하는 것이 아니라, 단지 충돌에 관계한 중간 파일을 삭제해, PATH로 한번 더 커밋한다 뿐입니다. 즉 Subversion에 그 충돌은 벌써"해소되었다"라고 전합니다. 충돌의 해소에 대한 자세한 것은 > (을)를 봐 주세요.

		별명

		없음

		변경 대상

		작업 카피

		저장소(repository)에의 액세스

		No

		스윗치

		--targets FILENAME
		--recursive (-R)
		--quiet (-q)

		례

		갱신 조작중에 충돌이 있었을 경우, 작업 카피는 세 개의 새로운 파일을 만듭니다:

		$ svn update
		C  foo.c
		Updated to revision 31.
		$ ls
		foo.c
		foo.c.mine
		foo.c.r30
		foo.c.r31

		충돌을 해소해,foo.c 의 커밋의 준비가 할 수 있던 상태에 있는 경우,svn resolved 는 당신의 작업 카피에, 주의하지 않으면 안 되는 모든 일을 전합니다.

		Warning
		단지 충돌 파일을 삭제하고 나서 커밋할 수도있습니다 하지만 svn resolved 는 작업 카피 관리 area의 기록으로서 충돌 파일을 삭제했다 일도 덧붙이므로, 이 커멘드를 사용하는 것을 추천합니다.

		svn revert

		Name

		svn revert  -- 로컬 파일에의 모든 편집을 취소합니다.
		용법

		svn revert PATH...
		설명

		파일, 디렉토리에 대한 변경을 모두 취소해 충돌 상태를 해소합니다. svn revert 작업 카피의 아이템의 내용 만이 아니고, 속성의 변경도 취소합니다. 한층 더 벌써 한 예고 조작을 취소하는데도 사용할 수 있습니다. (예를 들어, 파일에 대한 추가 또는 삭제의 예고 도"삭제되고".

		별명

		없음

		변경 대상

		작업 카피

		저장소(repository)에의 액세스

		없음

		스윗치

		--targets FILENAME
		--recursive (-R)
		--quiet (-q)

		례

		파일에 대한 변경의 취소:

		$ svn revert foo.c
		Reverted foo.c

		디렉토리 전체를 취소하고 싶은 경우는, --recursive 플래그를 사용합니다:

		$ svn revert --recursive .
		Reverted newdir/afile
		Reverted foo.c
		Reverted bar.txt

		마지막으로, 어느 예고 조작도 취소할 수가 있습니다:

		$ svn add mistake.txt whoops
		A         mistake.txt
		A         whoops
		A         whoops/oopsie.c

		$ svn revert mistake.txt whoops
		Reverted mistake.txt
		Reverted whoops

		$ svn status
		?       mistake.txt
		?       whoops

		Warning
		svn revert 의 대상을 지정하지 않으면, 그것은 아무것도 하지 않습니다 잘못한 수정의 파기로부터 작업 카피를 지키기 위해서,svn revert 조작은 적어도 하나의 인수를 지정하도록(듯이) 요구합니다.

		svn status

		Name

		svn status  -- 작업 카피에 있는 파일이나 디렉토리 상태를 표시.
		용법

		svn status [PATH...]
		설명

		작업 카피에 있는 파일이나 디렉토리 상태를 표시합니다. 인수가 없는 경우는, 로컬로 수정된 아이템만이 표시됩니다(저장소(repository)에 대하는 액세스는 발생하지 않습니다 --show-updates를 사용하면(자), 작업 리비전과 서버의 최신이 아닌 정보도 추가됩니다. --verbose를 사용하면(자), 모든 아이템에 대한다 완전한 리비전 정보를 표시합니다.

		출력의 최초의 5열의 칼럼은 각각 한 글자폭으로, 작업 카피 아이템 마다 여러가지 정보를 표시합니다.

		최초의 칼럼은, 아이템이 추가, 삭제, 그 이외의 변경, 목 상태인지를 (을)를 나타냅니다.

		' '
		변경은 없습니다.

		'A'
		아이템은 추가 예고되고 있습니다.

		'D'
		아이템은 삭제 예고되고 있습니다.

		'M'
		아이템은 수정되었습니다.

		'C'
		아이템은 저장소(repository)로부터 받은 갱신에 의해 충돌 한 상태에 있습니다.

		'I'
		아이템은 무시되고 있는 속성입니다 (예를 들어, svn:ignore와 같은)

		'? '
		아이템은 버전 관리하에 없습니다.

		'! '
		아이템은 없어졌습니다(이것은 예를 들어, svn를 사용하지 않고 파일을 삭제하거나 이동했을 경우에 일어납니다). 또, 이것은 디렉토리가 불완전한 것을 나타내고 있습니다 (체크아웃이나 갱신이 중단된, 등).

		'~'
		아이템은 디렉토리로서 버전 관리되어 있습니다만, 파일로 옮겨놓을 수 있어 버렸습니다. 혹은 그 역의 상황이 일어났습니다.

		두번째의 칼럼은 파일이나 디렉토리의 속성 상태를 나타냅니다.

		' '
		수정은 없습니다.

		'M'
		이 아이템의 속성은 수정되었습니다.

		'C'
		이 아이템의 속성은 저장소(repository)로부터 받은 속성 갱신에 의해 충돌한 상태에 있습니다.

		3번째의 칼럼은 작업 카피가 락 되고 있는 경우에만 사용됩니다.

		' '
		아이템은 락 되고 있지 않습니다.

		'L'
		아이템은 락 되고 있습니다.

		4번째의 칼럼은 아이템이 추가 예고되고 있는 경우에게만 사용됩니다.

		' '
		커밋 기다리는 예고는 없습니다.

		'+'
		커밋 기다리는 예고가 있습니다.

		다섯번째의 칼럼은 아이템이 부모에 대해서 상대적으로 교체되었다 때에만 사용됩니다. (>를 봐 주세요).

		' '
		아이템은 친디렉토리의 아이입니다.

		'S'
		아이템은 바뀌고 있습니다.

		최신 상태에 관계한 정보가 8번째의 칼럼에 표시됩니다 (--show-updates 스윗치를 건네주었을 경우).

		' '
		작업 카피의 아이템은 최신입니다.

		'*'
		서버에는 아이템의 것 좀 더 새로운 버전이 존재합니다.

		나머지의 필드는 공백에서 단락지어진 가변장입니다. --show-updates 나--verbose (을)를 지정했을 경우는 작업 리비전이 다음의 필드가 됩니다.

		--verbose 스윗치를 지정하면(자) 마지막 커밋 리비전 (와)과 그것을 한 사람이 다음에 표시됩니다.

		작업 카피의 패스는 항상 마지막 필드가 되므로, 공백을 포함하는 것이 할 수 있습니다.

		별명

		stat, st

		변경 대상

		없음

		저장소(repository)에의 액세스

		--show-updates가 지정되었을 경우에 한발생한다

		스윗치

		--show-updates (-u)
		--verbose (-v)
		--non-recursive (-N)
		--quiet (-q)
		--username USER
		--password PASS
		--no-auth-cache
		--non-interactive
		--force-log
		--no-ignore

		례

		작업 카피(?변경점을 조사하기 위한 제일 간단한 방법:

		$ svn status wc
		 M     wc/bar.c
		A  +   wc/qax.c

		작업 카피중, 어느 파일이 최신이 아닌가를 알고 싶은 경우 (은)는--show-updates 스윗치를 지정해 주세요(이것은 작업 카피의 내용을결코변경하지 않습니다). 마지막에 자신의 작업 카피를 갱신하고 나서 저장소(repository)의wc/foo.c (으)로 변경이 있었을 때에는 다음과 같이 됩니다:

		$ svn status --show-updates wc
		 M           965    wc/bar.c
		       *     965    wc/foo.c
		A  +         965    wc/qax.c
		Head revision:   981

		Warning
		--show-updates는, 최신이 아닌 아이템의 이웃에 asterisk를 두는만 입니다(즉,svn update를 실행했다고 하면 저장소(repository)로부터 의 정보로 갱신될 아이템의 전에게만, 이라고 하는 의미입니다). --show-updates 은, 아이템의 저장소(repository) 버전을 반영 한 상태 일람을 표시하는 것은아닙니다.

		마지막으로, status 서브 커멘드로 제일 많은 정보를 얻으려면:

		$ svn status --show-updates --verbose wc
		 M           965       938 sally        wc/bar.c
		       *     965       922 harry        wc/foo.c
		A  +         965       687 harry        wc/qax.c
		             965       687 harry        wc/zig.c
		Head revision:   981

		svn status 의 것 좀 더 많은 예는 >에 있습니다.

		svn switch

		Name

		svn switch  -- 작업 카피를 다른 URL에 갱신합니다.
		용법

		svn switch URL [PATH]
		설명

		이 서브 커멘드는 자신의 작업 카피를 새로운 URL에 갱신해, 복제를 만듭니다. 그렇게 할 필요는 없습니다만, 보통은 그 URL는 바탕으로 되는 작업 카피와 공통의 조상을 가집니다. 이것이 Subversion로 작업 카피를 다른 브랜치(branch)에 이동시키는 방법 입니다. > 에 의해 자세한 설명이 있습니다.

		별명

		sw

		변경 대상

		작업 카피

		저장소(repository)에의 액세스

		발생한다

		스윗치

		--revision (-r) REV
		--non-recursive (-N)
		--quiet (-q)
		--diff3-cmd CMD
		--relocate
		--username USER
		--password PASS
		--no-auth-cache
		--non-interactive

		례

		지금'vendors-with-fix'로부터 분기 한'vendors'라고 하는 디렉토리의 내부에 있어, 그 브랜치(branch)의 작업 카피로 옮기고 싶을 때에는:

		$ svn switch http://svn.red-bean.com/repos/branches/vendors-with-fix .
		U  myproj/foo.txt
		U  myproj/bar.txt
		U  myproj/baz.c
		U  myproj/qux.c
		Updated to revision 31.

		그리고, 원래대로 돌아가고 싶을 때에는, 최초로 작업 카피를 체크아웃 했다 저장소(repository)의 장소를 URL로서 지정할 뿐입니다:

		$ svn switch http://svn.red-bean.com/repos/trunk/vendors .
		U  myproj/foo.txt
		U  myproj/bar.txt
		U  myproj/baz.c
		U  myproj/qux.c
		Updated to revision 31.

		Tip: 작업 카피 전체를 바꾸고 싶지 않은 경우, 그 일부만을 브랜치(branch)에 바꿀 수도 있습니다.

		저장소(repository)의 장소가 변경되었지만, 그대로 계속해 이용하고 싶다고 생각한다 작업 카피가 있는 경우,svn switch --relocate를 사용해 어느 URL로부터 다른 URL를 가리키도록(듯이) 작업 카피를 변경할 수가 있습니다:

		$ svn checkout file:///tmp/repos test
		A  test/a
		A  test/b


		$ mv repos newlocation
		$ cd test/

		$ svn update
		svn: Couldn't open a repository.
		svn: Unable to open an ra_local session to URL
		svn: Unable to open repository 'file:///tmp/repos'

		$ svn switch --relocate file:///tmp/repos file:///tmp/newlocation .
		$ svn update
		At revision 3.

		svn update

		Name

		svn update  -- 작업 카피의 갱신.
		용법

		svn update [PATH...]
		설명

		svn update 는, 저장소(repository)의 수정을 작업 카피에 반영합니다. 리비전을 지정하지 않으면, HEAD 리비전의 최신 의 내용이 반영됩니다. 그렇지 않으면,--revision 스윗치 그리고 지정된 리비전에 작업 카피를 동기 합니다.

		갱신되는 아이템 마다, 어떠한 동작을 일으켰는지를 나타내는 캐릭터로 시작된다 행이 표시됩니다. 이 캐릭터는 이하와 같은 의미입니다:

		A
		추가

		D
		삭제

		U
		갱신

		C
		충돌

		M
		merge

		최초의 칼럼의 캐릭터는 실제의 파일의 갱신을 나타냅니다만, 파일의 속성의 갱신 상황은 두번째의 칼럼에서 가리킵니다.

		별명

		up

		변경 대상

		작업 카피

		저장소(repository)에의 액세스

		발생한다

		스윗치

		--revision (-r) REV
		--non-recursive (-N)
		--quiet (-q)
		--username USER
		--password PASS
		--no-auth-cache
		--non-interactive

		례

		마지막 갱신 후에 일어난 저장소(repository)의 수정을 수중에 넣습니다:

		$ svn update
		A  newdir/toggle.c
		A  newdir/disclose.c
		A  newdir/launch.c
		D  newdir/README
		Updated to revision 32.

		좀 더 낡은 리비전으로 작업 카피를 갱신할 수도 있습니다. (Subversion 는 CVS 와 같이"붙어" 파일 의 개념을 가지지 않습니다. >(을)를 봐 주세요):

		svn update -r30
		A  newdir/README
		D  newdir/toggle.c
		D  newdir/disclose.c
		D  newdir/launch.c
		U  foo.c
		Updated to revision 30.

		Tip: 하나의 파일의 낡은 버전을 조사하고 싶을 때에는 svn cat를 사용하고 싶어질지도 알려지지 않습니다.

		1.2. svnadmin

		svnadmin 는 Subversion 저장소(repository)를 감시하거나 수복하거나하기 위한 관리툴입니다. 자세하게는>을 봐 주세요.

		svnadmin는 직접 저장소(repository)에 대한 액세스에 보다 동작하므로(그리고, 저장소(repository)가 존재하는 머신상에서만 이용하는 것이 할 수 있으므로), URL가 아니고, 패스명에 의해 저장소(repository)를 참조합니다.

		1.2.1. svnadmin스윗치

		--bypass-hooks
		저장소(repository)의 훅을 우회 합니다.

		--copies
		패스를 조사할 때 카피 히스토리를 표시합니다.

		--in-repos-template ARG
		새로운 저장소(repository)를 작성할 경우에, 저장소(repository) 구조의 템플릿을 지정합니다.

		"in-repository" 템플릿은 저장소(repository) 자신의 레이아웃 (을)를 지정합니다(그것은, db/ 디렉토리안의 Berkeley DB 파일 그리고 사용됩니다). /trunk, /branches ···(와)과 같은 형태입니다. 템플릿은 저장소(repository)의 최초의 로드를(hook 없음으로) 실행하는데 관리자나 어플리케이션에 의해 사용하는 것이라고 옵니다. 디폴트는 없습니다. 아무것도 지정하지 않으면 저장소(repository)는"빈 상태로" 로 작성됩니다.

		--incremental
		리비전의 전체를 덤프 하는 것이 아니라, 이전의 리비전에 대한 차분으로서 덤프 합니다.

		--on-disk-template ARG
		만들고 싶다고 생각하는 저장소(repository)를 위해서(때문에), 디스크상의 구조를 템플릿에 이용하도록(듯이) 지정합니다.

		"on-disk" 템플릿은 저장소(repository)의 디렉토리 그것을 나타냅니다. 각각의 템플릿은 이름을 갖고, "default" 의 디스크 템플릿은, 이하와 같은 내용을 가집니다:

		default/

		README.txt

		dav/

		format

		hooks/

		post-commit.tmpl

		post-revprop-change.tmpl

		pre-commit.tmpl

		pre-revprop-change.tmpl

		start-commit.tmpl

		locks/

		db.lock

		디스크상의 구조의 전형적인 사용법은 작성되는 푹스 클립트로서 벌써 정의된 것을 사용하는 것 같은 경우입니다. 예를 들어 커밋시의 메일러와 백업 스크립트가 있다 post-commit 스크립트를 만들어 있다고 합니다. 이후, 관리자가 새로운 저장소(repository)를 만들 때마다, 모든 훅을 미리 자동적으로 포함한, 이 새로운 템플릿을 지정한다 일이 생깁니다.

		--revision (-r) ARG
		조작 대상이 되는 특정의 리비전을 지정합니다.

		1.2.2. svnadmin 서브 커멘드

		Table of Contents
		svnadmin list-unused-dblogs -- 어느 로그 파일이 안전하게 삭제 가능한가를 Berkeley DB 에 문의 .
		svnadmin create -- REPOS_PATH에 신규의 빈 저장소(repository)를 만듭니다.
		svnadmin dump -- 파일 시스템의 내용을 표준 출력에 덤프 합니다.
		svnadmin help --
		svnadmin load -- 표준 입력으로부터"덤프 형식" 의 데이터를 읽어들입니다.
		svnadmin lstxns -- 커밋되어 있지 않은 모든 트랜잭션(transaction)의 이름의 표시.
		svnadmin recover -- 저장소(repository)중이 없어진 상황의 복원.
		svnadmin rmtxns -- 저장소(repository)로부터 트랜잭션(transaction)를 삭제합니다.
		svnadmin setlog -- 리비전에 로그 메세지를 설정합니다.
		svnadmin list-unused-dblogs

		Name

		svnadmin list-unused-dblogs  -- 어느 로그 파일이 안전하게 삭제 가능한가를 Berkeley DB 에 문의 .
		용법

		svnadmin list-unused-dblogs REPOS_PATH
		설명

		Berkeley DB 는 긴급시의 리커버리를 위해서(때문에) 저장소(repository)의 모든 변경점의 로그를 만듭니다. 시간과 함께 로그 파일은 축적됩니다만, 그 대부분은 벌써 이용되지 않고, 디스크 area를 펼치기 위해서(때문에) 삭제할 수가 있습니다. 자세한 것은 > (을)를 봐 주세요.

		례

		모든 이용되어 있지 않은 로그 파일을 저장소(repository)로부터 삭제합니다:

		$ svnadmin list-unused-dblogs /path/to/repos
		/path/to/repos/log. 0000000031
		/path/to/repos/log. 0000000032
		/path/to/repos/log. 0000000033

		$ svnadmin list-unused-dblogs /path/to/repos | xargs rm
		## disk space reclaimed!

		svnadmin create

		Name

		svnadmin create  -- REPOS_PATH에 신규의 빈 저장소(repository)를 만듭니다.
		용법

		svnadmin create REPOS_PATH
		설명

		지정한 패스에 신규에 빈 저장소(repository)를 만듭니다. 패스가 존재하지 않으면 자동적으로 만들어집니다.

		스윗치

		--on-disk-template arg
		--in-repos-template arg

		례

		새롭게 저장소(repository)를 만들려면 단지 이하와 같이 합니다:

		$ svnadmin create /usr/local/svn/repos

		svnadmin dump

		Name

		svnadmin dump  -- 파일 시스템의 내용을 표준 출력에 덤프 합니다.
		용법

		svnadmin dump REPOS_PATH [-r LOWER[:UPPER]] [--incremental]
		설명

		파일 시스템의 내용을'dumpfile'가반가능 형식에서 덤프 해, 진행 상황 (을)를 표준 출력에 표시합니다. 리비전 LOWER 로부터, UPPER까지를 덤프 합니다. 리비전이 지정 되지 않으면 모든 리비전 트리를 덤프 합니다. LOWER만이 지정되었을 경우는 하나의 리비전 트리만 덤프 합니다. 실제의 사용법에 대해서는> 을 봐 주세요.

		스윗치

		--revision (-r)
		--incremental

		례

		저장소(repository) 전체의 덤프:

		$ svnadmin dump /usr/local/svn/repos
		SVN-fs-dump-format-version: 1
		Revision-number: 0
		* Dumped revision 0.
		Prop-content-length: 56
		Content-length: 56


		저장소(repository)의 하나의 트랜잭션(transaction)의 차분 덤프:

		$ svnadmin dump /usr/local/svn/repos -r 21 --incremental
		* Dumped revision 21.
		SVN-fs-dump-format-version: 1
		Revision-number: 21
		Prop-content-length: 101
		Content-length: 101


		svnadmin help

		Name

		svnadmin help
		용법

		svnadmin help [SUBCOMMAND...]
		설명

		이 서브 커멘드는 네트워크 접속이 잘 되지 않게 되어 이 책의 카피를 읽을 수 없게 되거나 해 어디엔가 헤매어 버렸다 같은 때에 도움이 됩니다.

		svnadmin load

		Name

		svnadmin load  -- 표준 입력으로부터"덤프 형식" 의 데이터를 읽어들입니다.
		용법

		svnadmin load REPOS_PATH
		설명

		표준 입력으로부터"덤프 형식" 의 데이터를 읽어들여, 저장소(repository)의 파일 시스템에 새롭다 리비전을 커밋합니다. 진행 상황은 표준 출력에 표시됩니다.

		례

		이것은 백업파일로부터 저장소(repository)를 로드하는 최초의 부분입니다(물론 미리svn dump로 덤프 해 둔 것입니다):

		$ svnadmin load /usr/local/svn/restored  repos-backup
		 Started new txn, based on original revision 1
		     * adding path : test ... done.
		     * adding path : test/a ... done.


		svnadmin lstxns

		Name

		svnadmin lstxns  -- 커밋되어 있지 않은 모든 트랜잭션(transaction)의 이름의 표시.
		용법

		svnadmin lstxns REPOS_PATH
		설명

		커밋되어 있지 않은 모든 트랜잭션(transaction)의 이름을 표시합니다. 커밋되어 있지 않은 트랜잭션(transaction)는 어떻게 만들어져 어떻게 취급해야할 것인가에 대해서는> 을 봐 주세요.

		례

		저장소(repository)중의 미해결의 트랜잭션(transaction) 일람의 표시.

		$ svnadmin lstxns /usr/local/svn/repos/
		1w
		1x

		svnadmin recover

		Name

		svnadmin recover  -- 저장소(repository)중이 없어진 상황의 복원.
		용법

		svnadmin recover REPOS_PATH
		설명

		저장소(repository)는 수복될 필요가 있다고 하는 에러 메세지를 받아들였다 때로는 이 커멘드를 실행해 주세요.

		Warning
		저장소(repository)에 액세스 하고 있는 것이 자신 뿐이다고 하는 것이 완전하게 확실한 경우에만 이 커멘드를 실행해 주세요이 커멘드에는 배타적인 액세스권이 필요합니다. 저장소(repository)의 수복에 관한 자세한 것은 >(을)를 봐 주세요.

		례

		헹 해 버린 저장소(repository)의 수복:

		$ svnadmin recover /usr/local/svn/repos/
		Acquiring exclusive lock on repository db.
		Recovery is running, please stand by...
		Recovery completed.
		The latest repos revision is 34.

		svnadmin rmtxns

		Name

		svnadmin rmtxns  -- 저장소(repository)로부터 트랜잭션(transaction)를 삭제합니다.
		용법

		svnadmin rmtxns REPOS_PATH TXN_NAME...
		설명

		미해결의 트랜잭션(transaction)를 저장소(repository)로부터 삭제합니다. 이것은,>그리고 자세하게 접할 수 있고 있습니다.

		례

		이름이 붙은 트랜잭션(transaction)의 삭제:

		$ svnadmin rmtxns /usr/local/svn/repos/ 1w 1x

		행운의 일로, svn lstxns 의 출력은, rmtxns의 입력과 같은 정도 잘 움직입니다:

		$ svnadmin rmtxns /usr/local/svn/repos/  `svnadmin lstxns /usr/local/svn/repos/`

		이것은 저장소(repository)로부터 모든 커밋되어 있지 않은 트랜잭션(transaction) (을)를 삭제합니다.

		svnadmin setlog

		Name

		svnadmin setlog  -- 리비전에 로그 메세지를 설정합니다.
		용법

		svnadmin setlog REPOS_PATH -r REVISION FILE
		설명

		FILE의 내용을 리비전 REVISION의 로그 메세지로서 설정합니다.

		이것은,svn propset --revprop를 사용해 리비전상에 svn:log속성을 설정하는 것과 닮아 있습니다만, --bypass-hooks를 사용해 커밋 전후의 훅의 실행을 피한다 일이 생깁니다. 이것은 pre-revprop-change 훅중에서 리비전 속성의 수정 하지만 유효하지 않는 경우에 편리합니다.

		Warning
		리비전 속성은 버전 관리하에는 없기 때문에 이 커멘드는 이전의 로그 메세지를 완전하게 덧쓰기해 버립니다.

		스윗치

		--revision (-r) ARG
		--bypass-hooks

		례

		파일'msg'의 내용을 리비전 19의 로그 메세지로 설정합니다:

		$ svnadmin setlog /usr/local/svn/repos/ -r 19 msg

		1.3. svnlook

		svnlook 는 Subversion 저장소(repository)의 다른 부분을 조사하기 위한 커멘드 라인 툴입니다. 이 커멘드는 저장소(repository)에는 무슨 변경도 더하지 않습니다단지"조사하는"싶은 에 이용됩니다. svnlook는 저장소(repository) 훅으로 이용되는 것이 전형적입니다만, 저장소(repository) 관리자는 진단의 목적으로도 이용할 수 있는 것에 눈치챌지도 알려지지 않습니다.

		svnlook 는 직접 저장소(repository)에 액세스 하는 형태로 실행된다 의로(그리고, 그것이 이유로 저장소(repository)의 존재하는 머신상에서만 이용하는 것이 할 수 있습니다만), URL가 아니고, 패스 명칭에 의해 저장소(repository)를 참조합니다.

		리비전이나 트랜잭션(transaction)가 지정되지 않으면, svnlook 는 저장소(repository)의 최신 리비전을 사용합니다.

		1.3.1. svnlook스윗치

		svnlook 중의 스윗치는 svn 나svnadmin등과 함께로 글로벌하게 일합니다만, (정도)만큼 어느 스윗치는 하나의 서브 커멘드에 밖에 효과가 없습니다. 그것은svnlook의 기능의 유효 범위가(의도적으로) 한정되어 있기 때문입니다.

		--no-diff-deleted
		svnlook가 삭제된 파일의 차이를 표시하지 않게 합니다. 트랜잭션(transaction)/리비전중에서 파일이 삭제되었을 때의 디폴트 동작은, 그 파일이 빈 파일로서 남아 있을 때 것과 같게 됩니다.

		--revision (-r)
		조사하고 싶은 특정의 리비전 번호를 지정합니다.

		--transaction (-t)
		조사하고 싶은 특정의 트랜잭션(transaction) 번호를 지정합니다.

		--show-ids
		파일 시스템 트리중의, 각각의 패스마다의 파일 시스템 노드 리비전 번호를 표시합니다.

		1.3.2. svnlook 서브 커멘드

		Table of Contents
		svnlook author -- 처리한 사람의 표시.
		svnlook cat -- 파일의 내용을 표시합니다
		svnlook changed -- 변경된 패스를 표시합니다.
		svnlook date -- 일자를 표시합니다.
		svnlook diff -- 변경된 파일, 디렉토리의 차분을 표시합니다.
		svnlook dirs-changed -- 변경이 있던 디렉토리를 표시합니다.
		svnlook help --
		svnlook history -- 저장소(repository)중의 패스의 히스토리에 관한 정보를 표시합니다 (혹은 패스가 지정되지 않았던 경우에는 루트 디렉토리가 됩니다).
		svnlook info -- 작업자, 일자, 로그 메세지의 크기, 로그 메세지를 표시합니다.
		svnlook log -- 로그 메세지를 표시합니다.
		svnlook proplist -- 버전화 된 파일과 디렉토리의 속성의 이름과 값을 표시합니다.
		svnlook tree -- 트리를 표시합니다.
		svnlook youngest -- 제일 최근의 리비전 번호를 표시합니다.
		svnlook author

		Name

		svnlook author  -- 처리한 사람의 표시.
		용법

		svnlook author REPOS_PATH
		설명

		저장소(repository)의 리비전이나 트랜잭션(transaction)를 실행했다 사람을 표시합니다.

		스윗치

		--revision (-r)
		--transaction (-t)

		례

		svnlook author는 편리합니다만, 그만큼 재미있는 커멘드가 아닙니다:

		$ svnlook author -r 40 /usr/local/svn/repos
		sally

		svnlook cat

		Name

		svnlook cat  -- 파일의 내용을 표시합니다
		용법

		svnlook cat REPOS_PATH PATH_IN_REPOS
		설명

		파일의 내용을 표시합니다.

		스윗치

		--revision (-r)
		--transaction (-t)

		례

		이하는/trunk/README 에 있는 트랜잭션(transaction) ax8중의 파일의 내용을 표시하고 있습니다:

		$ svnlook cat -t ax8 /usr/local/svn/repos /trunk/README

		               Subversion, a version control system.
		               =====================================

		$LastChangedDate: 2003-07-17 10:45:25 -0500 (Thu, 17 Jul 2003) $

		Contents:

		     I.  A FEW POINTERS
		    II.  DOCUMENTATION
		   III.  PARTICIPATING IN THE SUBVERSION COMMUNITY


		svnlook changed

		Name

		svnlook changed  -- 변경된 패스를 표시합니다.
		용법

		svnlook changed REPOS_PATH
		설명

		"svn update-style" 의 제일 스테이터스 캐릭터와 같이 특정의 리비전이나 트랜잭션(transaction)로 변경된 패스를 표시합니다: A 는 추가,D 는 삭제,U 는 수정을 나타냅니다.

		스윗치

		--revision (-r)
		--transaction (-t)

		례

		테스트 저장소(repository)의 리비전 99로 수정한 모든 파일의 일람을 표시합니다:

		$ svnlook changed -r 39 /usr/local/svn/repos
		A   trunk/vendors/deli/
		A   trunk/vendors/deli/chips.txt
		A   trunk/vendors/deli/sandwich.txt
		A   trunk/vendors/deli/pickle.txt

		svnlook date

		Name

		svnlook date  -- 일자를 표시합니다.
		용법

		svnlook date REPOS_PATH
		설명

		저장소(repository)중의 특정 리비전이나 트랜잭션(transaction)의 일자를 표시합니다.

		스윗치

		--revision (-r)
		--transaction (-t)

		례

		이것은, 테스트 저장소(repository)의 리비전 40의 일자를 표시합니다:


		$ svnlook date -r 40 /tmp/repos/
		2003-02-22 17:44:49 -0600 (Sat, 22 Feb 2003)

		svnlook diff

		Name

		svnlook diff  -- 변경된 파일, 디렉토리의 차분을 표시합니다.
		용법

		svnlook diff REPOS_PATH
		설명

		저장소(repository)중에서 변경된 파일, 속성의 차분을 GNU 형식에서 표시합니다.

		스윗치

		--revision (-r)
		--transaction (-t)
		--no-diff-deleted

		례

		이것은, 새롭게 추가된 파일(빈 파일), 삭제된 파일, 카피되었다 파일을 표시합니다:

		$ svnlook diff -r 40 /usr/local/svn/repos/
		Copied: egg.txt (from rev 39, trunk/vendors/deli/pickle.txt)

		Added: trunk/vendors/deli/soda.txt
		==============================================================================

		Modified: trunk/vendors/deli/sandwich.txt
		==============================================================================
		--- trunk/vendors/deli/sandwich.txt (original)
		+++ trunk/vendors/deli/sandwich.txt 2003-02-22 17:45:04. 000000000 -0600
		@@ -0, 0 +1 @@
		+Don't forget the mayo!

		Deleted: trunk/vendors/deli/chips.txt
		==============================================================================

		Deleted: trunk/vendors/deli/pickle.txt
		==============================================================================

		svnlook dirs-changed

		Name

		svnlook dirs-changed  -- 변경이 있던 디렉토리를 표시합니다.
		용법

		svnlook dirs-changed REPOS_PATH
		설명

		(속성을 편집에 의해) 그것 자신으로 변경이 있었는지, 그 아이의 파일로 변경이 있던 디렉토리를 표시합니다.

		스윗치

		--revision (-r)
		--transaction (-t)

		례

		우리의 샘플 저장소(repository)중의 리비전 40으로 수정되었다 디렉토리를 표시합니다:

		$ svnlook dirs-changed -r 40 /usr/local/svn/repos
		trunk/vendors/deli/

		svnlook help

		Name

		svnlook help
		용법

		Also svnlook -h and svnlook -?.
		설명

		svnlook 의 헬프를 표시합니다. svn help의 헬프와 같아, 무엇인가가 모르게 되었을 때에는 항상 도움이 됩니다.

		svnlook history

		Name

		svnlook history  -- 저장소(repository)중의 패스의 히스토리에 관한 정보를 표시합니다 (혹은 패스가 지정되지 않았던 경우에는 루트 디렉토리가 됩니다).
		용법

		svnlook history REPOS_PATH
		            [PATH_IN_REPOS]
		설명

		저장소(repository)중의 패스의 히스토리에 관한 정보를 표시합니다 (혹은 패스가 지정되지 않았던 경우에는 루트 디렉토리가 됩니다).

		스윗치

		--revision (-r)
		--show-ids

		례

		이하는 예로서 만든 저장소(repository)의 리비전 15 로 보았다 패스/tags/1. 0의 히스토리 표시입니다.

		$ svnlook history -r 20 /usr/local/svn/repos /tags/1. 0 --show-ids
		REVISION   PATH ID
		--------   ---------
		      19   /tags/1. 0 1. 2.12
		      17   /branches/1. 0-rc2 1. 1.10
		      16   /branches/1. 0-rc2 1. 1. x
		      14   /trunk 1. 0. q
		      13   /trunk 1. 0. o
		      11   /trunk 1. 0. k
		       9   /trunk 1. 0. g
		       8   /trunk 1. 0. e
		       7   /trunk 1. 0. b
		       6   /trunk 1. 0.9
		       5   /trunk 1. 0.7
		       4   /trunk 1. 0.6
		       2   /trunk 1. 0.3
		       1   /trunk 1. 0.2

		svnlook info

		Name

		svnlook info  -- 작업자, 일자, 로그 메세지의 크기, 로그 메세지를 표시합니다.
		용법

		svnlook info REPOS_PATH
		설명

		작업자, 일자, 로그 메세지의 크기, 로그 메세지를 표시합니다.

		스윗치

		--revision (-r)
		--transaction (-t)

		례

		이것은 샘플 저장소(repository)의 리비전 40에 대한 info 의 출력입니다.

		$ svnlook info -r 40 /usr/local/svn/repos
		sally
		2003-02-22 17:44:49 -0600 (Sat, 22 Feb 2003)
		15
		Rearrange lunch.

		svnlook log

		Name

		svnlook log  -- 로그 메세지를 표시합니다.
		용법

		svnlook log REPOS_PATH
		설명

		로그 메세지를 표시합니다.

		스윗치

		--revision (-r)
		--transaction (-t)

		례

		이것은 샘플 저장소(repository)의 리비전 40의 로그 표시입니다:

		$ svnlook log /tmp/repos/
		Rearrange lunch.

		svnlook proplist

		Name

		svnlook proplist  -- 버전화 된 파일과 디렉토리의 속성의 이름과 값을 표시합니다.
		용법

		svnlook proplist REPOS_PATH PATH_IN_REPOS
		설명

		저장소(repository)중의 패스의 속성을 일람표 가리킵니다. -v를 사용해 속성치도 표시할 수 있습니다.

		스윗치

		--revision (-r)
		--transaction (-t)
		--verbose (-v)

		례

		이것은 HEAD 리비전에 있는 파일/trunk/README (으)로 설정된 속성명을 표시하고 있습니다:

		$ svnlook proplist /usr/local/svn/repos /trunk/README
		  original-author
		  svn:mime-type

		이것은 전의 예와 같은 커멘드입니다만, 이번은 속성치도 함께 표시 하고 있습니다:

		$ svnlook proplist /usr/local/svn/repos /trunk/README
		  original-author : fitz
		  svn:mime-type : text/plain

		svnlook tree

		Name

		svnlook tree  -- 트리를 표시합니다.
		용법

		svnlook tree REPOS_PATH [PATH_IN_REPOS]
		설명

		PATH_IN_REPOS 로부터 시작되는 트리를 표시합니다. (PATH_IN_REPOS 의 지정이 없는 경우에는 루트로부터 시작되는 트리를 표시합니다. ). 옵션으로 노드 리비전 id를 표시시킬 수도 있습니다.

		스윗치

		--revision (-r)
		--transaction (-t)
		--show-ids

		례

		이것은, (노드 번호 돌출하고) 샘플 저장소(repository)의 리비전 40의 트리를 표시한 것입니다:

		$ svnlook tree -r 40 /usr/local/svn/repos --show-ids
		/ 0. 0.2j
		 trunk/ p. 0.2j
		  vendors/ q. 0.2j
		   deli/ 1g. 0.2j
		    egg.txt 1i.e. 2j
		    soda.txt 1k. 0.2j
		    sandwich.txt 1j. 0.2j

		svnlook youngest

		Name

		svnlook youngest  -- 제일 최근의 리비전 번호를 표시합니다.
		용법

		svnlook youngest REPOS_PATH
		설명

		저장소(repository)에 있는 제일 최근의 리비전 번호를 표시합니다.

		례

		이것은, 샘플 저장소(repository)의 제일 최근의 리비전 번호를 표시하고 있습니다:


		$ svnlook youngest /tmp/repos/
		42

		Notes

		[1]
		네, 그렇네요. --version 스윗치를 사용할 때에는 서브 커멘드는 불필요합니다. 조금 다음에 그것에 접합니다.

----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------

----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
[ SVN ]

폴더 제외

- 제외 하고 자 하는 폴더를 마우스 오른쪽 버튼 -> Team -> Add to svn:ignore

파일 제외(확장자 등)

- Windows -> Preference -> Team -> Ignored Resources

에서 특정 확장자를 선택해서 제외 하면 됨

----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------

Corp.  (corporation) : 법인 종합상사로 단체, 사단법인을 칭할 때 사용합니다.
    미국에서는 법인을 뜻하고 영국에서는 주식회사로 통합니다.
    보통 이것은 규모가 좀 큰 곳에서 사용하는 것 같습니다.

Co., Ltd. (Company Limited): . : 주식회사이면서 유한책임회사인 경우에 사용하는 표기 입니다.
    Company는 말그대로 회사의 약자임을 나타내고 limited는 유한책임을 나타내는 말입니다.
    이 단어는 표기에 주의해야하는데 .(마침표)는 compant의 약자이므로 표시하는것이고 ,(콤마) 는
    company 와 limited를 구분표시할 때 사용하는 것이기 때문에 꼭 사용해야 합니다.

Inc.  (Incorporated) : 미국에서 말하는 주식회사는 이 표기를 많이 사용합니다.

    이외에 개인회사의 경우에는 Company의 줄임말인 Co.를 사용하시는 것이 좋습니다.

PLC  (Public Limited Company) - 상장법인으로 이것도 개인회사의 경우 많이 사용되는데 영국에서 많이 사용됩니다.
    또 우리나라 회사법제에서 인정되지 아니하는 회사형태로 LLC라는 형태가 있습니다. 이는
    유한책임이라는 점에서 주식회사와 유사하나 법인세 면제조치 등 측면에서 조합적 겅격이
    강조되는 회사로 유한회사와 조합의 중간정도의 성격이라고 생각하시면 되는 곳입니다.

    이는 명확히 구분하기 힘들 수도 있는데 이들의 가장 큰 차이점은 문제발생시 책임을 어디까지
    지는가입니다. Corp.의 경우에는 개인사업자와 동일한 책임을 지는 무한책임회사를 말합니다.
    보통합자회사의 경우 무한책임을 집니다. 즉, 자신들이 투자한 회사돈이 채권자들에게 줄돈보다
    부족하면 사재를 털어서라도 갚아야 합니다. 그러나 Co.,Ltd는 유한책임회사이기 때문에 회사가
    파산한다고해도 사주에게 책임을 물을 수 없는 곳을 회사의 사주가 출자한 범위내에서만 회사의
    자본위엄에 대한 책임을 집니다.

----------------------------------------------------------------------------------------------------
[ data grid : 한글문제 (32BIT) ]

AMERICAN_AMERICA.US7ASCII


----------------------------------------------------------------------------------------------------
[ DATA GRID : 한글문제 (64BIT) ]

http://metalzang.blog.me/130127660830

1. Toad에서 데이터 베이스의 캐릭터 셋을 확인

    select * from nls_database_parameters where parameter = 'NLS_CHARACTERSET';

2. 결과를 확인하니 'KO16MSWIN949'임.



----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------

----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------

/*
http://sourceforge.net/projects/sshtools/
*/

package com.mimul.sample;
import com.sshtools.j2ssh.SftpClient;
import com.sshtools.j2ssh.SshClient;
import com.sshtools.j2ssh.authentication.AuthenticationProtocolState;
import com.sshtools.j2ssh.authentication.PasswordAuthenticationClient;
public class J2sshSftpCient
{
    private SshClient client = null;
    private PasswordAuthenticationClient auth = null;
    private SftpClient sftp = null;

    public J2sshSftpCient(String server, String user, String pwd) throws Exception
    {
        try {
            if (server == null || user == null || pwd == null) {
                System.out.println("Parameter is null!");
            }
            client = new SshClient();
            client.setSocketTimeout(70000);
            client.connect(server);

            auth = new PasswordAuthenticationClient();
            auth.setUsername(user);
            auth.setPassword(pwd);
            int result = client.authenticate(auth);
            if (result != AuthenticationProtocolState.COMPLETE) {
                 throw new Exception("Login to " + server + ":22" +
                      user + "/" + pwd + " failed");
            }
            sftp = client.openSftpClient();
        } catch (Exception e) {
            System.out.println(e);
            throw e;
        }
    }

    public boolean put(String path) throws Exception
    {
        boolean rtn = false;
        try    {
            if (sftp != null) {
                sftp.put(path);
                rtn = true;
            }
        } catch(Exception e) {
            System.out.println(e);
        }
        return rtn;
    }

    public boolean get(String srcFile, String destFile) throws Exception
    {
        boolean rtn = false;
        try {
            if (sftp != null) {
                if (destFile == null)
                    sftp.get(srcFile);
                else
                    sftp.get(srcFile, destFile);
                rtn = true;
            }
        } catch(Exception e) {
            System.out.println(e);
        }
        return rtn;
    }

    public boolean lcd(String path) throws Exception
    {
        boolean rtn = false;
        try {
            if (sftp != null) {
                sftp.lcd(path);
                rtn = true;
            }
        } catch(Exception e) {
            System.out.println(e);
        }
        return rtn;
    }

    public boolean cd(String path) throws Exception
    {
        boolean rtn = false;
        try {
            if (sftp != null) {
                sftp.cd(path);
                rtn = true;
            }
        } catch(Exception e) {
            System.out.println(e);
        }
        return rtn;
    }

    public String pwd() throws Exception
    {
        String rtnStr = null;
        try {
            if (sftp != null) {
                rtnStr = sftp.pwd();
            }
        } catch(Exception e) {
            System.out.println(e);
        }
        return rtnStr;
    }

    public boolean chmod(int permissions, String path) throws Exception
    {
        boolean rtn = false;
        try {
            if (sftp != null) {
                sftp.chmod(permissions, path);
                rtn = true;
            }
        } catch(Exception e) {
            System.out.println(e);
        }
        return rtn;
    }

    public boolean isClosed() throws Exception
    {
        boolean rtn = false;
        try {
            if (sftp != null)
                rtn = sftp.isClosed();
        } catch(Exception e) {
            System.out.println(e);
        }
        return rtn;
    }

    public boolean logout() throws Exception
    {
        boolean rtn = false;
        try {
            if (sftp != null)
                sftp.quit();
            if (client != null)
                client.disconnect();
            rtn = true;
        } catch(Exception e) {
            System.out.println(e);
        }
        return rtn;
    }

    public static void main(String[] args)
    {
        try {
            J2sshSftpCient jsftp = new J2sshSftpCient("remotehost", "userid",
                "password");
            boolean test = jsftp.cd("/home/k2/data");
            System.out.println(jsftp.pwd());
            boolean test1 = jsftp.lcd("C:/");
            boolean test2 = jsftp.get("README.TXT", "README.TXT");
            boolean isClosed = jsftp.isClosed();
            boolean test3 = jsftp.logout();
            System.out.println(test + " " + test1 + " " + test2 +
               " " + isClosed + " " + test3);
        } catch (Exception e) {
            System.out.println(e);
        }
    }
}

----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
[ Connection Pool ]


    [ Tomcat Connection Pool (JNDI) ]

    tomcat > conf > context.xml

        <Context>
            <WatchedResource> WEB-INF/web.xml </WatchedResource>

            // Oracle
            <Resource name="jdbc/vip125_ora"
                auth="Container"
                type="javax.sql.DataSource"
                driverClassName="oracle.jdbc.driver.OracleDriver"
                username="id"
                password="pwd"
                url="jdbc:oracle:thin:@localhost(ip):1521:db_name"
                validationQuery="SELECT 1 AS A  FROM DUAL"
                testWhileIdle="true"
                validationInterval="60000"
                maxActive="50"
                maxIdle="10"
                maxWait="-1"
                minIdle="0"/>

            // MySQL
            <Resource name="jdbc/vip123_my"
                auth="Container"
                type="javax.sql.DataSource"
                driverClassName="com.mysql.jdbc.Driver"
                username="id"
                password="pwd"
                url="jdbc:mysql://localhost(ip):3306/db_name"
                validationQuery="SELECT 1 AS A FROM DUAL"
                testWhileIdle="true"
                validationInterval="60000"
                maxActive="50"
                maxIdle="10"
                maxWait="-1"
                minIdle="0"/>
        </Context>

    Web Root > WEB-INF > web.xml

        <web-app xmlns="http://java.sun.com/xml/ns/javaee"....>

            // Oracle
            <resource-ref>
                <description>vip125_conn</description>
                <res-ref-name>jdbc/vip125_ora</res-ref-name>
                <res-type>javax.sql.DataSource</res-type>
                <res-auth>Container</res-auth>
            </resource-ref>

            // MySQL
            <resource-ref>
                <description>vip125_conn</description>
                <res-ref-name>jdbc/vip125_my</res-ref-name>
                <res-type>javax.sql.DataSource</res-type>
                <res-auth>Container</res-auth>
            </resource-ref>

            // 아래 로직 위에 추가해야됨
            <description>
                Welcome to Tomcat
            </description>

        </web-app>

    DB Connection (DBCP)

        Context context = new InitialContext();
        DataSource dataSource = (DataSource) context.lookup("java:comp/env/jdbc/vip125_ora");
        Connection conn = dataSource.getConnection();

        * driverClassName의 경우 import된 jar 파일에 맞게 설정해준다.



----------------------------------------------------------------------------------------------------

    위와 같은 web.xml, server.xml(혹은 context.xml)의 <resource> 부분을 바꿔주면
    commonDBCP 가 아닌 tomcatDBCP를 사용하게 된다.

        <Resource name="jndi_dbcp"
            auth="Container"
            type="javax.sql.DataSource"
            factory="org.apache.tomcat.jdbc.pool.DataSourceFactory"
            testWhileIdle="true"
            testOnBorrow="true"
            testOnReturn="false"
            validationQuery="SELECT 1"
            validationInterval="30000"
            timeBetweenEvictionRunsMillis="30000"
            maxActive="100"
            minIdle="10"
            maxWait="10000"
            initialSize="10"
            removeAbandonedTimeout="60"
            removeAbandoned="true"
            logAbandoned="true"
            minEvictableIdleTimeMillis="30000"
            jmxEnabled="true"
            jdbcInterceptors="org.apache.tomcat.jdbc.pool.interceptor.ConnectionState;org.apache.tomcat.jdbc.pool.interceptor.StatementFinalizer"
            username="user"
            password="pass"
            driverClassName="com.mysql.jdbc.Driver"
            url="jdbc:mysql://localhost:3306/jdni_dbcp?autoReconnect=true"/>

----------------------------------------------------------------------------------------------------
[ Tomcat DBCP(DataBase Connection Pool) }

    톰캣에서 제공되는 DBCP입니다. 기존의 apache commons에서 제공되는 DBCP보다 향상된 DBCP입니다.
    기존 사용하는 apache commons의 DBCP와 사용법은 유사합니다.

    기존에는 아래의 라이브러리 파일등을 톰캣의 lib폴더에 차가하여 설정해야 했지만

        commons-dbcp-1.2.1.jar
        commons-pool-1.2.jar
        commons-collections-3.1.jar
        ...

    톰캣 6.0 이후 버전부터는 lib폴더에 tomcat-dbcp.jar라는 이름으로 통합되어 좀더 간편하고 강력하게
    DBCP를 사용할 수 있습니다.

    1. 톰캣의 server.xml 파일에 <Context> 부분 아래에 다음의 소스를 추가해줍니다.

        <Context docBase="....>
            <Resource name="jdbc/nyakao"
                auth="Container"
                type="javax.sql.DataSource"
                driverClassName="oracle.jdbc.driver.OracleDriver"
                url="jdbc:oracle:thin:@url:port:sid"
                username="user"
                password="pass"
                loginTimeout="10"
                maxActive="100"
                maxIdle="30"
                maxWait="10"/>
        </Context>

    2. web.xml 파일에서 server.xml에서 정의한 리소스를 사용하기 위해 설정합니다.

        <resource-ref>
            <description>오라클 DBCP 예제</description>
            <res-ref-name>jdbc/nyakao</res-ref-name>
            <res-type>javax.sql.DataSource</res-type>
            <res-auth>Container</res-auth>
        </resource-ref>

    3. tomcat을 재시작한다.

    4. 서브릿에서 아래와 같이 DataSource를 사용한다.

        DataSource ds;

        try {
            Context initContext = new InitialContext();
            Context envContext = (Context)initContext.lookup("java:/comp/env");
            DataSource ds = (DataSource) envContext.lookup("jdbc/nyakao");
            Connection conn = ds.getConnection();
        } catch (Exception e) {
            e.printStackTrace();
        }





----------------------------------------------------------------------------------------------------

Tomcat 6.0
jdk 6.0
Mysql 5.0
툴은 이클립스 사용중입니다.
프로젝트 생성은 Dynamic Web project로 했습니다.

제가 지금 밑에와 같은 에러가 뜹니다.
javax.naming.NoInitialContextException: Need to specify class name in environment or system property, or as an applet parameter, or in an application resource file:  java.naming.factory.initial
 at javax.naming.spi.NamingManager.getInitialContext(Unknown Source)
 at javax.naming.InitialContext.getDefaultInitCtx(Unknown Source)
 at javax.naming.InitialContext.getURLOrDefaultInitCtx(Unknown Source)
 at javax.naming.InitialContext.lookup(Unknown Source)
 at util.DBResource.getConnection(DBResource.java:17)
 at util.Test.main(Test.java:21)

프로젝트는 C:\Program Files\Apache Software Foundation\Tomcat 6.0\webapps\ROOT
에 위치에 있구요.
server.xml
<Host name="localhost"  appBase="webapps"
            unpackWARs="true" autoDeploy="true"
            xmlValidation="false" xmlNamespaceAware="false">
<Context path="" reloadable="true" docBase="/ROOT" >
<Resource
       name="jdbc/jkj"
       auth="Container"
       type="javax.sql.DataSource"
       driverClassName="com.mysql.jdbc.Driver"
       url="jdbc:mysql://localhost:3306/db"
       username="root"
       password="1234"
      />
</Context>
</host>

web.xml
<resource-ref>
     <description>MySQL</description>
     <res-ref-name>jdbc/jkj</res-ref-name>
     <res-type>javax.sql.DataSource</res-type>
     <res-auth>Container</res-auth>
  </resource-ref>

DBresource.java
package util;
import java.sql.*;
import javax.naming.Context;
import javax.naming.InitialContext;
import javax.naming.NamingException;
import org.apache.log4j.Logger;
public class DBResource {
 Logger log = Logger.getLogger(DBResource.class);

 public Connection getConnection() throws NamingException,SQLException{
  Context context = new InitialContext();
  Context env = (Context)context.lookup("java:comp/env");
  DataSource ds = (DataSource) env.lookup("jdbc/jkj");
  return ds.getConnection();
 }

 public void close(ResultSet rs,PreparedStatement pstmt, Connection con){
  try{
   if(rs != null) rs.close();
   if(pstmt !=null) pstmt.close();
   if((con != null) && (con.isClosed())) con.setAutoCommit(true);

  }catch(SQLException e){
   log.error(e.toString());
  }
 }
}

Test.java
package util;
import java.sql.*;
import util.DBResource;
public class Test {

 public static void main(String[] args) {
  // TODO Auto-generated method stub
  DBResource db = new DBResource();
  PreparedStatement pstmt = null;
  Connection con = null;
  ResultSet rs = null;

  try{
   con = db.getConnection();
  }catch (Exception e){
   e.printStackTrace();
  }finally{
   db.close(rs, pstmt, con);
  }
 }
}

소스는 위와 같습니다.
jsp  페이지에서는 이상없이 잘 나오는데 java에서 connection을 불러오면 위와 같은 에러가 발생하네요.
다 검색을 해보고 몇시간째 해보고 있는데 답이 안나와서 질문을 드립니다..
답변을  상세히 해주시면 감사하겠습니다..
그리고 ROOT 밑이 아닌 다른 디렉토리에 프로젝트를 생성하면 어떻게 설정을 해줘야 하는지도 알려주시면
감사하겠습니다.

----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------

oracle stored procedure를 자바소스에서 사용하기

Oracle 에서 입력된 stored procedure 를 java에서 실행해서 결과를 얻고 싶으시다면, Statement 대신에 CallableStatement class를 사용하여 호출하면 된다.
그 뒤에는 어차피 insert, update 같은 것들과 같이 성공 또는 실패, 성공시 몇개가 성공했는지, query 인 경우에는 ResultSet 받아서 fetch 하면서 값 뽑아서 쓰시면 된다.

         // 위에서 JDBC  드라이버 잡고 Connection 까지 맺은 상태…
      CallableStatement cs = con.prepareCall("{call myStoredProcedure(?,?,?)}");
      cs.setInt(1,2);
      cs.registerOutParameter(2, java.sql.Types.VARCHAR);
      cs.registerOutParameter(3, java.sql.Types.INTEGER);
      cs.execute();
      System.out.println("*name : "+ cs.getString(2) +"*age : "+ cs.getInt(3));
      cs.close();
      con.close();








다음은 JAVA program에서 parameter가 있는 pl/sql stored procedure를 호출하는 예제이다. (IN, OUT, IN OUT)

1. procedure 생성
create or replace procedure javatest(
  p1 in varchar2,
  p2 in out varchar2,
  p3 out varchar2) as
begin
  p2:=p1 || p2;
  p3:=p1;
end;
/



2. java source
import java.sql.*;
import java.io.*;
import java.util.*;
public class callInoutProc extends Object {
   public static void main(String[] args) throws SQLException {
      DriverManager.registerDriver(new oracle.jdbc.driver.OracleDriver());
      // DB 접속
      Connection conn = DriverManager.getConnection ("jdbc:oracle:oci8:@S692815.WORLD", "scott", "tiger");
      // 변수 선언
      String p1value = new String("a");
      String p2value = new String("b");
      String p3value;
      // Prepare statement
      CallableStatement cs = conn.prepareCall("{call javatest(?,?,?)}");
      // IN parameter 값을 넘기기 위해 setString 함수를 사용
      cs.setString(1,p1value);
      cs.setString(2,p2value);
      // OUT parameter에 대한 정보를 registerOutParameter 함수를 이용하여 설정
      cs.registerOutParameter(2,Types.VARCHAR);
      cs.registerOutParameter(3,Types.VARCHAR);
      // Statement 수행
      cs.execute();
      // 수행결과 data를 가져옴.
      p2value = cs.getString(2);
      p3value = cs.getString(3);
      // 수행결과 출력
      System.out.println("p2 + p2value);
      System.out.println("p3 + p3value);
   }
}
3. 수행 결과
Sample Output
p2 is ab
p3 is a

----------------------------------------------------------------------------------------------------

http://cafe.naver.com/buldon/4330


----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------

<!DOCTYPE html>
<html>
    <head>
        <title> sjisbmoc </title>
<script type="text/javascript" src="http://code.jquery.com/jquery.min.js"></script>
<script type='text/javascript'>
//<![CDATA[

/* 첫번째 select option 값 */
var sel_01_al   = new Array();
sel_01_al.push({value:20000,text:'원피스'});
sel_01_al.push({value:24000,text:'아우터'});
sel_01_al.push({value:30000,text:'드레스'});

/* 두번째 select option 값 */
var sel_02_al   = new Array();
sel_02_al.push({value:1,text:'1개'});
sel_02_al.push({value:2,text:'2개'});
sel_02_al.push({value:3,text:'3개'});
sel_02_al.push({value:4,text:'4개'});
sel_02_al.push({value:5,text:'5개'});

$(document).ready(function(){
    var sel1 = new Array();
    sel1.push('<option value="">선택</option>');
    for(var i=0; i<sel_01_al.length; i++) {
        sel1.push('<option value="'+sel_01_al[i].value+'">'+sel_01_al[i].text+'</option>');
    }

    $('#sel_01_Id').html(sel1.join(''));
    $('#sel_01_Id').change(function(){
        calcPrice();
    });

    var sel2 = new Array();
    sel2.push('<option value="">선택</option>');
    for(var i=0; i<sel_02_al.length; i++) {
        sel2.push('<option value="'+sel_02_al[i].value+'">'+sel_02_al[i].text+'</option>');
    }

    $('#sel_02_Id').html(sel2.join(''));
    $('#sel_02_Id').change(function(){
        calcPrice();
    });
});

function calcPrice() {
    var price = Number($('#sel_01_Id').val());
    var qut   = Number($('#sel_02_Id').val());
    if(price>0 && qut>0) {
        $('#dispId').html((String(price*qut)).comma());
    } else {
        $('#dispId').html('');
    }
}

String.prototype.comma = Number.prototype.comma = function() {
    var n = String(this).replace(/\,/g,'');
    return n.match(RegExp('^[0-9]{'+(n.length%3||3)+'}|[0-9]{3}','g')).join();
};

//]]>
</script>
    </head>
    <body>

        <select id='sel_01_Id'></select>
        <select id='sel_02_Id'></select>
        <div id='dispId'></div>

    </body>
</html>


----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
[ Regular Expression ]
----------------------------------------------------------------------------------------------------

1. Username Regular Expression Pattern

package com.mkyong.regex;

import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class UsernameValidator{

      private Pattern pattern;
      private Matcher matcher;

      private static final String USERNAME_PATTERN = "^[a-z0-9_-]{3,15}$";

      public UsernameValidator(){
          pattern = Pattern.compile(USERNAME_PATTERN);
      }

      /**
       * Validate username with regular expression
       * @param username username for validation
       * @return true valid username, false invalid username
       */
      public boolean validate(final String username){

          matcher = pattern.matcher(username);
          return matcher.matches();

      }
}

package com.mkyong.regex;

import org.testng.Assert;
import org.testng.annotations.*;

/**
 * Username validator Testing
 * @author mkyong
 *
 */
public class UsernameValidatorTest {

    private UsernameValidator usernameValidator;

    @BeforeClass
        public void initData(){
        usernameValidator = new UsernameValidator();
        }

    @DataProvider
    public Object[][] ValidUsernameProvider() {
        return new Object[][]{
           {new String[] {
                 "mkyong34", "mkyong_2002","mkyong-2002" ,"mk3-4_yong"
           }}
                };
    }

    @DataProvider
    public Object[][] InvalidUsernameProvider() {
        return new Object[][]{
           {new String[] {
             "mk","mk@yong","mkyong123456789_-"
           }}
            };
    }

    @Test(dataProvider = "ValidUsernameProvider")
    public void ValidUsernameTest(String[] Username) {

       for(String temp : Username){
        boolean valid = usernameValidator.validate(temp);
        System.out.println("Username is valid : " + temp + " , " + valid);
        Assert.assertEquals(true, valid);
       }

    }

    @Test(dataProvider = "InvalidUsernameProvider",
                 dependsOnMethods="ValidUsernameTest")
    public void InValidUsernameTest(String[] Username) {

       for(String temp : Username){
        boolean valid = usernameValidator.validate(temp);
        System.out.println("username is valid : " + temp + " , " + valid);
        Assert.assertEquals(false, valid);
       }

    }
}




----------------------------------------------------------------------------------------------------

2. Password Regular Expression Pattern

(           # Start of group
  (?=.*\d)      #   must contains one digit from 0-9
  (?=.*[a-z])       #   must contains one lowercase characters
  (?=.*[A-Z])       #   must contains one uppercase characters
  (?=.*[@#$%])      #   must contains one special symbols in the list "@#$%"
              .     #     match anything with previous condition checking
                {6,20}  #        length at least 6 characters and maximum of 20
)           # End of group


package com.mkyong.regex;

import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class PasswordValidator{

      private Pattern pattern;
      private Matcher matcher;

      private static final String PASSWORD_PATTERN =
              "((?=.*\\d)(?=.*[a-z])(?=.*[A-Z])(?=.*[@#$%]).{6,20})";

      public PasswordValidator(){
          pattern = Pattern.compile(PASSWORD_PATTERN);
      }

      /**
       * Validate password with regular expression
       * @param password password for validation
       * @return true valid password, false invalid password
       */
      public boolean validate(final String password){

          matcher = pattern.matcher(password);
          return matcher.matches();

      }
}

package com.mkyong.regex;

import org.testng.Assert;
import org.testng.annotations.*;

/**
 * Password validator Testing
 * @author mkyong
 *
 */
public class PasswordValidatorTest {

    private PasswordValidator passwordValidator;

    @BeforeClass
        public void initData(){
        passwordValidator = new PasswordValidator();
        }

    @DataProvider
    public Object[][] ValidPasswordProvider() {
        return new Object[][]{
           {new String[] {
               "mkyong1A@", "mkYOn12$",
           }}
            };
    }

    @DataProvider
    public Object[][] InvalidPasswordProvider() {
        return new Object[][]{
           {new String[] {
               "mY1A@","mkyong12@","mkyoNg12*",
                            "mkyonG$$","MKYONG12$"
           }}
           };
    }

    @Test(dataProvider = "ValidPasswordProvider")
    public void ValidPasswordTest(String[] password) {

       for(String temp : password){
        boolean valid = passwordValidator.validate(temp);
        System.out.println("Password is valid : " + temp + " , " + valid);
        Assert.assertEquals(true, valid);
       }

    }

    @Test(dataProvider = "InvalidPasswordProvider",
                 dependsOnMethods="ValidPasswordTest")
    public void InValidPasswordTest(String[] password) {

       for(String temp : password){
        boolean valid = passwordValidator.validate(temp);
        System.out.println("Password is valid : " + temp + " , " + valid);
        Assert.assertEquals(false, valid);
       }
    }
}



----------------------------------------------------------------------------------------------------

3. Hexadecimal Color Code Regular Expression Pattern

^        #start of the line
 #       #  must constains a "#" symbols
 (       #  start of group #1
  [A-Fa-f0-9]{6} #    any strings in the list, with length of 6
  |      #    ..or
  [A-Fa-f0-9]{3} #    any strings in the list, with length of 3
 )       #  end of group #1
$        #end of the line

package com.mkyong.regex;

import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class HexValidator{

   private Pattern pattern;
   private Matcher matcher;

   private static final String HEX_PATTERN = "^#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$";

   public HexValidator(){
      pattern = Pattern.compile(HEX_PATTERN);
   }

   /**
   * Validate hex with regular expression
   * @param hex hex for validation
   * @return true valid hex, false invalid hex
   */
   public boolean validate(final String hex){

      matcher = pattern.matcher(hex);
      return matcher.matches();

   }
}

package com.mkyong.regex;

import org.testng.Assert;
import org.testng.annotations.*;

/**
 * Hex validator Testing
 * @author mkyong
 *
 */
public class HexValidatorTest {

    private HexValidator hexValidator;

    @BeforeClass
        public void initData(){
        hexValidator = new HexValidator();
        }

    @DataProvider
    public Object[][] ValidHexProvider() {
        return new Object[][]{
               {new String[] {
                "#1f1f1F", "#AFAFAF","#1AFFa1","#222fff", "#F00"
               }}
        };
    }

    @DataProvider
    public Object[][] InvalidHexProvider() {
        return new Object[][]{
            {new String[] {
                   "123456","#afafah","#123abce","aFaE3f",
                   "F00","#afaf", "#F0h"
                }}
        };
    }

    @Test(dataProvider = "ValidHexProvider")
    public void ValidHexTest(String[] hex) {

       for(String temp : hex){
           boolean valid = hexValidator.validate(temp);
           System.out.println("Hex is valid : " + temp + " , " + valid);
           Assert.assertEquals(true, valid);
       }

    }

    @Test(dataProvider = "InvalidHexProvider", dependsOnMethods="ValidHexTest")
    public void InValidHexTest(String[] hex) {

       for(String temp : hex){
           boolean valid = hexValidator.validate(temp);
           System.out.println("Hex is valid : " + temp + " , " + valid);
           Assert.assertEquals(false, valid);
       }

    }
}


----------------------------------------------------------------------------------------------------

4. Email Regular Expression Pattern

^           #start of the line
  [_A-Za-z0-9-\\+]+ #  must start with string in the bracket [ ], must contains one or more (+)
  (         #   start of group #1
    \\.[_A-Za-z0-9-]+   #     follow by a dot "." and string in the bracket [ ], must contains one or more (+)
  )*            #   end of group #1, this group is optional (*)
    @           #     must contains a "@" symbol
     [A-Za-z0-9-]+      #       follow by string in the bracket [ ], must contains one or more (+)
      (         #         start of group #2 - first level TLD checking
       \\.[A-Za-z0-9]+  #           follow by a dot "." and string in the bracket [ ], must contains one or more (+)
      )*        #         end of group #2, this group is optional (*)
      (         #         start of group #3 - second level TLD checking
       \\.[A-Za-z]{2,}  #           follow by a dot "." and string in the bracket [ ], with minimum length of 2
      )         #         end of group #3
$           #end of the line

package com.mkyong.regex;

import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class EmailValidator {

    private Pattern pattern;
    private Matcher matcher;

    private static final String EMAIL_PATTERN =
        "^[_A-Za-z0-9-\\+]+(\\.[_A-Za-z0-9-]+)*@"
        + "[A-Za-z0-9-]+(\\.[A-Za-z0-9]+)*(\\.[A-Za-z]{2,})$";

    public EmailValidator() {
        pattern = Pattern.compile(EMAIL_PATTERN);
    }

    /**
     * Validate hex with regular expression
     *
     * @param hex
     *            hex for validation
     * @return true valid hex, false invalid hex
     */
    public boolean validate(final String hex) {

        matcher = pattern.matcher(hex);
        return matcher.matches();

    }
}

package com.mkyong.regex;

import org.testng.Assert;
import org.testng.annotations.*;

/**
 * Email validator Testing
 *
 * @author mkyong
 *
 */
public class EmailValidatorTest {

    private EmailValidator emailValidator;

    @BeforeClass
    public void initData() {
        emailValidator = new EmailValidator();
    }

    @DataProvider
    public Object[][] ValidEmailProvider() {
        return new Object[][] { { new String[] { "mkyong@yahoo.com",
            "mkyong-100@yahoo.com", "mkyong.100@yahoo.com",
            "mkyong111@mkyong.com", "mkyong-100@mkyong.net",
            "mkyong.100@mkyong.com.au", "mkyong@1.com",
            "mkyong@gmail.com.com", "mkyong+100@gmail.com",
            "mkyong-100@yahoo-test.com" } } };
    }

    @DataProvider
    public Object[][] InvalidEmailProvider() {
        return new Object[][] { { new String[] { "mkyong", "mkyong@.com.my",
            "mkyong123@gmail.a", "mkyong123@.com", "mkyong123@.com.com",
            ".mkyong@mkyong.com", "mkyong()*@gmail.com", "mkyong@%*.com",
            "mkyong..2002@gmail.com", "mkyong.@gmail.com",
            "mkyong@mkyong@gmail.com", "mkyong@gmail.com.1a" } } };
    }

    @Test(dataProvider = "ValidEmailProvider")
    public void ValidEmailTest(String[] Email) {

        for (String temp : Email) {
            boolean valid = emailValidator.validate(temp);
            System.out.println("Email is valid : " + temp + " , " + valid);
            Assert.assertEquals(valid, true);
        }

    }

    @Test(dataProvider = "InvalidEmailProvider", dependsOnMethods = "ValidEmailTest")
    public void InValidEmailTest(String[] Email) {

        for (String temp : Email) {
            boolean valid = emailValidator.validate(temp);
            System.out.println("Email is valid : " + temp + " , " + valid);
            Assert.assertEquals(valid, false);
        }
    }
}





----------------------------------------------------------------------------------------------------

5. Image File Extension Regular Expression Pattern

(           #Start of the group #1
 [^\s]+         #  must contains one or more anything (except white space)
       (        #    start of the group #2
         \.     #   follow by a dot "."
         (?i)       #   ignore the case sensive checking for the following characters
             (      #     start of the group #3
              jpg   #       contains characters "jpg"
              |     #       ..or
              png   #       contains characters "png"
              |     #       ..or
              gif   #       contains characters "gif"
              |     #       ..or
              bmp   #       contains characters "bmp"
             )      #     end of the group #3
       )        #     end of the group #2
  $         #  end of the string
)           #end of the group #1

package com.mkyong.regex;

import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class ImageValidator{

   private Pattern pattern;
   private Matcher matcher;

   private static final String IMAGE_PATTERN =
                "([^\\s]+(\\.(?i)(jpg|png|gif|bmp))$)";

   public ImageValidator(){
      pattern = Pattern.compile(IMAGE_PATTERN);
   }

   /**
   * Validate image with regular expression
   * @param image image for validation
   * @return true valid image, false invalid image
   */
   public boolean validate(final String image){

      matcher = pattern.matcher(image);
      return matcher.matches();

   }
}

package com.mkyong.regex;

import org.testng.Assert;
import org.testng.annotations.*;

/**
 * Image validator Testing
 * @author mkyong
 *
 */
public class ImageValidatorTest {

    private ImageValidator imageValidator;

    @BeforeClass
        public void initData(){
        imageValidator = new ImageValidator();
        }

    @DataProvider
    public Object[][] ValidImageProvider() {
       return new Object[][]{
             {new String[] {
           "a.jpg", "a.gif","a.png", "a.bmp",
           "..jpg", "..gif","..png", "..bmp",
           "a.JPG", "a.GIF","a.PNG", "a.BMP",
           "a.JpG", "a.GiF","a.PnG", "a.BmP",
           "jpg.jpg", "gif.gif","png.png", "bmp.bmp"
           }
              }
       };
    }

    @DataProvider
    public Object[][] InvalidImageProvider() {
      return new Object[][]{
        {new String[] {
           ".jpg", ".gif",".png",".bmp",
           " .jpg", " .gif"," .png"," .bmp",
                   "a.txt", "a.exe","a.","a.mp3",
           "jpg", "gif","png","bmp"
           }
             }
       };
    }

    @Test(dataProvider = "ValidImageProvider")
     public void ValidImageTest(String[] Image) {

       for(String temp : Image){
           boolean valid = imageValidator.validate(temp);
           System.out.println("Image is valid : " + temp + " , " + valid);
           Assert.assertEquals(true, valid);
       }

    }

    @Test(dataProvider = "InvalidImageProvider",
                 dependsOnMethods="ValidImageTest")
    public void InValidImageTest(String[] Image) {

       for(String temp : Image){
           boolean valid = imageValidator.validate(temp);
           System.out.println("Image is valid : " + temp + " , " + valid);
           Assert.assertEquals(false, valid);
       }
    }
}



----------------------------------------------------------------------------------------------------

6. IP Address Regular Expression Pattern

^       #start of the line
 (      #  start of group #1
   [01]?\\d\\d? #    Can be one or two digits. If three digits appear, it must start either 0 or 1
        #    e.g ([0-9], [0-9][0-9],[0-1][0-9][0-9])
    |       #    ...or
   2[0-4]\\d    #    start with 2, follow by 0-4 and end with any digit (2[0-4][0-9])
    |           #    ...or
   25[0-5]      #    start with 2, follow by 5 and ends with 0-5 (25[0-5])
 )      #  end of group #2
  \.            #  follow by a dot "."
....            # repeat with 3 times (3x)
$       #end of the line

package com.mkyong.regex;

import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class IPAddressValidator{

    private Pattern pattern;
    private Matcher matcher;

    private static final String IPADDRESS_PATTERN =
        "^([01]?\\d\\d?|2[0-4]\\d|25[0-5])\\." +
        "([01]?\\d\\d?|2[0-4]\\d|25[0-5])\\." +
        "([01]?\\d\\d?|2[0-4]\\d|25[0-5])\\." +
        "([01]?\\d\\d?|2[0-4]\\d|25[0-5])$";

    public IPAddressValidator(){
      pattern = Pattern.compile(IPADDRESS_PATTERN);
    }

   /**
    * Validate ip address with regular expression
    * @param ip ip address for validation
    * @return true valid ip address, false invalid ip address
    */
    public boolean validate(final String ip){
      matcher = pattern.matcher(ip);
      return matcher.matches();
    }
}

package com.mkyong.regex;

import org.testng.Assert;
import org.testng.annotations.*;

/**
 * IPAddress validator Testing
 * @author mkyong
 *
 */
public class IPAddressValidatorTest {

    private IPAddressValidator ipAddressValidator;

    @BeforeClass
        public void initData(){
        ipAddressValidator = new IPAddressValidator();
        }

    @DataProvider
    public Object[][] ValidIPAddressProvider() {
        return new Object[][]{
           new Object[] {"1.1.1.1"},new Object[] {"255.255.255.255"},
                   new Object[] {"192.168.1.1"},new Object[] {"10.10.1.1"},
                   new Object[] {"132.254.111.10"},new Object[] {"26.10.2.10"},
           new Object[] {"127.0.0.1"}
        };
    }

    @DataProvider
    public Object[][] InvalidIPAddressProvider() {
        return new Object[][]{
           new Object[] {"10.10.10"},new Object[] {"10.10"},
                   new Object[] {"10"},new Object[] {"a.a.a.a"},
                   new Object[] {"10.0.0.a"},new Object[] {"10.10.10.256"},
           new Object[] {"222.222.2.999"},new Object[] {"999.10.10.20"},
                   new Object[] {"2222.22.22.22"},new Object[] {"22.2222.22.2"},
                   new Object[] {"10.10.10"},new Object[] {"10.10.10"},
        };
    }

    @Test(dataProvider = "ValidIPAddressProvider")
    public void ValidIPAddressTest(String ip) {
           boolean valid = ipAddressValidator.validate(ip);
           System.out.println("IPAddress is valid : " + ip + " , " + valid);
           Assert.assertEquals(true, valid);
    }

    @Test(dataProvider = "InvalidIPAddressProvider",
                 dependsOnMethods="ValidIPAddressTest")
    public void InValidIPAddressTest(String ip) {
           boolean valid = ipAddressValidator.validate(ip);
           System.out.println("IPAddress is valid : " + ip + " , " + valid);
           Assert.assertEquals(false, valid);
    }
}



----------------------------------------------------------------------------------------------------

7. Time Format Regular Expression Pattern

(               #start of group #1
 1[012]             #  start with 10, 11, 12
 |              #  or
 [1-9]              #  start with 1,2,...9
)               #end of group #1
 :              #    follow by a semi colon (:)
  [0-5][0-9]            #      follw by 0..5 and 0..9, which means 00 to 59
            (\\s)?      #        follow by a white space (optional)
                  (?i)      #          next checking is case insensitive
                      (am|pm)   #            follow by am or pm


package com.mkyong.regex;

import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class Time12HoursValidator{

      private Pattern pattern;
      private Matcher matcher;

      private static final String TIME12HOURS_PATTERN =
                                "(1[012]|[1-9]):[0-5][0-9](\\s)?(?i)(am|pm)";

      public Time12HoursValidator(){
          pattern = Pattern.compile(TIME12HOURS_PATTERN);
      }

      /**
       * Validate time in 12 hours format with regular expression
       * @param time time address for validation
       * @return true valid time fromat, false invalid time format
       */
      public boolean validate(final String time){
          matcher = pattern.matcher(time);
          return matcher.matches();
      }
}

package com.mkyong.regex;

import org.testng.Assert;
import org.testng.annotations.*;

/**
 * Time 12 hours format validator Testing
 * @author mkyong
 *
 */
public class Time12HoursValidatorTest {

    private Time12HoursValidator time12HoursValidator;

    @BeforeClass
        public void initData(){
        time12HoursValidator = new Time12HoursValidator();
        }

    @DataProvider
    public Object[][] ValidTime12HoursProvider() {
        return new Object[][]{
             new Object[] {"1:00am"}, new Object[] {"1:00 am"},
                     new Object[] {"1:00 AM"}, new Object[] {"1:00pm"},
                     new Object[] {"1:00 pm"},new Object[] {"1:00 PM"},
             new Object[] {"12:50 pm"}
        };
    }

    @DataProvider
    public Object[][] InvalidTime12HoursProvider() {
        return new Object[][]{
             new Object[] {"0:00 am"},new Object[] {"10:00  am"},
             new Object[] {"1:00"},new Object[] {"23:00 am"},
             new Object[] {"1:61 pm"},new Object[] {"13:00 pm"},
             new Object[] {"001:50 pm"},new Object[] {"10:99 am"},
             new Object[] {"01:00 pm"}, new Object[] {"1:00 bm"}
        };
    }

    @Test(dataProvider = "ValidTime12HoursProvider")
    public void ValidTime12HoursTest(String time) {
       boolean valid = time12HoursValidator.validate(time);
       System.out.println("Time12Hours is valid : " + time + " , " + valid);
       Assert.assertEquals(true, valid);
    }

    @Test(dataProvider = "InvalidTime12HoursProvider",
                 dependsOnMethods="ValidTime12HoursTest")
    public void InValidTime12HoursTest(String time) {
       boolean valid = time12HoursValidator.validate(time);
       System.out.println("Time12Hours is valid : " + time + " , " + valid);
       Assert.assertEquals(false, valid);
    }
}



----------------------------------------------------------------------------------------------------

8. Date Format(dd/mm/yyyy) Regular Expression Pattern

(           #start of group #1
 0?[1-9]        #  01-09 or 1-9
 |                      #  ..or
 [12][0-9]      #  10-19 or 20-29
 |          #  ..or
 3[01]          #  30, 31
)           #end of group #1
  /         #  follow by a "/"
   (            #    start of group #2
    0?[1-9]     #   01-09 or 1-9
    |           #   ..or
    1[012]      #   10,11,12
    )           #    end of group #2
     /          #   follow by a "/"
      (         #     start of group #3
       (19|20)\\d\\d    #       19[0-9][0-9] or 20[0-9][0-9]
       )        #     end of group #3

package com.mkyong.regex;

import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class DateValidator{

  private Pattern pattern;
  private Matcher matcher;

  private static final String DATE_PATTERN =
          "(0?[1-9]|[12][0-9]|3[01])/(0?[1-9]|1[012])/((19|20)\\d\\d)";

  public DateValidator(){
      pattern = Pattern.compile(DATE_PATTERN);
  }

  /**
   * Validate date format with regular expression
   * @param date date address for validation
   * @return true valid date fromat, false invalid date format
   */
   public boolean validate(final String date){

     matcher = pattern.matcher(date);

     if(matcher.matches()){

     matcher.reset();

     if(matcher.find()){

             String day = matcher.group(1);
         String month = matcher.group(2);
         int year = Integer.parseInt(matcher.group(3));

         if (day.equals("31") &&
          (month.equals("4") || month .equals("6") || month.equals("9") ||
                  month.equals("11") || month.equals("04") || month .equals("06") ||
                  month.equals("09"))) {
            return false; // only 1,3,5,7,8,10,12 has 31 days
         } else if (month.equals("2") || month.equals("02")) {
                  //leap year
          if(year % 4==0){
              if(day.equals("30") || day.equals("31")){
                  return false;
              }else{
                  return true;
              }
          }else{
                 if(day.equals("29")||day.equals("30")||day.equals("31")){
                  return false;
                 }else{
                  return true;
              }
          }
          }else{
        return true;
          }
       }else{
              return false;
       }
     }else{
      return false;
     }
   }
}

package com.mkyong.regex;

import org.testng.Assert;
import org.testng.annotations.*;

/**
 * Date format dd/mm/yyyy validator Testing
 * @author mkyong
 *
 */
public class DateValidatorTest {

    private DateValidator dateValidator;

    @BeforeClass
        public void initData(){
        dateValidator = new DateValidator();
        }

    @DataProvider
    public Object[][] ValidDateProvider() {
        return new Object[][]{
            new Object[] {"1/1/2010"}, new Object[] {"01/01/2020"},
            new Object[] {"31/1/2010"}, new Object[] {"31/01/2020"},
            new Object[] {"29/2/2008"}, new Object[] {"29/02/2008"},
            new Object[] {"28/2/2009"}, new Object[] {"28/02/2009"},
            new Object[] {"31/3/2010"}, new Object[] {"31/03/2010"},
            new Object[] {"30/4/2010"}, new Object[] {"30/04/2010"},
            new Object[] {"31/5/2010"}, new Object[] {"31/05/2010"},
            new Object[] {"30/6/2010"}, new Object[] {"30/06/2010"},
            new Object[] {"31/7/2010"}, new Object[] {"31/07/2010"},
            new Object[] {"31/8/2010"}, new Object[] {"31/08/2010"},
            new Object[] {"30/9/2010"}, new Object[] {"30/09/2010"},
            new Object[] {"31/10/2010"}, new Object[] {"31/10/2010"},
            new Object[] {"30/11/2010"}, new Object[] {"30/11/2010"},
            new Object[] {"31/12/2010"}, new Object[] {"31/12/2010"}
        };
    }

    @DataProvider
    public Object[][] InvalidDateProvider() {
        return new Object[][]{
            new Object[] {"32/1/2010"}, new Object[] {"32/01/2020"},
            new Object[] {"1/13/2010"}, new Object[] {"01/01/1820"},
            new Object[] {"29/2/2007"}, new Object[] {"29/02/2007"},
            new Object[] {"30/2/2008"}, new Object[] {"31/02/2008"},
            new Object[] {"29/a/2008"}, new Object[] {"a/02/2008"},
            new Object[] {"333/2/2008"}, new Object[] {"29/02/200a"},
            new Object[] {"31/4/2010"}, new Object[] {"31/04/2010"},
            new Object[] {"31/6/2010"}, new Object[] {"31/06/2010"},
            new Object[] {"31/9/2010"}, new Object[] {"31/09/2010"},
            new Object[] {"31/11/2010"}
        };
    }

    @Test(dataProvider = "ValidDateProvider")
    public void ValidDateTest(String date) {
        boolean valid = dateValidator.validate(date);
        System.out.println("Date is valid : " + date + " , " + valid);
        Assert.assertEquals(true, valid);
    }

    @Test(dataProvider = "InvalidDateProvider",
                 dependsOnMethods="ValidDateTest")
    public void InValidDateTest(String date) {
        boolean valid = dateValidator.validate(date);
        System.out.println("Date is valid : " + date + " , " + valid);
        Assert.assertEquals(false, valid);
    }
}


----------------------------------------------------------------------------------------------------

9. HTML tag Regular Expression Pattern

<       #start with opening tag "<"
 (      #   start of group #1
   "[^"]*"  #   allow string with double quotes enclosed - "string"
   |        #   ..or
   '[^']*'  #   allow string with single quote enclosed - 'string'
   |        #   ..or
   [^'">]   #   cant contains one single quotes, double quotes and ">"
 )      #   end of group #1
 *      # 0 or more
>       #end with closing tag ">"


package com.mkyong.regex;

import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class HTMLTagValidator{

   private Pattern pattern;
   private Matcher matcher;

   private static final String HTML_TAG_PATTERN = "<(\"[^\"]*\"|'[^']*'|[^'\">])*>";

   public HTMLTagValidator(){
      pattern = Pattern.compile(HTML_TAG_PATTERN);
   }

  /**
   * Validate html tag with regular expression
   * @param tag html tag for validation
   * @return true valid html tag, false invalid html tag
   */
  public boolean validate(final String tag){

      matcher = pattern.matcher(tag);
      return matcher.matches();

  }
}

package com.mkyong.regex;

import org.testng.Assert;
import org.testng.annotations.*;

/**
 * HTMLTag validator Testing
 * @author mkyong
 *
 */
public class HTMLTagValidatorTest {

    private HTMLTagValidator htmlTagValidator;

    @BeforeClass
        public void initData(){
        htmlTagValidator = new HTMLTagValidator();
        }

    @DataProvider
    public Object[][] ValidHTMLTagProvider() {
           return new Object[][]{
           new Object[] {"<b>"},
                   new Object[] {"<input value='>'>"},
           new Object[] {"<input value='<'>"},
           new Object[] {"<b/>"},
                   new Object[] {"<a href='http://www.google.com'>"},
           new Object[] {"<br>"},
                   new Object[] {"<br/>"},
           new Object[] {"<input value=\"\" id='test'>"},
                   new Object[] {"<input value='' id='test'>"}
       };
    }

    @DataProvider
    public Object[][] InvalidHTMLTagProvider() {
        return new Object[][]{
          new Object[] {"<input value=\" id='test'>"},
          new Object[] {"<input value=' id='test'>"},
          new Object[] {"<input value=> >"}
        };
    }

    @Test(dataProvider = "ValidHTMLTagProvider")
    public void ValidHTMLTagTest(String tag) {

        boolean valid = htmlTagValidator.validate(tag);
        System.out.println("HTMLTag is valid : " + tag + " , " + valid);
        Assert.assertEquals(true, valid);

    }

    @Test(dataProvider = "InvalidHTMLTagProvider",
                 dependsOnMethods="ValidHTMLTagTest")
    public void InValidHTMLTagTest(String tag) {

       boolean valid = htmlTagValidator.validate(tag);
       System.out.println("HTMLTag is valid : " + tag + " , " + valid);
       Assert.assertEquals(false, valid);

    }
}



----------------------------------------------------------------------------------------------------

10. HTML links Regular Expression Pattern

(       #start of group #1
 ?i     #  all checking are case insensive
)       #end of group #1
<a              #start with "<a"
  (     #  start of group #2
    [^>]+   #     anything except (">"), at least one character
   )        #  end of group #2
  >     #     follow by ">"
    (.+?)   #   match anything
         </a>   #     end with "</a>

\s*            #can start with whitespace
  (?i)             # all checking are case insensive
     href          #  follow by "href" word
        \s*=\s*        #   allows spaces on either side of the equal sign,
              (        #    start of group #1
               "([^"]*")   #      allow string with double quotes enclosed - "string"
               |       #      ..or
               '[^']*'     #        allow string with single quotes enclosed - 'string'
               |           #      ..or
               ([^'">]+)   #      can't contains one single quotes, double quotes ">"
          )        #    end of group #1

package com.mkyong.crawler.core;

import java.util.Vector;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class HTMLLinkExtractor {

    private Pattern patternTag, patternLink;
    private Matcher matcherTag, matcherLink;

    private static final String HTML_A_TAG_PATTERN = "(?i)<a([^>]+)>(.+?)</a>";
    private static final String HTML_A_HREF_TAG_PATTERN =
        "\\s*(?i)href\\s*=\\s*(\"([^\"]*\")|'[^']*'|([^'\">\\s]+))";


    public HTMLLinkExtractor() {
        patternTag = Pattern.compile(HTML_A_TAG_PATTERN);
        patternLink = Pattern.compile(HTML_A_HREF_TAG_PATTERN);
    }

    /**
     * Validate html with regular expression
     *
     * @param html
     *            html content for validation
     * @return Vector links and link text
     */
    public Vector<HtmlLink> grabHTMLLinks(final String html) {

        Vector<HtmlLink> result = new Vector<HtmlLink>();

        matcherTag = patternTag.matcher(html);

        while (matcherTag.find()) {

            String href = matcherTag.group(1); // href
            String linkText = matcherTag.group(2); // link text

            matcherLink = patternLink.matcher(href);

            while (matcherLink.find()) {

                String link = matcherLink.group(1); // link
                HtmlLink obj = new HtmlLink();
                obj.setLink(link);
                obj.setLinkText(linkText);

                result.add(obj);

            }

        }

        return result;

    }

    class HtmlLink {

        String link;
        String linkText;

        HtmlLink(){};

        @Override
        public String toString() {
            return new StringBuffer("Link : ").append(this.link)
            .append(" Link Text : ").append(this.linkText).toString();
        }

        public String getLink() {
            return link;
        }

        public void setLink(String link) {
            this.link = replaceInvalidChar(link);
        }

        public String getLinkText() {
            return linkText;
        }

        public void setLinkText(String linkText) {
            this.linkText = linkText;
        }

        private String replaceInvalidChar(String link){
            link = link.replaceAll("'", "");
            link = link.replaceAll("\"", "");
            return link;
        }

    }
}

package com.mkyong.crawler.core;

import java.util.Vector;

import org.testng.Assert;
import org.testng.annotations.BeforeClass;
import org.testng.annotations.DataProvider;
import org.testng.annotations.Test;

import com.mkyong.crawler.core.HTMLLinkExtractor.HtmlLink;

/**
 * HTML link extrator Testing
 *
 * @author mkyong
 *
 */
public class TestHTMLLinkExtractor {

    private HTMLLinkExtractor htmlLinkExtractor;
    String TEST_LINK = "http://www.google.com";

    @BeforeClass
    public void initData() {
        htmlLinkExtractor = new HTMLLinkExtractor();
    }

    @DataProvider
    public Object[][] HTMLContentProvider() {
      return new Object[][] {
        new Object[] { "abc hahaha <a href='" + TEST_LINK + "'>google</a>" },
        new Object[] { "abc hahaha <a HREF='" + TEST_LINK + "'>google</a>" },

        new Object[] { "abc hahaha <A HREF='" + TEST_LINK + "'>google</A> , "
        + "abc hahaha <A HREF='" + TEST_LINK + "' target='_blank'>google</A>" },

        new Object[] { "abc hahaha <A HREF='" + TEST_LINK + "' target='_blank'>google</A>" },
        new Object[] { "abc hahaha <A target='_blank' HREF='" + TEST_LINK + "'>google</A>" },
        new Object[] { "abc hahaha <A target='_blank' HREF=\"" + TEST_LINK + "\">google</A>" },
        new Object[] { "abc hahaha <a HREF=" + TEST_LINK + ">google</a>" }, };
    }

    @Test(dataProvider = "HTMLContentProvider")
    public void ValidHTMLLinkTest(String html) {

        Vector<HtmlLink> links = htmlLinkExtractor.grabHTMLLinks(html);

        //there must have something
        Assert.assertTrue(links.size() != 0);

        for (int i = 0; i < links.size(); i++) {
            HtmlLink htmlLinks = links.get(i);
            //System.out.println(htmlLinks);
            Assert.assertEquals(htmlLinks.getLink(), TEST_LINK);
        }

    }
}



----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------

    private static void test04(String[] args) throws Exception {

        Map<String,String> mapWord = new HashMap<String,String>();
        String ptn = "%([a-zA-Z0-9]{3,})%";
        String str = "정규표현%HELLO%식은 검색해 보%TIME%시면 아시%ID%겠지만 문자%ID01%열에서 특정 패턴을 이용해...";
        StringBuffer sb = new StringBuffer();

        if (flag) {
            mapWord.put("%HELLO%  ".trim(), "안녕하세요.");
            mapWord.put("%TIME%   ".trim(), "시간은");
            mapWord.put("%ID01%   ".trim(), "C123456ABC34D45E");
        }

        if (flag) {

            Pattern pattern = Pattern.compile(ptn);
            Matcher matcher = pattern.matcher(str);

            while (matcher.find()) {
                String key = matcher.group();
                String grp1 = matcher.group(1);
                String value = mapWord.get(key);
                if (value == null)
                    value = "";

                matcher.appendReplacement(sb, "[" + grp1 + "->" + value + "]");
            }

            System.out.println("> " + sb.toString());
        }
    }


----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
[ oracle CLOB 자료 ]

JDBC에서 Connection 처리 후  CLOB 쓸 때

    String sql = "insert into TABLE values (?,?,?)";
    PreparedStatement pstmt = connection.prepareStatement(sql);

    pstmt.setInt(1, 1234);
    pstmt.setCharacterStream(2, new StringReader(some_string, some_string.length());
    pstmt.setString(3, "Hello");
    pstmt.execute();

읽을 때

    public static String readClobData(Reader reader) throws IOException {
        StringBuffer sb = new StringBuffer();
        char[] buf = new char[1024];
        int cnt = 0;
        if (reader != null) {
            while ((cnt = reader.read(buf)) != -1) {
                sb.append(buf, 0, cnt);
            }
        }
        return sb.toString();
    }

    ResultSet rs = #####
    String clobString = readClobData(rs.getCharacterStream("clob_column"));

----------------------------------------------------------------------------------------------------

    sr0 = new java.io.StringReader(dataBean.getContent());
    pstmt.setCharacterStream(1, sr0, dataBean.getContent().length());

----------------------------------------------------------------------------------------------------
[ iBatis + CLOB ]

일단 clob을 집어넣고 뺄때 ibatis에 알려줘야했었던거다 ㅡㅡ;
셀렉트문... 먼저 resultMap을 셀렉트 하기전에 선언해줘야한다;; 왜냐면 XML은 순차적으로 해석하기때문에... 먼저 해줘야 나중에있는놈이 쓸수있는거다.
그리고 CONTENT를 보면 알겠지만 jdbcType와 javaType를 정의해주었다..

XML의 내용이다..

<resultMap id="viewIncClob" class="hmap">
  <result property="BBS_ORDER" column="BBS_ORDER"/>
  <result property="TITLE" column="TITLE"/>
  <result property="FIRSTREGDATE" column="FIRSTREGDATE"/>
  <result property="WRITER" column="WRITER"/>
  <result property="CONTENT" column="CONTENT" jdbcType="CLOB" javaType="java.lang.String"/>
 </resultMap>

셀렉트문에서는 만들어놓은 resultMap을 사용해준다.
 <select id="viewNotice" parameterClass="hmap" resultMap="viewIncClob">
  <![CDATA[
   SELECT BBS_ORDER, TITLE, TO_CHAR(FIRSTREGDATE,'YYYY-MM-DD') AS FIRSTREGDATE, WRITER,
          CONTENT
     FROM DPSCMM005
    WHERE BBS_ORDER = #bbs_order#
  ]]>
 </select>

인서트문이다.업데이트문도 동일하겠지?
파라미터 맵을 만들어준다.  지금 하는 프로젝트는 해쉬맵으로 넘겨주니까 클래스는 지정해놓은 해쉬맵으로 받고...
CLOB 파라미터는 jdbcType를 CLOB 으로 지정해준다..

 <parameterMap id="insertIncClob" class="hmap">
  <parameter property="title"/>
  <parameter property="writer"/>
  <parameter property="content" jdbcType="CLOB"/>
  <parameter property="bbskubun"/>
 </parameterMap>

그리고 인서트문에서도 해줘야 하는데 위에처럼 파라미터 맵을 만들어서 해도 되고. CLOB 필드만 CLOB으로 선언해서 넣을수가있다..
별다른 이유가 없다면 그냥 바로 CLOB으로 집어넣는게 편하겠지..

 <insert id="InsNotice" parameterClass="hmap">
  <![CDATA[
    INSERT INTO DPSCMM005 (
    BBS_ORDER,
    TITLE,
    WRITER,
    CONTENT,
    BBSKUBUN,
    FIRSTREGDATE,
    FINALCHNGDATE,
    FINALCHNGADDR,
    DATASTTCD
   ) VALUES (
        (SELECT NVL(MAX(BBS_ORDER),0)+1 FROM DPSCMM005),
        #title#,
        #writer#,
        #content:CLOB#,                              <------------- 넘어온 파라미터값 뒤에 :CLOB를 붙여주면 CLOB으로 들어간다~!
        #bbskubun#,
        SYSDATE,
        TO_DATE(#wdate#, 'YYYY-MM-DD'),
        #clientIP#,
        '0')
  ]]>
 </insert>

ibatis를 쓰지 않는다면 dbms_lob를 써서 불러와야한다. 물론 ibatis를 쓴다면 그냥 CONTENT만 불러오면 된다 ^^
select dbms_lob.substr(content, dbms_lob.getlength(content), 1) as CONTENT from dpscmm005 where bbs_order = '56'---비교적 간단한듯...

----------------------------------------------------------------------------------------------------

ibatis에서 Oracle의 CLOB을 쓰기위해서는 아래와 같은 별도 resultMap 생성이 필요의 처리가 필요하다

<resultMap id="brdView" class="java.util.HashMap">
        <result property="seq" column="seq"/>
        <result property="title" column="title"/>
        <result property="contents" column="contents" jdbcType="CLOB" javaType="java.lang.String"/>
        <result property="url" column="url"/>
</resultMap>

<select id="test.dao.selectTable" parameterClass="Map" resultMap="brdView">
select
        seq, title, contents, url
from testTable
</select>

* select ibatis 의 resultMap 에 위에서 선언한 brdView 를 세팅한다
* CLOB column 부분 을 잘 세팅할것
* 혹시 검색 쿼리에 column 이 추가될 경우 brdView 에도 같은 명칭으로 추가

EX) addcolumn 란 컬럼이 추가된경우 아래와 같다
<resultMap id="brdView" class="java.util.HashMap">
        <result property="seq" column="seq"/>
        <result property="title" column="title"/>
        <result property="contents" column="contents" jdbcType="CLOB" javaType="java.lang.String"/>
        <result property="url" column="url"/>
        <result property="addcolumn" column="addcolumn"/>
</resultMap>

<select id="test.dao.selectTable" parameterClass="Map" resultMap="brdView">
select
        seq, title, contents, url, addcolumn
from testTable
</select>
[출처] ibatis Oracle clob 처리하기 (하늘 Java) |작성자 프라임

----------------------------------------------------------------------------------------------------
< Bean >
package netville.knowledge.business.model;

import java.io.Serializable;

public class Report implements Serializable {
    private static final long serialVersionUID = ####L;

    protected String id;
    protected String name;
    protected String description;
    protected byte[] data;

    public String getId() {
        return id;
    }

    public void setId(String id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getDescription() {
        return description;
    }

    public void setDescription(String description) {
        this.description = description;
    }

    public byte[] getData() {
        return data;
    }

    public void setData(byte[] data) {
        this.data = data;
    }
}

< Service >
public Report getReport(String id) {
    try {
        return attachmentDAO.getReport(id);
    } catch (Exception e) {
        logger.error(e);
        throw new KnowRuntimeException(e);
    }
}

< DAO >
public Report getReport(String id) {
    return (Report) getSqlMapClientTemplate().queryForObject("knowledge.attachment.getReport", id);
}

public void insertReport(Report report) {
    getSqlMapClientTemplate().insert("knowledge.attachment.insertReport", report);
}


< SQL-MAP >
    <typeAlias alias="report" type="netville.knowledge.business.model.Report" />
    <resultMap class="report" id="report-result">
        <result column="id" porperty="id"/>
        <result column="name" property="name"/>
        <result column="description" property="description"/>
        <result column="data" property="data" jdbcType="BLOB"/>
    </resultMap>
    <insert id="insertReport" parameterClass="report">
        INSERT INTO REPORT
        (
            ID,
            NAME,
            DESCRIPTION,
            DATA
        ) VALUES (
            #id#,
            #name#,
            #description#,
            #data#
        )
    </insert>
    <select id="getReport" parameterClass="string" resultMap="report-result">
        SELECT
            *
        FROM
            REPORT
        WHERE
            ID = #value#
    </select>

<UTIL>
    public static byte[] getBytesFromFile(File file) throws IOException {

        InputStream is = new FileInputStream(file);

        long length = file.length();
        if (length > Integer.MAX_VALUE) {
            return null;
        }

        byte[] bytes = new byte[(int) length];

        int offset = 0;
        int numRead = 0;
        while (offset < bytes.length && (numRead = is.read(bytes, offset, bytes.length - offset)) >= 0) {
            offset += numRead;
        }

        if (offset < bytes.length) {
            throw new IOException("Could not completely read file " + file.getName());
        }

        is.close();

        return bytes;
    }

----------------------------------------------------------------------------------------------------

    <resultMap class="java.util.HashMap" id="resultStone">
        <result column="CONTENT" property="CONTENT" jdbcType="CLOB" javaType="java.lang.String"/>
    </resultMap>
    <select id="getMap" resultMap="resultStone" parameterClass="map">
        SELECT CONTENT FROM TABLE
    </select>


    <!-- CLOB Data를 위한 정의 -->
    <resultMap class="hmap">
        <result column="CONTENT" property="CONTENT" typeHandler="clobHandler"/>
    </resultMap>
    <select id="getBoardDetail" parameterClass="map" resultMap="getClobBoardData">
        TITLE, CONTENT FROM TEX_BULLETIN
        <iterate prepend="IN" property="listId" open="(" close=")" conjunction=",">
            #listId[]#
        </iterate>
    </select>

----------------------------------------------------------------------------------------------------

        // insert 하는 코드 예제
        params = new HashMap<String, Object>();
        params.put("retryTable", retryQName);
        params.put("file_id", message.getMessageId());
        params.put("source_type", getMessageTypeName(message.getSourceType()));
        params.put("msg_file", defalte(encode(message.getValue())));
        sqlMap.insert("insertToRetryQTable", params);
        // SQL-Map
        <insert id="insertToRetryQTable" parameterClass="java.util.Map">
            INSERT INTO $retryTable$ (FILE_ID, SOURCE_TYPE, MSG_FILE) VALUES (#file_id#, #source_type#, #msg_file:BLOB# )
        </insert>

    위 예제코드는 Oracle이나 CUBRID에서는 동작하지 않는다. byte 배열을 BLOB으로 바인딩할 수 없기 때문이다.
    따라서 아래와 같이 TypeHandler에서 setParameter 메소드를 구현해야 한다.

        // ps는 PreparedStatement 객체
        @Override
        public void setParameter(PreparedStatement ps, int i, Object parameter, String jdbcType) throws Exception {
            byte[] bytes = (byte[]) parameter;
            if (bytes != null) {
                Blob blob = ps.getConnection().createBlob();
                blob.setBytes(1, bytes);
                ps.setBlob(i, blob);
            } else {
                ps.setBlob(i, (Blob) null);
            }
        }


----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
[ Linux 메모리 사용량 확인 ]

    top에서 리눅스 시스템의 메모리 사용량을 보면 항상 대부분의 메모리가 사용중이고, free 메모리는 얼마되지 않는다.

        <app01>

            matcmsapp01:/sas/sasuser/sas>top
            top - 09:24:24 up 155 days, 21:01, 12 users,  load average: 0.00, 0.03, 0.02
            Tasks: 453 total,   1 running, 452 sleeping,   0 stopped,   0 zombie
            Cpu(s):  0.2%us,  0.2%sy,  0.0%ni, 99.5%id,  0.0%wa,  0.0%hi,  0.0%si,  0.0%st
            Mem:  65982532k total, 49347344k used, 16635188k free,   987724k buffers
            Swap: 67108856k total,   132432k used, 66976424k free, 26697296k cached

              PID USER      PR  NI  VIRT  RES  SHR S %CPU %MEM    TIME+  COMMAND
            15177 sas       20   0 11.2g 1.7g  13m S  1.7  2.7 281:19.30 java
             3335 sas       20   0 9802m 1.2g  14m S  1.3  1.9 277:27.85 java
             .....

    전체 66G 메모리 중에 49.3G 정도 사용하고 있는 것으로 나온다.

        <app02>

            matcmsapp02:/sas/sasuser/sas>top
            top - 09:24:25 up 155 days, 21:00,  8 users,  load average: 2.97, 2.06, 1.86
            Tasks: 429 total,   1 running, 428 sleeping,   0 stopped,   0 zombie
            Cpu(s): 10.7%us,  0.2%sy,  0.0%ni, 89.1%id,  0.0%wa,  0.0%hi,  0.0%si,  0.0%st
            Mem:  65982532k total, 65484132k used,   498400k free,  1031444k buffers
            Swap: 67108856k total,    70456k used, 67038400k free, 42926300k cached

              PID USER      PR  NI  VIRT  RES  SHR S %CPU %MEM    TIME+  COMMAND
            30007 sas       20   0 3697m 479m  16m S 112.2  0.7  32380:55 java
            17486 sas       20   0 3697m 480m  16m S 54.4  0.7  15844:03 java
            19976 sas       20   0 13.9g 5.5g  26m S  1.7  8.7 505:48.91 java
            .....

    전체 66G 메모리 중에 65.4G 정도 사용하고 있는 것으로 나온다.

    메모리가 부족한 것인다.
    한마디로 그렇지 한다. 이는 리눅스의 OS cache 때문이다. 리눅스는 가용메모리 전체를 OS cache로 사용한다.
    평상시에는 Disk Block에 대한 cashe로 사용하고, 대신 언제든지 가용 메모리로 할당할 수 있도록 준비한다.
    OS cache를 포함하여 그리고 임시 버퍼등의 메모리 사이즈는 가용 메모리로 봐야한다.

        실제 가용 메모리 = mem_free + mem_cache + mem_buffer

    buffers, cache 영역까지 감안한 실제 메모리 사용량을 free명령어를 통해서 확인할 수 있다.

        <app01>
            matcmsapp01:/sas/sasuser/sas>free -m -s 10
                         total       used       free     shared    buffers     cached
            Mem:         64436      48193      16242          0        964      26071
            -/+ buffers/cache:      21156      43279
            Swap:        65535        129      65406

    현재 64.436G 메모리 중에 21.156G 실제 사용중이고, 43.279G가 언제든지 할당 가능한 가용 메모리다.

        <app02>
            matcmsapp02:/sas/sasuser/sas>free -m -s 10
                         total       used       free     shared    buffers     cached
            Mem:         64436      63949        486          0       1007      41920
            -/+ buffers/cache:      21021      43414
            Swap:        65535         68      65467


    현재 64.436G 메모리 중에 21.021G 실제 사용중이고, 43.414G가 언제든지 할당 가능한 가용 메모리다.

----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------

Git 브랜치 배우기 : http://git-scm.com/book/ko/v2

Git 간편 안내서   : http://rogerdudler.github.io/git-guide/index.ko.html

Git BOOK          : http://git-scm.com/book/ko/v2

Git 작업 흐름     : http://dalinaum-kr.tumblr.com/post/15516936704/git-work-flow

Git Tutorial      : http://www.dreamy.pe.kr/zbxe/CodeClip/95408

Eclipse + Git     : http://git-scm.com/ : [Try Git]   http://git-scm.com/doc      http://git-scm.com/docs

                    http://zzznara2.tistory.com/396    http://miffy7777.blog.me/220306795158

                    http://forum.falinux.com/zbxe/index.php?document_srl=625195&mid=lecture_tip
                    http://forum.falinux.com/zbxe/index.php?document_srl=627996&mid=lecture_tip

                    http://www.vogella.com/tutorials/EclipseGit/article.html


Groovy 시작입문   : http://www.slideshare.net/meadunhansa/groovy-42475432

                    http://www.slideshare.net/SukjinYun1/start-groovy

----------------------------------------------------------------------------------------------------

    Site           : https://github.com/

    Account        : grtlinux / [PWD]

    Git Repository : https://github.com/grtlinux/First.git

----------------------------------------------------------------------------------------------------

Git에 관련된 기본적인 개념 설명은 다음 사이트들에 잘 정리되어 있으니 참고하도록 합니다.
- http://rogerdudler.github.io/git-guide/index.ko.html
- http://maskkwon.tistory.com/129

여기에서 다루는 Git 사용법은 원격으로 Git을 관리하는 서버가 존재하고 이 원격 서버로부터 파일을 주고받는 구조입니다. 원격 저장소를 생성하고 관리하는 것을 먼저 다루고 이 원격 저장소로부터 파일을 push, pull을 하는 로컬 저장소를 다루도록 하겠습니다.


0. 사용자 등록
 사용자 등록이라고 해서 회원가입과 같은 거창한 것은 아니고, push를 할 때 어떤 사람이 push를 했는지 확인하기 용이하게 하기 위해 user의 정보를 등록하는 것 뿐입니다. 로컬에서 다음과 같은 명령어를 통해 유저 정보를 등록해줍니다.
 $git config --global user.name "유저의 이름"
 $git config --global user.email "유저의@이메.일"



1. Git 원격 저장소 만들기

 서버에 접속을 해서 원격 저장소로 사용할 폴더를 만들어주고 해당 폴더로 이동합니다.
 예)
 $mkdir GitServer.git
 $cd GitServer.git
 폴더명 뒤에는 관습적으로 .git을 붙여줍니다. 이렇게 이동한 폴더에서 bare 옵션을 이용하여 bare repository로 초기화해줍니다.
 $git init --bare
 이 bare repository는 서버 역할을 하는 repository로서 해당 폴더에서는 git 명령어를 사용할 수 없습니다. 이렇게 생성한 repo에는 자동적으로 원격 저장소가 필요로 하는 파일과 폴더들이 생성됩니다.
 이렇게 하면 원격 저장소를 만드는 것이 끝납니다. 이제 이 원격 저장소와 파일을 주고받는 로컬 저장소를 만들어 보겠습니다.



2. Git 로컬 저장소 만들기

 저장소로 만들 폴더로 이동을 하고 아래와 같은 명령어를 입력합니다. 저장소로 만들 폴더 안에 프로젝트 파일이 있어도 상관 없습니다.
 $git init
 이 과정을 거치면 해당 폴더에 .git이라고 하는 숨김파일이 생성이 됩니다. 이제 해당 폴더 안에 있는 모든 파일들을 commit 가능하도록 스테이지 영역에 파일들을 추가해줍니다.
 $git add *
 이 명령어를 통해 해당 폴더 안에 있는 모든 파일들을 추가할 수 있습니다.  이렇게 스테이지 영역에 추가 된 파일들은 commit 명령어를 통해 로컬 저장소로 commit이 가능한 것입니다. 즉 프로젝트를 진행하다가 파일이 추가가 될 경우 위 명령어를 활용해서 해당 파일을 스테이지에 계속 추가를 해줘야 하는 것입니다. 이렇게 추가된 파일들은 다음과 같은 명령어로 커밋이 가능합니다.
 $git commit -m "init project"
 init project라는 메세지와 함께 로컬 저장소에 파일들을 commit 합니다. 메세지를 이용하면 해당 commit 내용이 무엇인지 추후에 확인하기 용이합니다.
 이제 로컬 저장소에 있는 파일들을 원격 저장소로 전송하는 환경을 설정하도록 하겠습니다. 로컬 저장소 폴더에서 아래와 같은 명령어를 실행합니다.
 $git remote add origin username@hostname:GitServer.git
  어느 주소로 push를 할 것인지 설정을 해 줍니다. 예를 들어, 서버 계정이 gitmanager이고 IP주소가 123.123.123.123이며 원격 저장소의 경로가 ~/repo/GitServer.git이고 80번 포트를 이용해서 접근을 해야하는 경우 다음과 같이 입력을 해 줍니다.
 예)
 $git remote add origin ssh://gitmanager@123.123.123.123:80/~/repo/GitServer.git
 프로토콜을 어떤 것을 사용하는지는 자유지만 일반적으로 Git에서는 SSH를 사용하길 권장합니다. 다른 프로토콜에 비해 push와 pull이 자유롭기 때문입니다. (그래서 일반적으로 22번 포트를 사용하지만 학교나 회사의 경우 80번 포트를 제외하고는 전부 막아 놓는 경우가 많았습니다. 그래서 외부 포트 80번과 내부 포트 22번 포트를 포워딩해서 사용하기도 합니다.)
 만일  remote를 설정하는데 값을 잘못 입력했을 경우 아래의 명령어를 통해 수정 가능합니다.
 $git remote set-url origin username@hostname:GitServer.git
 이렇게 어느 원격 저장소로 push를 할 것인지 설정도 끝났다면 원격 저장소로 파일을 보낼 준비가 끝난 것입니다. 다음과 같은 명령어를 통해 파일을 push할 수 있습니다.
 $git push origin master
 master라고 하는 이름의 branch로 파일을 push합니다. 마지막으로 파일을 pull, push를 할 branch를 설정해주면 모든 작업이 끝나게 됩니다.
 $git branch --set-upstream master origin/master
 이제 자유롭게 push, pull을 할 수 있습니다.



 3. 원격 저장소로부터 프로젝트 파일을 그대로 가져오기

 프로젝트 초기에 PL이 위와 같이 Git을 설정해주고 팀원들이 해당 프로젝트 파일을 그대로 원격에서 받아오면 위와 같은 설정을 새로 할 필요가 없습니다. 원격 저장소에 업로드 된 프로젝트 파일들을 그대로 로컬로 복사해 오는 것을 clone이라고 합니다.
 $git clone username@hostname:GitServer.git
 이렇게 명령어 한 줄로 프로젝트 파일을 원격 저장소로부터 복사해 올 수 있습니다. 프로젝트를 복사해오면 해당 프로젝트 폴더명 그대로 새로운 폴더가 하나 생성이 되고 그 안에 프로젝트 파일이 들어있게 됩니다. (위의 예로는 GitServer라는 폴더가 생성됩니다.) git remote -v 명령어를 입력해보면 원격 저장소로 remote 경로가 설정이 되어있는 것을 확인할 수 있습니다.

 이렇게 기본적으로 git을 사용하는 방법에 대해서 알아봤습니다. 다음에는 Xcode와 연동하여 Git을 사용하는 법을 알아보겠습니다.


----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------

----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------

public class FTPDownloadFileDemo {

	public static void main(String[] args) {
		String server = "www.myserver.com";
		int port = 21;
		String user = "user";
		String pass = "pass";

		FTPClient ftpClient = new FTPClient();
		try {

			ftpClient.connect(server, port);
			ftpClient.login(user, pass);
			ftpClient.enterLocalPassiveMode();
			ftpClient.setFileType(FTP.BINARY_FILE_TYPE);

			// APPROACH #1: using retrieveFile(String, OutputStream)
			String remoteFile1 = "/test/video.mp4";
			File downloadFile1 = new File("D:/Downloads/video.mp4");
			OutputStream outputStream1 = new BufferedOutputStream(new FileOutputStream(downloadFile1));
			boolean success = ftpClient.retrieveFile(remoteFile1, outputStream1);
			outputStream1.close();

			if (success) {
				System.out.println("File #1 has been downloaded successfully.");
			}

			// APPROACH #2: using InputStream retrieveFileStream(String)
			String remoteFile2 = "/test/song.mp3";
			File downloadFile2 = new File("D:/Downloads/song.mp3");
			OutputStream outputStream2 = new BufferedOutputStream(new FileOutputStream(downloadFile2));
			InputStream inputStream = ftpClient.retrieveFileStream(remoteFile2);
			byte[] bytesArray = new byte[4096];
			int bytesRead = -1;
			while ((bytesRead = inputStream.read(bytesArray)) != -1) {
				outputStream2.write(bytesArray, 0, bytesRead);
			}

			success = ftpClient.completePendingCommand();
			if (success) {
				System.out.println("File #2 has been downloaded successfully.");
			}
			outputStream2.close();
			inputStream.close();

		} catch (IOException ex) {
			System.out.println("Error: " + ex.getMessage());
			ex.printStackTrace();
		} finally {
			try {
				if (ftpClient.isConnected()) {
					ftpClient.logout();
					ftpClient.disconnect();
				}
			} catch (IOException ex) {
				ex.printStackTrace();
			}
		}
	}
}


-------------------------------------------------------------------


오라클
스크립트로 Reverse Engineer 하여 Comment를 논리명으로 변경하기
1)  Tools => Reverse Engineer
    New Model Type : Logical/Physical 선택
    Toget Database : Oracle / 10.x/11.x 선택
    Next
    Reverse Engineer From : Script File 선택하여 파일 지정
2) Physical 모델 선택
   테이블 전체 선택
   테이블을 외 공간에서 마우스 오른쪽 클릭  => 메뉴 : Harden Physical Names 클릭
3) Logical 모델 선택

   Model => Domain dictionary
   Macro Toolbox 버튼 클릭
   Macros -> Attribute Macro -> %ColumnComment 선택
   Colse 버튼 클릭
   Name Inherited by Attribute : %ColumnComment 만 남기고 삭제
   OK 버튼 클릭

   Model => Attribute
   Reset 버튼 클릭
   Remove overrridden properties for : Reset all attributes in model 선택
   Select Properties to Reset : Definition 제거 / Domain Parent 제거 / Logical Data Type 제거
Logical Only 선택
   OK 버튼 클릭
4) 완료



----------------------------------------------------------------------------------------------------

[ IDEF1X <-> IE ] 모델 표기볍 변경

	Model > Model properties > Notation > IE/IDEF1X

----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------

Maven을 사용하려면 당연히 일단 설치부터 해야 한다...
아래 사이트에 가보면 Maven 다운로드 받을 수 있고 간단하게 설치하는 방법도 설명되어 있다.

http://maven.apache.org/download.html

그냥 압축 풀고 환경변수만 세팅해주면 끝난다.
제대로 설치했다면 커맨드 창에 mvn -version이란 명령이 실행되어야 한다.
윈도우즈 환경에서 실행했다면 아래와 비슷한 메세지가 출력되는 것을 볼 수 있다.

Maven version: 2.0.10
Java version: 1.6.0_06
OS name: "windows xp" version: "5.1" arch: "x86" Family: "windows"

개발툴로 이클립스를 사용한다면 이클립스에 플러그인도 하나 설치해주자..
http://m2eclipse.sonatype.org/update/

m2eclipse 말고 Q를 사용하고자 한다면 아래 플러그인을 설치하도록 하자... (어떤게 좋은지는 자기 맘~)
http://q4e.googlecode.com/svn/trunk/updatesite-iam/

설치가 끝났다.. 이제 한 번 Maven 프로젝트를 생성해보자..

Maven에서는 초간단하게 프로젝트를 만들 수 있는 템플릿을 제공하는데 아래와 같이 archetype 이란 플러그인을 사용하면 된다.
archetype에는 몇가지 goal들을 제공하는데 그 중에 create를 사용해보자.

mvn archetype:create -DgroupId=com.test.app -DartifactId=test-app

위의 명령을 실행하면 뭔가 막 다운로드 받으면서 마지막에 BUILD SUCCESSFUL 이란 글자를 확인할 수 있다.
처음 실행 시에 다운로드 받는 것들은 Remote Repository 에서 Local Repository 로 필요한 라이브러리를 복사하는 과정이다.
다음에 다시 실행하면 이미 받은 라이브러리들은 다운로드 받지 않게 된다.
그런데 실행 명령어를 자세히 살펴보면 create가 Deprecated 되었으니 generate를 사용하라고 나와있다.
친절하게 설명해주니깐 다음부터는 create 대신에 generate를 사용해주도록 하자.
아무튼 생성된 프로젝트를 살펴보면 아래와 같은 구조로 만들어져 있는 것을 볼 수 있다.

test-app
├ src
│ ├ main
│ │ └ java
│ │     └ com
│ │         └ test
│ │             └ app
│ │                 └ App.java
│ └  test
│      └ java
│          └ com
│              └ test
│                  └ app
│                      └ AppTest.java
└ pom.xml

일단 artifactId 가 루트 디렉토리로 생성되고 그 안에 아래와 같은 pom.xml 파일이 존재한다.

<project>
 <modelVersion>4.0.0</modelVersion>
 <groupId>com.test.app</groupId>
 <artifactId>test-app</artifactId>
 <packaging>jar</packaging>
 <version>1.0-SNAPSHOT</version>
 <name>Maven Quick Start Archetype</name>
 <url>http://maven.apache.org</url>
 <dependencies>
  <dependency>
   <groupId>junit</groupId>
   <artifactId>junit</artifactId>
   <version>3.8.1</version>
   <scope>test</scope>
  </dependency>
 </dependencies>
</project>

Maven에서 제공하는 기본 pom.xml 과 똑같은 형태이다.
아무튼 위에서 볼 수 있는 디렉토리 구조가 바로 Maven에서 사용하는 Standard Directory Layout 이다.
src 폴더에는 main 과 test 디렉토리가 있는데 각각의 디렉토리에 groupId 로 패키지가 만들어지고
해당 디렉토리에는 소스파일, 설정파일 등등이 위치하게 된다.
그리고 App.java 파일을 하나 생성해주는데 Hello World 프로그램이 하나 들어있다.

그렇다면 이제 컴파일을 하기 위해서 pom.xml 파일이 있는 test-app 디렉토리로 경로를 옮겨간다.
이 디렉토리가 test-app 프로젝트에서 ${basedir} 가 되고 이를 이용하여 pom.xml 에서 상수처럼 사용할 수 있다.
자세한 예는 나중에 나올 것 같으니 일단은 알아두고 넘어가자.
그렇다면 컴파일은 어떻게 해주면 될까?

mvn compile

정말 간단하다... -_-;;
제대로 했다면 아까 처럼 뭔가 다운로드 받다가 성공했다는 메세지를 볼 수 있을 것이다.
그런데 정말 잘 컴파일이 되었는지 궁금하다.
test-app 디렉토리를 잘 살펴보면 target/classes 디렉토리가 생성되어 있고 그 안에 컴파일된 파일이 있는 것을 볼 수 있다!
그런데 뭔가 좀 이상한 점이 있다...
어떻게 컴파일 하고 컴파일 한 결과를 저 디렉토리에다가 복사해놓았을까...
분명 pom.xml 에는 컴파일에 관련된 아무런 정보도 없는데...

이것이 바로 Convention Over Configuration 이다.
Maven 에서 아무런 설정을 하지 않는다면 소스 디렉토리는 src/main/java 디렉토리가 되고 타겟 디렉토리는 target/classes 가 된다.
위에서 생성된 pom.xml 에서 이런 설정들을 전혀 볼 수 없지만 비밀은 Super POM 이 가지고 있다.
모든 Maven 프로젝트는 Super POM을 상속하고 있고 따로 경로 설정을 하지 않는다면 위의 기본 설정을 사용하게 되는 것이다.
과연 어떻게 POM이 구성되는지 알아보려면 아래와 같은 명령을 사용하면 최종 POM 구조를 확인할 수 있다.

mvn help:effective-pom

위의 컴파일이 끝나면 소스 코드는 컴파일이 되지만 테스트 코드는 컴파일이 되지 않는다.
Maven은 Build Life Cycle 을 갖는데 compile 이란 goal 은 소스 코드를 컴파일 하는 역할까지만 하도록 되어 있는 것이다.
이렇게 만든 이유는 재사용이 용이하도록 하기 위해서라고 이전에 살펴본 바 있다.
그렇다면 이제 테스트 코드를 컴파일 하고 유닛 테스트를 실행해보도록 하자.

mvn test

끝이다... -_-;;
그냥 위와 같이 해주면 뭔가 다운로드가 끝나면 바로 테스트 코드 컴파일 하고 유닛 테스트까지 실행해준다.
실행 결과를 잘 살펴보면 test 를 실행시키면 compile 과 test-compile 이 먼저 실행되는 것을 볼 수 있을 것이다.
Build Life Cycle이 이렇게 실행되도록 구성되어 있기 때문이다.
(상위 레벨의 goal 을 실행하게 되면 하위 레벨의 goal 을 먼저 실행한다!!)
만약 테스트 컴파일까지만 하고 테스트를 실행하지 않고자 한다면 mvn test-compile 로 실행하면 된다.
일단 테스트를 실행하면 아래와 같이 surefile 플러그인이 담당하는 것을 확인할 수 있을 것이다.

-------------------------------------------------------
 T E S T S
-------------------------------------------------------
[surefire] Running com.test.app.AppTest
[surefire] Tests run: 1, Failures: 0, Errors: 0, Time elapsed: 0.001 sec
Results :
[surefire] Tests run: 1, Failures: 0, Errors: 0

여기서 한가지 알고 넘어가야 할 사실은 여기에도 Convention Over Configuration이 적용된다는 것이다.
surefire 플러그인은 기본적으로 다음과 같은 파일을 찾아서 테스트 코드를 실행시킨다.

**/*Test.java
**/Test*.java
**/*TestCase.java

그리고 기본적으로 다음과 같은 파일은 제외한다.

**/Abstract*Test.java
**/Abstract*TestCase.java

그냥 저런 네이밍 룰을 지키기만 하면 모든걸 편하게 할 수 있다.
이번에는 패키징과 인스톨을 알아보도록 하자.

mvn package

위와 같이 실행시켜주면 pom.xml 에 설정되어 있는 패키지로 (<packaging>jar</packaging> 라면 jar로) 만들어 준다.

mvn install

그리고 나서 위의 명령을 실행하면 Local Repository로 만들어진 jar 파일을 복사해주게 된다.

정말 초간단하게 프로젝트 하나 생성해서 컴파일, 테스트, 패키징, 인스톨까지 완료할 수 있다.
필요한 POM 설정 파일은 위에서 살펴본 pom.xml 파일이 전부이다.

Maven에서는 또 하나의 유용한 플러그인을 제공한다



위에 보는 화면은 방금 우리가 만든 프로젝트의 종합적인 정보를 보여주는 웹페이지다.
저걸 내가 작접 만든게 아니고 mvn site 명령을 실행하면 site 플러그인이 자동으로 만들어 준다.
지금까지 빌드된 내용을 삭제하고자 한다면 mvn clean 명령을 실행하면 된다.

그리고 사실 요즘에 누가 커맨드 창에서 일일이 입력하고 있을까 싶다..
Maven에서는 IntelliJ IDEA와 이클립스에서 사용할 수 있는 형태로 만들어주는 플러그인도 제공한다.

mvn eclipse:eclipse

위와 같이 실행하면 이클립스 프로젝트로 사용할 수 있도록 .project 파일과 .classpath 파일이 생성된다.
이클립스를 실행한 후에 프로젝트로 등록해서 사용하면 된다.
여기까지 간단하게 프로젝트를 생성하고 Maven을 사용하는 방법을 알아보았다.
[출처] Maven 설치 및 간단한 사용방법|작성자 죽빵에캔디



----------------------------------------------------------------------------------------------------

이번에는 Maven에서 각종 리소스 파일들을 어떻게 처리하는지 알아보도록 하자.
일단 Maven에서는 리소스 파일이 src/main/resources 디렉토리에 있으면 해당 파일들을 리소스 파일로 간주한다.
만약 해당 디렉토리에 아래와 같이 test.properties 란 파일이 있다면...

test-app
├ src
│ ├ main
│ │ ├ java
│ │ │└ com
│ │ │    └ test
│ │ │        └ app
│ │ │            └ App.java
│ │ └ resources
│ │    └ test.properties
│ └  test
│      └ java
│          └ com
│              └ test
│                  └ app
│                      └ AppTest.java
└ pom.xml

mvn complie 명령을 실행해주면 target/classes 폴더에 해당 파일이 복사되는 것을 확인할 수 있다.
만약 mvn install 명령을 실행했다면 생성된 jar 파일에는 다음과 같이 META-INF 폴더가 생성된다.

test-app-1.0-SNAPSHOT.jar
└ META-INF
    ├ maven
    │  └ com.test.app
    │      └ test-app
    │          ├ pom.properties
    │          └ pom.xml
    └ MANIFEST.MF

위의 정보는 자동으로 생성된다.
만약 MANIFEST.MF 파일을 직접 만들고 싶다면 maven-jar-plugin 을 사용하면 된다..
아래와 같이 해주면<manifestFile> 태그에 명시된 파일로 변경된다.

<build>
  <plugins>
    <plugin>
      <groupId>org.apache.maven.plugins</groupId>
      <artifactId>maven-jar-plugin</artifactId>
      <configuration>
        <archive>
          <manifestFile>META-INF/MANIFEST.MF</manifestFile>
        </archive>
      </configuration>
    </plugin>
  </plugins>
</build>

테스트 클래스패스 리소스도 src/test/resources 디렉토리에 만들어주면 된다.
일반 클래스패스 리소스와 다른 점은 하나도 없다.

자.. 이번에는 리소스 필터링에 대해서 알아보도록 하자.
Maven 에서는 리소스 파일을 동적으로 변경할 수 있는 기능을 가지고 있다.
즉 POM.xml에서 사용하고 있는 모든 속성들을 ${속성이름} 으로 리소스 파일에서 가져다 사용할 수 있다.
만약 아래와 같이 POM.xml 파일에서 filtering을 true로 설정했다면...

<project>
 <modelVersion>4.0.0</modelVersion>
 <groupId>com.test.app</groupId>
 <artifactId>test-app</artifactId>
 <packaging>jar</packaging>
 <version>1.0-SNAPSHOT</version>
 <name>test</name>
 <url>http://maven.apache.org</url>
 <dependencies>
  <dependency>
   <groupId>junit</groupId>
   <artifactId>junit</artifactId>
   <version>3.8.1</version>
   <scope>test</scope>
  </dependency>
 </dependencies>
 <build>
  <resources>
   <resource>
    <directory>src/main/resources</directory>
    <filtering>true</filtering>
   </resource>
  </resources>
 </build>
</project>

src/main/resource 디렉토리에 있는 test.properties 파일에...
project.name = ${project.name} 라고 저장하고 mvn process-resources 를 실행하면...
test.properties 파일의 내용은 project.name = test 로 변경된다.

다른 프로퍼티 파일에 있는 내용을 사용할 수도 있는데...

<build>
  <filters>
   <filter>src/main/filters/filter.properties</filter>
  </filters>
  <resources>
  <resource>
   <directory>src/main/resources</directory>
   <filtering>true</filtering>
  </resource>
  </resources>
</build>

위와 같이 설정하게 되면 filter.properties에 있는 속성도 ${속성이름} 형식으로 사용할 수 있게 된다.

POM.xml에서 직접 속성을 설정할 수도 있다.

 <properties>
  <test>
   <value>hello</value>
  </test>
  <greeting.hello>hi</greeting.hello>
 </properties>

위와 같이 설정하게 되면 ${test.value} 또는 ${greeting.hello} 속성을 사용할 수 있게 된다.

마지막으로 시스템 프로퍼티도 사용할 수가 있다.
예를 들어 java.version 이라던지 기타 등등 System 클래스에서 제공하는 프로퍼티들을 그대로 사용 가능하다.
심지어 -D 옵션으로 넘어오는 커맨드 라인 프로퍼티도 사용가능하다!!

만약 리소스 중에 위와 같은 필터링을 제외하고 싶은 리소스가 있는 경우에는 아래와 같이 설정해주면 된다.

 <build>
  <resources>
   <resource>
    <directory>src/main/resources</directory>
    <filtering>true</filtering>
    <excludes>
     <exclude>test/**</exclude>
    </excludes>
   </resource>
   <resource>
    <directory>src/main/resources</directory>
    <includes>
     <include>test/**</include>
    </includes>
   </resource>
  </resources>
 </build>

즉 필터링 시에 제외할 리소스를 <exclude> 설정을 통해 제외시키고 제외된 리소스만 따로 <include> 해주면 된다.
다소 복잡해 보일지도 모르겠지만 가만 살펴보만 아주 명시적인 방법이다.

이전에도 살펴보았지만 Maven에서는 빌드를 커스터마이징 할 수 있다.
새로운 플러그인을 추가해서 할 수도 있고 이미 추가되어 있는 플러그인에 파라미터를 설정해서 할 수도 있다.

예를 들어 자바 컴파일러로 JDK 5.0을 사용하고자 한다면 아래와 같이 설정하면 된다.

 <build>
  <plugins>
   <plugin>
    <groupId>org.apache.maven.plugins</groupId>
    <artifactId>maven-compiler-plugin</artifactId>
    <version>2.0</version>
    <configuration>
     <source>1.5</source>
     <target>1.5</target>
    </configuration>
   </plugin>
  </plugins>
 </build>

<plugin> 태그를 사용하면 되는데 <depedency>와 매우 사용방법이 유사하다.
한가지 다른 점이 있다면 <plugin>은 groupId와 version은 명시하지 않아도 된다는 것이다.
만약 groupId가 없다면 org.apache.maven.plugins 또는 org.codehaus.mojo에서 해당 groupId를 찾게 된다.
그리고 version이 없다면 가장 최신 버전으로 가져오게 된다.

플러그인에 대해 자세한 정보를 얻고자 한다면 아래 주소를 참고하도록 하자.
http://maven.apache.org/plugins

이로써 기본적인 사용 방법은 다 알아보았다.
과연 언제쯤 끝까지 다 볼 수 있을까... -_-;;
[출처] Maven Classpath Resource Management - 리소스를 관리해 보자~|작성자 죽빵에캔디



----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
[ maven jar를 Local Repository에 추가하기 ]

	개발을 진행하다보면 내부에서 사용하는 jar파일이라든지, jdbc에 관련된 jar 등.. maven repository에서
	제공하지 않는 jar파일들을 추가해야 할 경우가 생기는데

	가장 좋은 방법은 개발팀내에 중앙 repository를 만들어서 등록하고 사용하면 좋겠지만 상황이 여의치 않고
	번거롭다면..  WEB-INF/lib 폴더에 넣거나 build path로 잡아주면 된다.

	간편하게 local repository에 등록하고 사용하는 방법이 있다.
	dependecy 파일들을 아래와 같은 로컬경로에 다운로드 되어진다.

		C:\Users\Administrator\.m2\repository

		(XP) C:\Documents and Settings\사용자계정\.m2\repository

	추가하기 위해서 아래와 같은 명령어를 사용하게 된다.

		mvn install:install-file
			-Dfile=<path-to-file>         : 파일 full 경로 : 외부 repository 정보
			-DgroupId=<group-id>          : 그룹아이디
			-Dartifactid=<artifact-id>    : artifactid
			-Dversion=<version>           : 버전
			-Dpackaging=<packaging>       : jar
			-DgeneratePom=true            : true pom에 생성

		예) mvn install:install-file -Dfile=C\something.jar -DgroupId=com.test -DartifactId=first -Dversion=1.0 -Dpackaging=jar -DgeneratePom=true

	정상적으로 되었다면 아래와 같은 경로로 폴더와 파일이 생성된다.

		> dir C:\Users\Administrator\.m2\repository\com\test\first\1.0
			first-1.0.jar
			first-1.0.pom

	마찬가지로 해당정보가 pom.xml에 추가된다.

		<dependency>
			<groupId>com.test</groupId>
			<artifactId>first</artifactId>
			<version>1.0</version>
		</dependency>


-- mvn install:install-file -Dfile=.\libs\commons-net-3.3.jar                -DgroupId=kang.jar -DartifactId=commons-net              -Dversion=1.0 -Dpackaging=jar -DgeneratePom=true
mvn install:install-file -Dfile=.\libs\ibatis-2.3.4.726b.jar              -DgroupId=kang.jar -DartifactId=ibatis                   -Dversion=1.0 -Dpackaging=jar -DgeneratePom=true
mvn install:install-file -Dfile=.\libs\java-json.jar                      -DgroupId=kang.jar -DartifactId=java-json                -Dversion=1.0 -Dpackaging=jar -DgeneratePom=true
mvn install:install-file -Dfile=.\libs\log4j.jar                          -DgroupId=kang.jar -DartifactId=log4j                    -Dversion=1.0 -Dpackaging=jar -DgeneratePom=true
mvn install:install-file -Dfile=.\libs\modules.tain.0.151031.jar          -DgroupId=kang.jar -DartifactId=modules.tain             -Dversion=1.0 -Dpackaging=jar -DgeneratePom=true
mvn install:install-file -Dfile=.\libs\sas.core.jar                       -DgroupId=kang.jar -DartifactId=sas.core                 -Dversion=1.0 -Dpackaging=jar -DgeneratePom=true
mvn install:install-file -Dfile=.\libs\sas.core.nls.jar                   -DgroupId=kang.jar -DartifactId=sas.core.nls             -Dversion=1.0 -Dpackaging=jar -DgeneratePom=true
mvn install:install-file -Dfile=.\libs\sas.rutil.jar                      -DgroupId=kang.jar -DartifactId=sas.rutil                -Dversion=1.0 -Dpackaging=jar -DgeneratePom=true
mvn install:install-file -Dfile=.\libs\sas.security.sspi.jar              -DgroupId=kang.jar -DartifactId=sas.security.sspi        -Dversion=1.0 -Dpackaging=jar -DgeneratePom=true
mvn install:install-file -Dfile=.\libs\sas.servlet.jar                    -DgroupId=kang.jar -DartifactId=sas.servlet              -Dversion=1.0 -Dpackaging=jar -DgeneratePom=true
mvn install:install-file -Dfile=.\libs\sas.servlet.nls.jar                -DgroupId=kang.jar -DartifactId=sas.servlet.nls          -Dversion=1.0 -Dpackaging=jar -DgeneratePom=true
mvn install:install-file -Dfile=.\libs\sas.svc.connection.jar             -DgroupId=kang.jar -DartifactId=sas.svc.connection       -Dversion=1.0 -Dpackaging=jar -DgeneratePom=true
mvn install:install-file -Dfile=.\libs\sas.svc.connection.nls.jar         -DgroupId=kang.jar -DartifactId=sas.svc.connection.nls   -Dversion=1.0 -Dpackaging=jar -DgeneratePom=true
mvn install:install-file -Dfile=.\libs\sastpj.rutil.jar                   -DgroupId=kang.jar -DartifactId=sastpj.rutil             -Dversion=1.0 -Dpackaging=jar -DgeneratePom=true
mvn install:install-file -Dfile=.\libs\scsl.jar                           -DgroupId=kang.jar -DartifactId=scsl                     -Dversion=1.0 -Dpackaging=jar -DgeneratePom=true
-- mvn install:install-file -Dfile=.\libs\smeapi_2_7.jar                     -DgroupId=kang.jar -DartifactId=smeapi                   -Dversion=1.0 -Dpackaging=jar -DgeneratePom=true
mvn install:install-file -Dfile=.\libs\tdgssconfig.jar                    -DgroupId=kang.jar -DartifactId=tdgssconfig              -Dversion=1.0 -Dpackaging=jar -DgeneratePom=true
mvn install:install-file -Dfile=.\libs\terajdbc4.jar                      -DgroupId=kang.jar -DartifactId=terajdbc4                -Dversion=1.0 -Dpackaging=jar -DgeneratePom=true



----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------

Jakarta Commons Net API
FTP, TFTP
SMTP, POP3
telnet
Finger, Whois, Time, Echo 등
	Commons Net 라이브러리는 다양한 프로토콜에 대한 지원을 할 수 있는 구조를 갖고 있으며, 위 목록과 같이 이미 기존에 많이 사용되는 몇몇 프로토콜에 대한 클라이언트 모듈을 제공하고 있다. 또한, 개발자가 직접 프로토콜 처리를 하지 않아도 되기 때문에 관련 모듈을 빠르게 개발할 수 있는 장점도 있다.
	Commons Net 라이브러리 설치하기
	Commons Net 라이브러리는 http://jakarta.apache.org/commons/net 에서 다운로드 받을 수 있다. 현재 버전은 1.4.1 버전으로서, 다운로드 받은 파일의 압축을 풀면 commons-net-1.4.1.jar 파일이 생성되는데, 이 파일을 클래스패스에 추가해주면 된다
	.
	Commons Net은 Jakarta ORO API를 필요로 한다. Jakarta ORO 관련 모듈은 http://jakarta.apache.org/oro/index.html 사이트에서 다운로드 받을 수 있다. 현재 Jakarta ORO의 버전은 2.0.8로서, 배포판의 압축을 풀면 jakarta-oro-2.0.8.jar 파일이 생성되는데 이 파일을 클래스패스에 추가해면 설치가 완료된다.
	Commons Net API로 FTP 파일 송수신하기
	Commons Net API는 FTP와 관련해서 다음의 두 클래스를 제공하고 있다.
	org.apache.commons.net.ftp.FTPClient
	FTP 프로토콜 처리를 위한 API를 제공한다. 서버 연결, 로그인, 파일 목록, 송수신 등의 기능을 제공한다.
	org.apache.commons.net.ftp.FTPFile
	FTP 서버의 파일 표현할 때 사용되는 클래스. 파일명, 파일크기, 위치 등에 대한 정보를 제공한다.
	이 두 클래스만 사용하면 원격지의 FTP 서버로부터 원하는 파일을 송수신 할 수 있다. FTPClient API는 FTP 프로토콜과 관련해서 로그인, 파일 목록, 경로변경 등과 관련된 기능을 제공하는 데, 이들 기능과 관련된 메소드는 다음과 같다.
	메소드	설명
	conect(Strint server, int port)
	connect(String server)	FTP 서버에 접속한다. 포트 번호를 지정할 경우 해당 포트로 접속하며, 포트 번호를 지정하지 않으면 기본 포트인 21번 포트로 접속한다.
	login(String user, String pass)	지정한 사용자와 암호를 사용하여 로그인한다.
	changeWorkingDirectory(String path)	FTP 서버에서 현재 작업 디렉토리의 경로를 변경한다.
	String printWorkingDirectory()	현재 작업 디렉토리를 구한다.
	FTPFile[] listFiles()
	FTPFile[] listFiles(String path)	현재 작업 디렉토리에 있는 파일 목록을 구한다.
	경로를 지정할 경우 해당 경로의 파일 목록을 구한다.
	String[] listNames()
	FTPFile[] listFiles(String path)	현재 작업 디렉토리에 있는 파일 이름을 구한다.
	경로를 지정할 경우 해당 경로의 파일 이름을 구한다.
	makeDirectory(String path)	새로운 디렉토리를 생성한다.
	rename(String from, String to)	from에 해당하는 경로를 to로 변경한다.
	retriveFile(String remoteName, OutputStream local)	FTP 서버의 remoteName 파일을 local에 지정된 출력 스트림에 다운로드 한다. 성공적으로 완료되면 true를 리턴한다.
	InputStream retrieveFileStream(String remoteName)	FTP 서버의 remoteName 파일로부터 데이터를 읽어오는 입력 스트림을 리턴한다.
	storeFile(String remoteName, InputStream local)	local 입력 스트림으로부터 데이터를 읽어와 FTP 서버에 remoteName 경로로 업로드한다. 성공적으로 파일을 업로드 하면 true를 리턴한다.
	logout()	FTP 서버에서 로그아웃한다.
	disconnect()	서버와의 연결을 종료한다.
	이 외에 몇가지 메소드가 더 존재하지만, 일단 위 메소드 정도만 사용하면 충분히 FTP 프로토콜을 사용해서 파일을 송수신 할 수 있게 된다.
	파일 다운로드
	파일을 다운로드 하기 위해서는 다음과 같은 순서로 코드를 작성하면 된다.
	FTPClient.connect(): FTP 서버에 접속한다.
	FTPClient.login(): 로그인 한다.
	FTPClient.changeWorkingDirectory(): 파일이 있는 폴더로 이동한다.
	FTPClient.retrieveFile(): 파일을 다운로드 한다.
	FTPClient.logout(): 로그아웃한다.
	FTPClient.disconnect(): 연결을 종료한다.
	이를 실제 코드로 작성하면 다음과 같다.
	    FTPClient ftp = null;
	    try {
	        ftp = new FTPClient();
	        ftp.setControlEncoding("UTF-8");

	        ftp.connect("ftp.somehost");         ftp.login("user", "pass");         ftp.changeWorkingDirectory("/dbdump");

	        File f = new File("d:\\dbdump", "oradump1_200605.tmp");
	        FileOutputStream fos = null;
	        try {
	            fos = new FileOutputStream(f);
	            boolean isSuccess = ftp.retrieveFile("oradump1.tmp", fos);
	            if (isSuccess) {
	                // 다운로드 성공
	            } else {
	                // 다운로드 실패
	            }
	        } catch(IOException ex) {
	            System.out.println(ex.getMessage());
	        } finally {
	            if (fos != null) try { fos.close(); } catch(IOException ex) {}
	        }
	        ftp.logout();
	    } catch (SocketException e) {
	        System.out.println("Socket:"+e.getMessage());
	    } catch (IOException e) {
	        System.out.println("IO:"+e.getMessage());
	    } finally {
	        if (ftp != null && ftp.isConnected()) {
	            try { ftp.disconnect(); } catch (IOException e) {}
	        }
	    }

	파일 다운로드
	파일 업로드는 파일을 다운로드 하는 것과 크게 다르지 않다. 차이점이 있다면 retrieveFile() 메소드 대신 storeFile() 메소드를 사용한다는 것 뿐이다. 파일 업로드 하는 예제 코드는 다음과 같다.
	    FTPClient ftp = null;
	    try {
	        ftp = new FTPClient();
	        ftp.setControlEncoding("UTF-8");

	        ftp.connect("camp.cvnet.co.kr");
	        ftp.login("uniasset", "unisise");
	        ftp.changeWorkingDirectory("/dbdump");

	        File uploadFile = new File("d:\\today_log.txt");
	        FileInputStream fis = null;
	        try {
	            fis = new FileInputStream(uploadFile);
	            boolean isSuccess = ftp.storeFile(uploadFile.getName(), fis);
	            if (isSuccess) {
	                System.out.println("업로드 성공");
	            }
	        } catch(IOException ex) {
	            System.out.println(ex.getMessage());
	        } finally {
	            if (fis != null) try { fis.close(); } catch(IOException ex) {}
	        }
	        ftp.logout();
	    } catch (SocketException e) {
	        System.out.println("Socket:"+e.getMessage());
	    } catch (IOException e) {
	        System.out.println("IO:"+e.getMessage());
	    } finally {
	        if (ftp != null && ftp.isConnected()) {
	            try { ftp.disconnect(); } catch (IOException e) {}
	        }
	    }

	FTPFile 클래스
	FTPClient.listFiles() 메소드를 사용하면 현재 디렉토리의 파일 및 폴더 목록을 읽어올 수 있는데, 이 때 각 파일과 폴더는 FTPFile 객체로 표현된다. FTPFile 클래스는 파일 및 폴더에 대한 정보를 제공하는데, 이와 관련된 메소드는 다음과 같다.
	메소드	설명
	String getName()	파일의 이름을 구한다.
	String getSize()	파일의 크기를 구한다.
	boolean isDirectory()	폴더인 경우 true를 리턴한다.
	boolean isFile()	파일인 경우 true를 리턴한다.
	boolean isSymbolicLink()	심볼 링크인 경우 true를 리턴한다.
	String getLink()	심볼 링크인 경우 링크가 가리키는 파일의 이름을 리턴한다.
	Calendar getTimestamp()	생성날짜를 구한다.
	이 외에도 FTPFile 클래스는 파일의 소유자 및 그룹, 권한 관련 정보를 구할 수 있는 메소드를 제공하고 있다.
	결론
	본 글에서는 Jakarta Commons Net API를 사용하여 FTP 파일 업로드/다운로드 기능을 구현하는 방법을 살펴봤다. Commons Net API의 FTPClient 클래스는 개발자 대신 FTP 프로토콜을 처리해줌으로써 개발자가 빠르게 FTP 관련 기능을 구현할 수 있게 해준다는 것을 알 수 있었을 것이다. FTP 뿐만 아니라 SMTP/POP3, Telnet 등 다양한 프로토콜을 처리할 수 있는 클라이언트 모듈을 제공하고 있으므로, Commons Net을 사용하면 이들 프로토콜과 관련된 클라이언트 어플리케이션을 빠르게 개발할 수 있을 것이다.
	출처 : http://javacan.madvirus.net/main/content/read.tle?contentId=123#sectionTitleListA
	==========================================================================================
	Commons net
	I. Commons net
	Jakarta Commons의 net은 network utility collection입니다.
	인터넷 프로토콜을 대부분지원하는 강력한 유틸리티로 사용이 쉽고 간결합니다.
	클라이언트측의 기본적인 Internet protocol을 구현함으로서 고차원적인 abstract가 아닌 기본적인 프로토콜 access가 목적이기 때문에 부분적으로 object-orient 규칙에 위배되는 사항이 있다는것을 참고적으로 알자
	Commons net이 지원하는 프로토콜은 다음과 같다
	FTP
	NNTP
	SMTP
	POP3
	Telnet
	TFTP
	Finger
	Whois
	rexec/rcmd/rlogin
	Time (rdate) and Daytime
	Echo
	Discard
	NTP/SNTP
	FTP의 경우 이전에는 sun 패키지의 FtpClient를 사용했지만 이제는 Commons net의 FTP를 사용해 봅시다
	II. 준비물~
	Commons net은 자체적으로 ORO를 사용합니다
	Jakarta ORO란 파일이름의 치환, 분할, 필터링 등을 수행하기 위한 Perl5 호환 정규식, AWK와 같은 정규식, glob 표현, 그리고 유틸리티 클래스들을 제공하는 텍스트 처리 자바 클래스들입니다
	Commons net http://jakarta.apache.org/site/downloads/downloads_commons-net.cgi
	Jakarta ORO http://jakarta.apache.org/site/downloads/downloads_oro.cgi
	참고자료
	Commons net API http://jakarta.apache.org/commons/net/apidocs/index.html
	Commons net http://jakarta.apache.org/commons/net/
	III. org.apache.commons.net.ftp 의 흐름
	sun 패키지의 FTPClient처럼 FTP여러 동작을 Commons net의 FTPClient로 구현해 보자
	다음 ① ~ ⑦까지 목록은 필수항목으로 구현되어야 합니다.
	논리적으로 보면 간단합니다 ① FTPClient 생성
	먼저 가장 중심적인 역할을 하는 FTPClient를 생성합니다
	FTPClient ftpClient = new FTPClient();
	② FTPServer에 Connect
	서버에 연결을 합니다
	ftpClient.connect(server);
	③ 응답이 정상적인지 확인 합니다
	응답을 받아와서
	int reply = ftpClient.getReplyCode();
	정상적인지 확인해 봅니다
	if (!FTPReply.isPositiveCompletion(reply)) {
	정상적이지 않으면 연결을 끊고 종료 합니다
	ftpClient.disconnect();

	System.out.println("FTP server refused connection.");
	} else {
	정상적이면 계속 진행 합니다
	System.out.println("Connect successful");
	..
	}
	④ FTP Server 로그인
	ftpClient.login(username, password);
	⑤ 여러가지 작업을 합니다
	list, get, put...
	⑥ FTP Server 로그아웃
	ftpClient.logout();
	⑦ FTP Server disconnect
	ftpClient.disconnect();
	IV. 사용예제 - 목록보기
	본격적으로 FTP에 접속하여 목록을 가져오는 소스를 봅시다 FTPClient ftpClient = null;
	try {
	ftpClient = new FTPClient();
	ftpClient.setControlEncoding("euc-kr"); // 한글파일명 때문에 디폴트 인코딩을 euc-kr로 합니다
	ftpClient.connect("user.chollian.net"); // 천리안 FTP에 접속합니다
	int reply = ftpClient.getReplyCode(); // 응답코드가 비정상이면 종료합니다
	if (!FTPReply.isPositiveCompletion(reply)) {
	ftpClient.disconnect();
	System.out.println("FTP server refused connection.");
	} else {

	System.out.print(ftpClient.getReplyString()); // 응답 메세지를 찍어봅시다
	ftpClient.setSoTimeout(10000); // 현재 커넥션 timeout을 millisecond 값으로 입력합니다
	ftpClient.login(username, password); // 로그인 유저명과 비밀번호를 입력 합니다
	// 목록보기 구현
	FTPFile[] ftpfiles = ftpClient.listFiles("/public"); // public 폴더의 모든 파일을 list 합니다
	if (ftpfiles != null) {
	for (int i = 0; i < ftpfiles.length; i++) {
	FTPFile file = ftpfiles[i];
	System.out.println(file.toString()); // file.getName(), file.getSize() 등등..
	}
	}
	ftpClient.logout();
	}
	} catch (Exception e) {
	System.out.println(e);
	e.printStackTrace();
	} finally {
	if (ftpClient != null && ftpClient.isConnected()) {
	try {
	ftpClient.disconnect();
	} catch (IOException ioe) {
	ioe.printStackTrace();
	}
	}
	목록보기 방법에는 한가지 방법이 더 있습니다
	위의 코드는 해당 디렉토리내의 모든 파일을 가져오는 방법이며 다음 방법은 해당 디렉토리의 모든 파일을 정해진 수로 짤라 가져오는 방법이 있습니다.
	위의 빨간색 코드대신 다음 코드가 들어갈 수 있습니다.
	int page = 1;
	FTPListParseEngine engine = ftpClient.initiateListParsing("/public"); // 목록을 나타낼 디렉토리
	while (engine.hasNext()) {
	FTPFile[] ftpfiles = engine.getNext(10); // 10개 단위로 끊어서 가져온다

	System.out.println("------------------------ "+page+" ------------------------");
	if (ftpfiles != null) {
	for (int i = 0; i < ftpfiles.length; i++) {
	FTPFile file = ftpfiles[i];
	System.out.println(file.toString());
	}
	}
	System.out.println("------------------------ "+(page++)+" -------------------------");
	}
	V. 사용예제 - get (파일 다운로드)
	서버의 /public/테스트.txt 파일을 클라이언트의 C:\\Test\\테스트.txt 에 다운받는 예제 File get_file = new File("C:\\Test\\테스트.txt");
	OutputStream outputStream = new FileOutputStream(get_file);
	boolean result = ftpClient.retrieveFile("/public/테스트.txt", outputStream);
	outputStream.close();
	VI. 사용예제 - put(파일 업로드)
	클라이언트의 C:\\Test\\보내자.txt 파일을 서버의 /public/보내자.txt 에 업로드하는 예제
	만일 서버에 이미 /public/보내자.txt 파일이 있다면 덮어쓰게 된다 File put_file = new File("C:\\Test\\보내자.txt");
	inputStream = new FileInputStream(put_file);
	boolean result = ftpClient.storeFile("/public/보내자.txt", inputStream);
	inputStream.close();
	VII. 사용예제 - append (파일업로드)
	위의 예제와 같은 기능을 하지만 이미 파일에 동일한 파일이 있으면 false를 반환하면서 실행하지 않는다 File append_file = new File("C:\\Test\\더해라.txt");
	inputStream = new FileInputStream(append_file);
	boolean result = ftpClient.appendFile("/public/더해라.txt", inputStream);
	inputStream.close();
	VIII. 사용예제 - rename (파일 이름변경)
	변경전 파일명과 변경할 파일명을 파라미터로 준다 boolean result = ftpClient.rename("/public/바꾸기전파일.txt", "/public/바꾼후파일.txt");
	IX. 사용예제 - delete (파일삭제)
	삭제할 파일을 선택한다 boolean result = ftpClient.deleteFile("/public/test.txt");
	X. 사용예제 - directory 생성
	/public 에 oops 디렉토리를 생성한다 boolean result = ftpClient.makeDirectory("/public/oops");
	XI. 사용예제 - OS 커맨드 입력하기
	/public 에 oops 디렉토리를 생성한다 ftpClient.sendCommand(FTPCommand.MAKE_DIRECTORY, "/public/oops");
	sendCommand 함수에 FTPCommand의 실행할 OS명령을 static 멤버변수를 넘겨준다
	XII. 사용예제 - 작업디렉토리 설정하기
	작업디렉토리를 /public 설정한 후 oops 디렉토리를 설정한다 (위의 예제와 비교해보라!) ftpClient.changeWorkingDirectory("/public");
	boolean result = ftpClient.makeDirectory("oops"); // /public/oops 절대경로를 적지 않아도 된다
	XIII. 사용예제 - 파일 및 전송형태 설정
	파일 형태 설정 ftpClient.setFileType(FTP.BINARY_FILE_TYPE);
	파일 타입
	FTP.BINARY_FILE_TYPE, FTP.ASCII_FILE_TYPE, FTP.EBCDIC_FILE_TYPE, FTP.IMAGE_FILE_TYPE , FTP.LOCAL_FILE_TYPE
	이 값을 설정하지 않으면 디폴트는 ASCII 이다
	전송 형태 설정 ftpClient.setFileTransferMode(FTP.STREAM_TRANSFER_MODE);
	전송 타입
	FTP.BLOCK_TRANSFER_MODE, FTP.COMPRESSED_TRANSFER_MODE
	이값을 설정하지 않으면 디폴트는 FTP.STREAM_TRANSFER_MODE 이다
	XIV. FTP접속시 글목록이 보이지 않는경우 아래 URL을 참고하세요
	Jakarta Commons Net 에서 FTP 사용시 목록이 안보일 경우
	http://www.jakartaproject.com/article/jakarta/1132032615162
	목록이 안보일 경우 해결기 I탄
	http://www.jakartaproject.com/article/jakarta/1135307924491
	테스트한 파일을 첨부합니다 ^^

----------------------------------------------------------------------------------------------------
[ tain.kr.test ]

	1. WAS
		import tain.kr.test.ftp.v01.FtpReceiver
		import tain.kr.test.ftp.v01.FtpTransfer

	2. was/bin/realenv.sh
		tain.kr.test.realsystem.v01.RealSystem

	3.




----------------------------------------------------------------------------------------------------
[ maven ]

	1. http://www.sonatype.com/books/mvnex-book/reference/public-book.html
	2. http://www.slideshare.net/MikeEnsor/maven-3-overview-15845337
	3. http://www.slideshare.net/leefs/maven-7839125
	4. http://www.slideshare.net/croeder6000/maven-7847270




----------------------------------------------------------------------------------------------------
/*

오라클
스크립트로 Reverse Engineer 하여 Comment를 논리명으로 변경하기
1)  Tools => Reverse Engineer
    New Model Type : Logical/Physical 선택
    Toget Database : Oracle / 10.x/11.x 선택
    Next
    Reverse Engineer From : Script File 선택하여 파일 지정
2) Physical 모델 선택
   테이블 전체 선택
   테이블을 외 공간에서 마우스 오른쪽 클릭  => 메뉴 : Harden Physical Names 클릭
3) Logical 모델 선택

   Model => Domain dictionary
   Macro Toolbox 버튼 클릭
   Macros -> Attribute Macro -> %ColumnComment 선택
   Colse 버튼 클릭
   Name Inherited by Attribute : %ColumnComment 만 남기고 삭제
   OK 버튼 클릭

   Model => Attribute
   Reset 버튼 클릭
   Remove overrridden properties for : Reset all attributes in model 선택
   Select Properties to Reset : Definition 제거 / Domain Parent 제거 / Logical Data Type 제거
Logical Only 선택
   OK 버튼 클릭
4) 완료

*/



----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------

[ Maven DOS 창에서 실행시 HttpServlet symbol 에러 발생시 처리방법 pom.xml 위에 추가한다. ]

	<dependencies>
		<dependency>
			<groupId>javax.servlet</groupId>
			<artifactId>javax.servlet-api</artifactId>
			<version>3.1.0</version>
			<scope>compile</scope>
		</dependency>
	</dependencies>

----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------

//mvn install:install-file -DgroupId=kang.tain -DartifactId=commons-net            -Dversion=1.0 -Dpackaging=jar -Dfile=D:\PROJ\TEMP\SASEMARTCMS\libs\commons-net-3.3.jar
//mvn install:install-file -DgroupId=kang.tain -DartifactId=smeapi_2_7             -Dversion=1.0 -Dpackaging=jar -Dfile=D:\PROJ\TEMP\SASEMARTCMS\libs\smeapi_2_7.jar

mvn install:install-file -DgroupId=kang.tain -DartifactId=ibatis                 -Dversion=1.0 -Dpackaging=jar -Dfile=D:\PROJ\TEMP\SASEMARTCMS\libs\ibatis-2.3.4.726b.jar
mvn install:install-file -DgroupId=kang.tain -DartifactId=java-json              -Dversion=1.0 -Dpackaging=jar -Dfile=D:\PROJ\TEMP\SASEMARTCMS\libs\java-json.jar
mvn install:install-file -DgroupId=kang.tain -DartifactId=log4j                  -Dversion=1.0 -Dpackaging=jar -Dfile=D:\PROJ\TEMP\SASEMARTCMS\libs\log4j.jar
mvn install:install-file -DgroupId=kang.tain -DartifactId=modules.tain           -Dversion=1.0 -Dpackaging=jar -Dfile=D:\PROJ\TEMP\SASEMARTCMS\libs\modules.tain.0.151031.jar
mvn install:install-file -DgroupId=kang.tain -DartifactId=sas.core               -Dversion=1.0 -Dpackaging=jar -Dfile=D:\PROJ\TEMP\SASEMARTCMS\libs\sas.core.jar
mvn install:install-file -DgroupId=kang.tain -DartifactId=sas.core.nls           -Dversion=1.0 -Dpackaging=jar -Dfile=D:\PROJ\TEMP\SASEMARTCMS\libs\sas.core.nls.jar
mvn install:install-file -DgroupId=kang.tain -DartifactId=sas.rutil              -Dversion=1.0 -Dpackaging=jar -Dfile=D:\PROJ\TEMP\SASEMARTCMS\libs\sas.rutil.jar
mvn install:install-file -DgroupId=kang.tain -DartifactId=sas.security.sspi      -Dversion=1.0 -Dpackaging=jar -Dfile=D:\PROJ\TEMP\SASEMARTCMS\libs\sas.security.sspi.jar
mvn install:install-file -DgroupId=kang.tain -DartifactId=sas.servlet            -Dversion=1.0 -Dpackaging=jar -Dfile=D:\PROJ\TEMP\SASEMARTCMS\libs\sas.servlet.jar
mvn install:install-file -DgroupId=kang.tain -DartifactId=sas.servlet.nls        -Dversion=1.0 -Dpackaging=jar -Dfile=D:\PROJ\TEMP\SASEMARTCMS\libs\sas.servlet.nls.jar
mvn install:install-file -DgroupId=kang.tain -DartifactId=sas.svc.connection     -Dversion=1.0 -Dpackaging=jar -Dfile=D:\PROJ\TEMP\SASEMARTCMS\libs\sas.svc.connection.jar
mvn install:install-file -DgroupId=kang.tain -DartifactId=sas.svc.connection.nls -Dversion=1.0 -Dpackaging=jar -Dfile=D:\PROJ\TEMP\SASEMARTCMS\libs\sas.svc.connection.nls.jar
mvn install:install-file -DgroupId=kang.tain -DartifactId=sastpj.rutil           -Dversion=1.0 -Dpackaging=jar -Dfile=D:\PROJ\TEMP\SASEMARTCMS\libs\sastpj.rutil.jar
mvn install:install-file -DgroupId=kang.tain -DartifactId=scsl                   -Dversion=1.0 -Dpackaging=jar -Dfile=D:\PROJ\TEMP\SASEMARTCMS\libs\scsl.jar
mvn install:install-file -DgroupId=kang.tain -DartifactId=tdgssconfig            -Dversion=1.0 -Dpackaging=jar -Dfile=D:\PROJ\TEMP\SASEMARTCMS\libs\tdgssconfig.jar
mvn install:install-file -DgroupId=kang.tain -DartifactId=terajdbc4              -Dversion=1.0 -Dpackaging=jar -Dfile=D:\PROJ\TEMP\SASEMARTCMS\libs\terajdbc4.jar

		<!--
		<dependency><groupId>kang.tain</groupId><artifactId>commons-net</artifactId><version>1.0</version></dependency>
		<dependency><groupId>kang.tain</groupId><artifactId>smeapi_2_7</artifactId><version>1.0</version></dependency>
		-->
		<dependency><groupId>kang.tain</groupId><artifactId>ibatis</artifactId><version>1.0</version></dependency>
		<dependency><groupId>kang.tain</groupId><artifactId>java-json</artifactId><version>1.0</version></dependency>
		<dependency><groupId>kang.tain</groupId><artifactId>log4j</artifactId><version>1.0</version></dependency>
		<dependency><groupId>kang.tain</groupId><artifactId>modules.tain</artifactId><version>1.0</version></dependency>
		<dependency><groupId>kang.tain</groupId><artifactId>sas.core</artifactId><version>1.0</version></dependency>
		<dependency><groupId>kang.tain</groupId><artifactId>sas.core.nls</artifactId><version>1.0</version></dependency>
		<dependency><groupId>kang.tain</groupId><artifactId>sas.rutil</artifactId><version>1.0</version></dependency>
		<dependency><groupId>kang.tain</groupId><artifactId>sas.security.sspi</artifactId><version>1.0</version></dependency>
		<dependency><groupId>kang.tain</groupId><artifactId>sas.servlet</artifactId><version>1.0</version></dependency>
		<dependency><groupId>kang.tain</groupId><artifactId>sas.servlet.nls</artifactId><version>1.0</version></dependency>
		<dependency><groupId>kang.tain</groupId><artifactId>sas.svc.connection</artifactId><version>1.0</version></dependency>
		<dependency><groupId>kang.tain</groupId><artifactId>sas.svc.connection.nls</artifactId><version>1.0</version></dependency>
		<dependency><groupId>kang.tain</groupId><artifactId>sastpj.rutil</artifactId><version>1.0</version></dependency>
		<dependency><groupId>kang.tain</groupId><artifactId>scsl</artifactId><version>1.0</version></dependency>
		<dependency><groupId>kang.tain</groupId><artifactId>tdgssconfig</artifactId><version>1.0</version></dependency>
		<dependency><groupId>kang.tain</groupId><artifactId>terajdbc4</artifactId><version>1.0</version></dependency>


----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------

ibatis를 쓰다보면 쿼리를 out으로 출력하고 싶을때가 많지요
일단 file로 생성하는건 추후에 포스팅 하고, 로컬에서 console에 찍는방법을 정리하겠습니다.

WEB-INF/lib/log4.jar
WEB-INF/classes/log4j.properties

	# Global logging configuration
	# 에러가 발생했을시 출력
	log4j.rootLogger=ERROR, stdout

	# SqlMap logging configuration
	# 쿼리를 출력하고 싶으므로, DEBUG레벨로 설정
	log4j.logger.java.sql.Connection=DEBUG
	log4j.logger.java.sql.Statement=DEBUG
	log4j.logger.java.sql.PreparedStatement=DEBUG
	# 쿼리가 이중으로 출력되므로, false처리
	log4j.additivity.java.sql.Connection=false

	# Console output
	log4j.appender.stdout=org.apache.log4j.ConsoleAppender
	log4j.appender.stdout.Append=false
	log4j.appender.stdout.layout=org.apache.log4j.PatternLayout
	log4j.appender.stdout.layout.ConversionPattern=%5p ({%t} %F[%M]:%L) [%d] - %m%n

web.xml에
	<param-value>
		/WEB-INF/classes/log4j.properties
	</param-value>

추가하면 끝입니다.


파일에 출력할 로그 레벨을 지정
	log4j.appender.file.Threshold=DEBUG

----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------

[ eclipse java 자동 주석 ]

	1. 세팅하기
		Window >  Preferences > C/C++ > Code Style > Code Templates
		Comments 하부의 Files, Types, Fields, Methods, Constructors, Destructors
		각 항목을 선택하여 Edit 버튼 클릭하여 원하는 형태로 구성 가능

	2. 주석 사용하기 (shift + ALT + J )
		클래스 생성시 생성 화면 맨 아래에 [주석생성] 체크 박스가 있습니다. 체크하고 [완료]버튼 클릭하면 파일주석이 생성됩니다.
		클래스와 메소드주석은 클래스나 메소드명이 있는 라인에서 마우스 R-버튼 클릭 후 [소스]-[요소주석생성]을 클릭하면 주석이 자동 생성됩니다.

	3. 파일 주석 사용하기
		파일 주석은 단축키를 사용하지 않고 파일 생성 시 templete 를 선정하여 초기 설정 되도록 한다.

	4. Comments 항목 설정 예시
		${} 내용설명
		
		date : Current date
		dollar : The dollar symbol
		enclosing_type : The type enclosing the method
		file_name : Name of the enclosing compilation
		package_name : Name of the enclosing package
		project_name : Name of the enclosing project
		tags : Generated Javadoc tags (@params, @return...)
		time : Current time
		todo : Todo task tag
		type_name : Name of the current type
		user : user name
		year : current year
		
		
		[Files]
			/**
			* 0. Project  : XXXX 프로젝트
			*
			* 1. FileName : ${file_name}
			* 2. Package : ${package_name}
			* 3. Comment :
			* 4. 작성자  : ${user}
			* 5. 작성일  : ${date} ${time}
			* 6. 변경이력 :
			*                    이름     : 일자          : 근거자료   : 변경내용
			*                   ------------------
			*                    ${user} : ${date} :            : 신규 개발.
			*/

			/**
			 * Copyright 2014, 2015, 2016. TAIN, Inc. all rights reserved.
			 *
			 * Licensed under the GNU GENERAL PUBLIC LICENSE, Version 3, 29 June 2007 (the "License");
			 * you may not use this file except in compliance with the License.
			 * You may obtain a copy of the License at
			 *
			 *      http://www.gnu.org/licenses/
			 *
			 * Unless required by applicable law or agreed to in writing, software
			 * distributed under the License is distributed on an "AS IS" BASIS,
			 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
			 * See the License for the specific language governing permissions and
			 * limitations under the License.
			 *
			 * -----------------------------------------------------------------
			 * Copyright 2014, 2015 TAIN, Inc.
			 */

			/**
			 *
			 * Copyright 2009 the original author or authors.
			 *
			 * Licensed under the Apache License, Version 2.0 (the "License");
			 * you may not use this file except in compliance with the License.
			 * You may obtain a copy of the License at
			 *
			 *      http://www.apache.org/licenses/LICENSE-2.0
			 *
			 * Unless required by applicable law or agreed to in writing, software
			 * distributed under the License is distributed on an "AS IS" BASIS,
			 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
			 * See the License for the specific language governing permissions and
			 * limitations under the License.
			 *
			 */

			/**
			 * Copyright 2016 the original author or authors.
			 *
			 * Licensed under the GNU GENERAL PUBLIC LICENSE, Version 3, 29 June 2007 (the "License");
			 * you may not use this file except in compliance with the License.
			 * You may obtain a copy of the License at
			 *
			 *      http://www.gnu.org/licenses/
			 *
			 * Unless required by applicable law or agreed to in writing, software
			 * distributed under the License is distributed on an "AS IS" BASIS,
			 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
			 * See the License for the specific language governing permissions and
			 * limitations under the License.
			 *
			 * -----------------------------------------------------------------
			 *
			 * Code Templates > Comments > Files
			 *
			 * 1. Project    : Tools check project
			 * 2. FileName   : ${file_name}
			 * 3. Package    : ${package_name}
			 * 4. Comment    :
			 * 5. Author     : ${user}
			 * 6. First Date : ${date} ${time}
			 * 7. History
			 *     ${user} : ${date} :
			 *
			 */

		[Class]
			/**
			* <PRE>
			* 1. ClassName : ${enclosing_type}
			* 2. FileName  : ${file_name}
			* 3. Package  : ${package_name}
			* 4. Comment  :
			* 5. 작성자   : ${user}
			* 6. 작성일   : ${date} ${time}
			* </PRE>
			*/

			/**
			 * Code Templates > Comments > Types
			 *
			 * <PRE>
			 *   1. ClassName  : ${enclosing_type}
			 *   2. FileName   : ${file_name}
			 *   3. Package    : ${package_name}
			 *   4. Comment    :
			 *   5. Author     : ${user}
			 *   6. First Date : ${date} ${time}
			 * </PRE>
			 *
			 * @author ${user}
			 *
			 * ${tags}
			 */

		[Constructors]
			/**
			* <PRE>
			* 1. MethodName : ${enclosing_type}
			* 2. ClassName  : ${enclosing_type}
			* 3. Comment   :
			* 4. 작성자    : ${user}
			* 5. 작성일    : ${date} ${time}
			* </PRE>
			*   ${tags}
			*/

			/**
			 * Code Templates > Comments > Constructors
			 *
			 * <PRE>
			 *   1. MethodName : ${enclosing_type}
			 *   2. ClassName  : ${enclosing_type}
			 *   3. Comment    :
			 *   4. Author     : ${user}
			 *   5. First Date : ${date} ${time}
			 * </PRE>
			 *
			 * ${tags}
			 */

		[Method]
			/**
			* <PRE>
			* 1. MethodName : ${enclosing_method}
			* 2. ClassName  : ${enclosing_type}
			* 3. Comment   :
			* 4. 작성자    : ${user}
			* 5. 작성일    : ${date} ${time}
			* </PRE>
			*   @return ${return_type}
			*   ${tags}
			*/

			/**
			 * Code Templates > Comments > Constructors
			 *
			 * <PRE>
			 *   1. MethodName : ${enclosing_method}
			 *   2. ClassName  : ${enclosing_type}
			 *   3. Comment    :
			 *   4. Author     : ${user}
			 *   5. First Date : ${date} ${time}
			 * </PRE>
			 *
			 * ${tags}
			 */



----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
[ Eclipse 단축키 ]

	Eclipse 단축키 확인 및 변경
	Eclipse의 모든 단축키는 Window >> Preferences >> Workbench >> Keys 메뉴에서 확인 및 변경이 가능하다. 그 동안 다른 툴에서 자신의 손에 익숙한 단축키들이 있다면 이 메뉴에서 단축키들을 변경하는 것이 가능하다.

	Java Editor 단축키
	Ctrl + Shift + M : 특정 클래스 Import 시키기
	Ctrl + Shift + O : 자동으로 Import 시키기
	Ctrl + Shift + F : 코드 자동 정리
	Ctrl + Shift + G : 특정 메써드나 필드를 Reference하고 있는 곳을 찾는다.
	Ctrl + 1 : Quick Fix. 에러가 발생했을 경우 Quick Fix를 통해 쉽게 해결이 가능하다.
	Ctrl + Shift + / : 블럭 주석 설정
	Alt + Shift + UP : 커서를 기준으로 토큰단위 블럭지정
	Alt + Shift + DOWN : 커서를 기준으로 토큰단위 블럭해제
	CTRL + L : 특정 줄번호로 가기
	Alt + Shift + J : 자동으로 주석 달기 (메소드나 멤버변수에 포커스 두고 실행)

	Window 이동
	F10 : 메뉴창을 활성화
	Ctrl + F8 : 다음 Perspective로 이동
	Ctrl + N : 새로운 파일 및 프로젝트 생성.
	Ctrl + Shift + Down : Java Editor에서 다음 member로 이동.
	Ctrl + F7 : 다음 View로 이동.
	Ctrl + Shift + F7 : 이전 View로 이동.
	Alt + <- : 이전 작업 화면
	Alt + -> : 다음 작업 화면
	F12 : 컴파일 중 에러등으로 포커스가 다른데로 갔을 때 Editor 로 커서 이동
	Ctrl + 1 : 컴파일 에러가 발생한 곳에서 Ctrl + 1을 누를 경우 컴파일 에러에 대한 해결책을 제시

	디버깅 단축키
	CTRL + Shift + B : 현 커서의 위치에 브레이크 포인터 설정/해제
	F11 : 디버깅 시작
	F8 : 디버깅 계속
	F6 : 한줄씩 실행(Step Over)
	F5 : 한줄씩 실행하되 함수일 경우 그 함수 내부로 들어감(Step Into)
	CTRL + R : 현재 라인까지 실행(Run to Line)

	Refactoring 단축키
	Shift + ALT + 알파벳 : Refactoring을 위한 단축키 임.

	RUN 단축키
	Ctrl + F11 : 이전에 실행되었던 Run파일 실행.

----------------------------------------------------------------------------------------------------
[ 유용한 TIP ] 이클립스 - 단축키

	보기시 전에 필요하신것만 ctrl + f 하셔서 봅시다 많아요ㅎㅎ;

	1) 코딩을 할 때 라인 번호가 있어야 편하다.
	워크벤치-에디터-텍스트 에디터-쇼라인넘버즈
	어플라이 하면 된다.

	2) 코드 스타일 바꾸기
	Windows > Prefrences >
	Java > Code Style > Formatter
	하나를 만들어서 그거 이용하도록
	에디터에서 적용방법 : Ctrl + Shift + F 또는 Source > Format
	특정부분만 적용하려면 블록 후 Ctrl + Shift + F

	3) 퍼스펙티스 설정 저장
	WIndow > Save Perspective As

	(4) 코드 어시스트 Ctrl + Space
	for, while 자동완성
	sysout 자동완성
	템플릿 설정은 Preferences
	Java > Editor > Templates
	Actio 정도만 치고 Ctrl+Space를 치면 적당한 후보를 내줍니다.
	요것도 여러번 연습해서 습관이 되도록 하셔야겠지요.
	for(int i = 0; i < array.length; i++)
	이거 치기 참 힘드시죠?
	for만 치시고 ctrl+space 누르시면
	슈루룩 완성이 됩니다.
	중간에 바꿔야 할건 tab키를 이용하면 바꿀 수 있고요.

	(5) Quick fix
	에러난 줄에 노란전구가 있으면 Ctrl + 1 눌러서 방법중 하나 고르면 수정된다.
	빨간 줄이 보이세요? 커서를 올려놓고 기다려보세요.
	올려놓고 기다리시면 왜 빨간줄이 나왔는지 나옵니다.
	도대체 어떻게 고쳐야할지 모르겠다 싶으시면
	한번 Ctrl+1을 눌러보세요. 알아서 고쳐줄지도 모릅니다.
	(안고쳐줄때도 많긴 합니다만, 편할때도 많습니다^^)
	(6) Quick Type Hierarchy
	메서드, 타입, 패키지를 선택하고 Ctrl + T
	한번 더 누르면 뒤집어짐
	(7) Quick Outline
	Ctrl + 0 키를 누르면 바로 필터링됨
	(8) 소스 코드 네비게이션
	정의로 바로가기 : F3
	다시 돌아오기 : Alt + <- , 다시 정의보기 : Alt + ->
	Ctrl 누르고 있으면 각 요소가 하이퍼링크 모양으로 바뀜 : 이때 마우스 클릭시 이동
	해당라인 이동 : Ctrl + L

	(9) Mark Occurences
	툴바버튼이 눌려있으면 커서가 위치한 요소는 사용처가 다 보임
	(10) getter, setter, 생성자
	소스에서 Source > 해서 선택
	(11) 소스비교
	우클릭 > Compare with > Local History
	Replace With > Local History
	Restore from Local HIstory
	(12) 에디터간 이동
	많아지면 오른쪽 >> 클릭
	Ctrl + F6 :

	(13) 뷰 간 이동
	Ctrl + F7
	(14) 퍼스펙티브간 이동
	Ctrl + F8
	(15) 에디터로 돌아오기
	어디에 있든 F12

	(16) 찾기
	점증적찾기 : Ctrl + J (아래에 Incremental File표시)
	그리고 단어입력
	그리고 Ctrl + J 클릭시 다음단어 찾음 (Ctrl + Shift + J는 반대)
	블록선택후 Ctrl + K 클릭시 다음단어
	검색기능
	일반 검색 : Ctrl + F
	마우스로 드레그한 항목 아래로 검색 : Ctrl + K
	마우스로 드레그한 항목 위로 검색 : Ctrl + Shift + K
	실시간 타이핑 검색 (아래로) : Ctrl + J
	실시간 타이핑 검색 (위로) : Ctrl + Shift + J
	(17)  소스편집
	원하는 라인으로 이동 : Ctrl + L
	한 라인 삭제 : Ctrl + D
	주석처리 : Ctrl + Shift + /     --->   형태 :
	                Ctrl + /    ----> 형태 : //
	자동 들여쓰기 정리 : Ctrl + I
	자동으로 임포트하기 : Ctrl + Shift + O
	소스창 전체화면 전환 : Ctrl + M
	System.out.println(); 간단하게 입력하기 : sysout 입력 후 Ctrl + Space
	try { } catch { } 간단하게 입력하기 : try 입력 후 Ctrl + Space
	for문 간단하게 입력하기 : for 입력 후 Ctrl + Space
	열린파일 이동할때 리스트 항목을 보고 선택하기 : Ctrl + F6
	Ctrl  +  Shift  +  O  -  Organize  Imports
	저장전에는  필히  import  구문을  정리  해주시고..
	Ctrl  +  Shift  +  F  -  Reformat  source
	저장전  소스  들여쓰기도  자동으로  정리해주시고
	Alt  +  Shift  +  J  -  Java  Doc  Comment  Create
	아직도  Java  Doc을  안다는가..  달어줘라  개발자의  센스다.  일일히  타이핑  하는가..
	이젠  이단축키  하나로..  메소드나  클래스  명에  위치시키고  눌러봐라.  파라미터,  throws를  분석하여  친절하게  Doc주석을  달어준다.
	--------------------------------------------------------------------------------
	1. 옮길 문장이 있는 줄을 아무데나 클릭한다.
	2. Alt키와 화살표(위로)키를 누른다.
	--------------------------------------------------------------------------------

	(18) 리펙토링
	1. Source 메뉴에는 재미있는 기능이 많습니다.
	- source =>Generate Getter and Setter를 보시면
	그동안 여러분을 괴롭혔던 mutator와 accessor를 편하게 구현하실 방법이 들어있습니다.
	- source => Generate Constructors using Fields에서는
	class variable만 선언하면 constructor가 자동으로 만들어지게 해줍니다.

	ALT + SHIFT + Z = 블록설정 후 try-catch 문 덮어서 만들어주기
	(19) 디버깅
	2. 버그가 있으십니까? 디버깅을 해보세요. (고급기능, 그러나 유용한 기능)
	Ctrl+Shift+B를 누르면 breakpoint가 걸리고,
	F11을 누르면 디버그 모드로 실행이 됩니다.
	디버그 모드에서는 breakpoint의 위치에서 어떤 변수가 어떤 값을 가지는지 볼 수 있고요,
	한줄 한줄 실행해가며(보통 F6, 함수로 들어갈때 F5) 볼 수도 있고요.
	디버깅에 대한 건 자세히 가면 책 한권정도 분량도 나오는데
	기본적인 건 당연한 것들이 많아서 혼자 해보다 보면 스스로 많은 교훈을 얻으실 수 있습니다.
	(자세한 도움이 필요하시면 메일을 보내시던지 주변에 물어보시고요 ^^)
	아. 디버깅을 하시다보면 perspective(창의 배치)가 달라집니다.
	이때 디버깅을 마치고 돌아오시려면 오른쪽 위에 Debug / Java라고 쓰인 곳에 가셔서 Java를 눌러주세요.

	(20) 주석처리
	Ctrl  +  Shift  +  /  -  instantly  toggling  comments
	소스를  일일히  주석처리  하는가.  블로  주석이라면  마우스로  긁어서  한번에  주석처리  하자.

	(21) 기타
	Alt  +Shift  +  T  -  Show  Refactor  Quick  Menu
	팝업에  Refactor  선택에  명령어  수행  너무많은  시간이  소비된다.  한번에  단축키로  호출하자
	(22) 단축키호출
	Ctrl  +  Shift  +  L  -  Hotkeys  Table  Call
	이클립스의  핫키  목록을  볼수있는  핫키
	Eclipse 단축키 확인 및 변경
	Eclipse의 모든 단축키는 Window >> Preferences >> Workbench >> Keys 메뉴에서 확인 및 변경이 가능하다. 그 동안 다른 툴에서 자신의 손에 익숙한 단축키들이 있다면 이 메뉴에서 단축키들을 변경하는 것이 가능하다.
	Java Editor 단축키
	Ctrl + Shift + M : 캐럿이 위치한 대상에 필요한 특정 클래스 Import 시키기
	Ctrl + Shift + O : 소스에 필요한 패키지를 자동으로 Import 시키기
	Ctrl + Shift + F : 소스코드 자동 정리
	Ctrl + Shift + G : 특정 메써드나 필드를 Reference하고 있는 곳을 찾는다.
	Ctrl + Shift + K : 이전찾기 (또는, 찾고자하는 문자열을 블럭으로 설정한 후 역으로 찾고자 하는 문자열을 찾아감.)
	Ctrl + shift + G : 특정 메써드나 필드를 참조하고 있는 곳을 찾는다.
	Ctrl + shift + B : 현재커서위치에 Break point설정/해제
	Ctrl + 1 : Quick Fix. 에러가 발생했을 경우 Quick Fix를 통해 쉽게 해결이 가능하다.(Rename에 주로 사용)
	Ctrl + 2 + R : Rename (리팩토링)
	Ctrl + Shift + / : 선택 영역 Block Comment 설정
	Ctrl + Shift + : 선택 영역 Block Comment 제거
	Ctrl + / : 한줄 또는 선택영역 주석처리 / 제거
	Ctrl + S : 저장 및 컴파일
	Ctrl + I : 소스 깔끔 정리(인덴트 중심의 자동구문정리)
	Ctrl + space : 어휘의 자동완성(Content Assistance)
	Ctrl + Q : 마지막 편집위치로 가기
	Ctrl + L : 특정줄번호로 가기
	Ctrl + D : 한줄삭제
	Ctrl + O : Outline 창 열기
	Ctrl + H : Find 및 Replace
	Ctrl + K : 다음찾기(또는, 찾고자 하는 문자열을 블럭으로 설정한 후 키를 누른다.)
	Ctrl + N : 새로운 파일 및 프로젝트 생성
	Ctrl + Shift + S : 열려진 모든파일 저장 및 컴파일
	Ctrl + 객체클릭(혹은 F3) : 클래스나 메소드 혹은 멤버를 정의한 곳으로 이동(Open Declaration)
	Alt + Shift + UP : 커서를 기준으로 토큰단위 블럭지정 (괄호의 열고 닫기 쌍 확인에 유용)  ==> 괄호의 뒤에 마우스 커서를 위치시킨 후 더블클릭한 것과 같은 효과
	Alt + Shift + DOWN : 커서를 기준으로 토큰단위 블럭해제
	Alt + Shift + J : 설정해 둔 기본주석을 자동으로 달기 (메소드나 멤버변수에 포커스 두고 실행)
	Alt + / : Word Completion
	Alt + Shift + R : Rename
	Alt + ->, Alt + <- : 이후, 이전
	해당 프로젝트에서 Alt + Enter : Project 속성
	sysout > Ctrl + Space : System.out.println();
	try > Ctrl + Space : 기본 try-catch문 완성
	for > Ctrl + Space : 기본 for문 완성
	템플릿을 수정,추가 : Preferences > java > editor > Templates
	Ctrl + Alt + R
	Ctrl + F11 : 실행
	F11 : 디버깅 시작
	F5 : step into
	F6 : step over
	F8 : 디버깅 계속
	Ctrl + .


	(23) 에러위치로 이동

	Ctrl + '.'

	(24) 키보드로 코드블럭 이동

	Alt + 위 화살표 혹은 아래 화살표

	(25) 나의 포맷 적용

	Ctrl + Shift + 'F'


----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------

static 함수에서 자기 자신 클래스 명 알아내기
=> 오브젝트 배열을 하나 만들어서 그걸 품고(enclosing)하고 있는 클래스가 자기 자신이다.


System.out.println(">" + new Object(){}.getClass().getEnclosingClass().getName());

[출처] static 함수에서 자기 자신 클래스 명 알아내기|작성자 캐나다여행



----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
